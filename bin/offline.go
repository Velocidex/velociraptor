package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"

	"github.com/Velocidex/ordereddict"
	errors "github.com/go-errors/errors"
	"www.velocidex.com/golang/velociraptor/config"
	"www.velocidex.com/golang/velociraptor/services"
	"www.velocidex.com/golang/velociraptor/startup"
	"www.velocidex.com/golang/velociraptor/uploads"
	"www.velocidex.com/golang/velociraptor/utils/tempfile"
	"www.velocidex.com/golang/velociraptor/vql/acl_managers"
)

var (
	// Command line interface for VQL commands.
	collector_cmd               = app.Command("collector", "Build an offline collector")
	spec_file                   = collector_cmd.Arg("spec_file", "A Spec file to use.").String()
	collector_command_datastore = collector_cmd.Flag(
		"datastore", "Path to a datastore directory (defaults to temp)").
		ExistingDir()

	collector_format = collector_cmd.Flag(
		"format", "Output format to use (text,json,csv,jsonl).").
		Default("json").Enum("text", "json", "csv", "jsonl")

	collector_cmd_force = collector_cmd.Flag(
		"force", "Ignore schema errors and use it anyway").Bool()
)

const SampleSpec = `
# Can be Windows, Windows_x86, Linux, MacOS, MacOSArm, Generic
OS: Windows

# The list of artifacts and their args.
Artifacts:
 Windows.Triage.Targets:
   HighLevelTargets: '["_SANS_Triage", "_KapeTriage"]'
   Devices: '["C:","D:","E:"]'
 Windows.Sysinternals.Autoruns:
   All: "Y"

# Can be ZIP, GCS, S3, Azure, SMBShare, SFTP, WebDAV
Target: ZIP

# When the Target is GCS:
#TargetArgs:
#  bucket:
#  GCSKey:

# When the Target is S3
#TargetArgs:
#  bucket: "
#  credentialsKey: ""
#  credentialsSecret: ""
#  credentialsToken: ""
#  region: ""
#  endpoint: ""
#  serverSideEncryption: ""
#  kmsEncryptionKey: ""
#  s3UploadRoot": ""
#  noverifycert": false

# When the Target is Azure
#TargetArgs:
#  sas_url: ""

# When the Target is SMBShare
#TargetArgs:
#  username: ""
#  password: ""
#  server_address: ""

# When the Target is SFTP
#TargetArgs:
#  user: ""
#  path: ""
#  privatekey: ""
#  endpoint: ""
#  hostkey: ""

# When the Target is WebDAV
#TargetArgs:
#  url: ""
#  basic_auth_user: ""
#  basic_auth_password: ""
#  user_agent: ""

# Can be None, X509
# NOTE: You can unzip the encrypted zip using
# velociraptor --config server.config.yaml unzip --dump_dir output file.zip
EncryptionScheme: None
EncryptionArgs: {}

# Following can be Y or N
OptVerbose: Y
OptBanner: Y
OptPrompt: N
OptAdmin: Y

# A path to use for the temp file (Blank for system default)
OptTempdir: ""

# Compression level to use
OptLevel: 5
OptConcurrency: 2
OptFilenameTemplate: "Collection-%Hostname%-%TIMESTAMP%"

# What to call the collection binary. If empty we use an autogenerated name.
OptCollectorTemplate: ""

# Can be jsonl or csv
OptFormat: jsonl

# Where we actually write the collection to. You can specify this as a
# mapped drive to write over the network.
OptOutputDirectory: ""

# A number between 0 to 100 representing the target maximum CPU
# utilization during running of this artifact.
OptCpuLimit: 0

# If specified the collector is terminated if it made no progress in
# this long. Note: Execution time may be a lot longer since each time
# any result is produced this counter is reset.
OptProgressTimeout: 1800

# If specified the collection must complete in the given time.
OptTimeout: 0

# If specified the collection will be packed with the specified
# version of the binary. NOTE: This is rarely what you want because
# the packed builtin artifacts are only compatible with the current
# release version.
OptVersion: ""

# If specified the collection will be deleted at exit. This only
# makes sense when uploading to the cloud or a remote
# location. NOTE: There is no way to check that the upload
# actually worked so this flag deletes the collection regardless
# of upload success.
OptDeleteAtExit: N
`

func doCollector() error {
	if *spec_file == "" {
		fmt.Printf(`
# This command builds an offline collector from the CLI

# You must provide a spec file. For example
# %s collector /path/to/spec_file.yaml

# An example spec file follows. You can redirect to a file and edit as needed.

`, os.Args[0])
		fmt.Printf("%s", SampleSpec)
		return errors.New("No Spec file provided")
	}

	// Start from a clean slate
	os.Setenv("VELOCIRAPTOR_CONFIG", "")
	os.Setenv("VELOCIRAPTOR_LITERAL_CONFIG", "")

	datastore_directory := *collector_command_datastore
	if datastore_directory == "" {
		datastore_directory = filepath.Join(
			tempfile.GetTempDir(), "gui_datastore")

		// Ensure the directory exists
		err := os.MkdirAll(datastore_directory, 0o777)
		if err != nil {
			return fmt.Errorf("Unable to create datastore directory: %w", err)
		}
	}

	datastore_directory, err := filepath.Abs(datastore_directory)
	if err != nil {
		return fmt.Errorf("Unable find path: %w", err)
	}

	server_config_path := filepath.Join(datastore_directory, "server.config.yaml")
	client_config_path := filepath.Join(datastore_directory, "client.config.yaml")

	// Try to open the config file from there
	config_obj, err := makeDefaultConfigLoader().
		WithVerbose(*verbose_flag).
		WithFileLoader(server_config_path).LoadAndValidate()
	if err != nil || config_obj.Frontend == nil {
		// Stop on hard errors but if the file does not exist we need
		// to create it below..
		hard_err, ok := err.(config.HardError)
		if ok && !errors.Is(hard_err.Err, os.ErrNotExist) {
			return err
		}

		// Need to generate a new config. This config is the same as
		// the `gui` command makes. You can keep this datastore around
		// for the next collector.
		Prelog("No valid config found - "+
			"will generate a new one at <green>%s</>", server_config_path)

		config_obj, err = generateGUIConfig(
			datastore_directory, server_config_path, client_config_path)
		if err != nil {
			return err
		}
	}

	if config_obj.Services == nil {
		config_obj.Services = services.GenericToolServices()
	}

	// Now start the frontend
	ctx, cancel := install_sig_handler()
	defer cancel()

	sm, err := startup.StartToolServices(ctx, config_obj)
	if err != nil {
		return fmt.Errorf("starting tool services: %w", err)
	}
	defer sm.Close()

	spec_filename, err := filepath.Abs(*spec_file)
	if err != nil {
		return err
	}

	_, err = os.Lstat(spec_filename)
	if err != nil {
		return err
	}

	logger := &LogWriter{config_obj: config_obj}
	builder := services.ScopeBuilder{
		Config:     sm.Config,
		ACLManager: acl_managers.NewRoleACLManager(sm.Config, "administrator"),
		Logger:     log.New(logger, "", 0),
		Env: ordereddict.NewDict().
			Set("FORCE", *collector_cmd_force).
			Set("SPECFILE", spec_filename),
		Uploader: &uploads.FileBasedUploader{
			UploadDir: datastore_directory,
		},
	}

	// this is needed to ensure artifacts are fully loaded before we
	// start so their tools are fully registred.
	query := `
LET _ <= SELECT name FROM artifact_definitions()
LET _ <= import(artifact="Server.Utils.CreateCollector")

LET Spec <= parse_yaml(filename=SPECFILE, schema=SpecSchema) || (
    FORCE && parse_yaml(filename=SPECFILE) ) ||
    log(level="ERROR", message="<red>Abording</> due to invalid spec file!")

LET _K = SELECT _key FROM items(item=Spec.Artifacts)

SELECT * FROM if(condition=Spec.OS, then={
  SELECT * FROM Artifact.Server.Utils.CreateCollector(
   OS=Spec.OS,
   artifacts=serialize(item=_K._key),
   parameters=serialize(item=Spec.Artifacts),
   target=Spec.Target,
   target_args=Spec.TargetArgs,
   encryption_scheme=Spec.EncryptionScheme,
   encryption_args=Spec.EncryptionArgs,
   opt_verbose=Spec.OptVerbose,
   opt_banner=Spec.OptBanner,
   opt_prompt=Spec.OptPrompt,
   opt_admin=Spec.OptAdmin,
   opt_tempdir=Spec.OptTempdir,
   opt_level=Spec.OptLevel,
   opt_concurrency=Spec.OptConcurrency,
   opt_filename_template=Spec.OptFilenameTemplate,
   opt_collector_filename=Spec.OptCollectorTemplate,
   opt_format=Spec.OptFormat,
   opt_output_directory=Spec.OptOutputDirectory,
   opt_cpu_limit=Spec.OptCpuLimit,
   opt_progress_timeout=Spec.OptProgressTimeout,
   opt_timeout=Spec.OptTimeout,
   opt_version=Spec.OptVersion,
   opt_delete_at_exit=Spec.OptDeleteAtExit
   )
})
`
	err = runQueryWithEnv(query, builder, *collector_format)
	if err != nil {
		return err
	}

	return logger.Error
}

func init() {
	command_handlers = append(command_handlers, func(command string) bool {
		switch command {
		case collector_cmd.FullCommand():
			FatalIfError(collector_cmd, doCollector)

		case collector_decrypt.FullCommand():
			FatalIfError(collector_decrypt, doCollectorDecrypt)

		default:
			return false
		}
		return true
	})
}
