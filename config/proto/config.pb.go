// This file represents the configuration file schema.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: config.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
	proto "www.velocidex.com/golang/velociraptor/actions/proto"
	proto1 "www.velocidex.com/golang/velociraptor/artifacts/proto"
	_ "www.velocidex.com/golang/velociraptor/proto"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Information about Velociraptor. This is a pseudo config item - it
// will never be read from config files, but can be used in VQL
// queries. It will be written to config files as metadata about the
// version that produced the config file.
type Version struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	Name        string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description string                 `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Version     string                 `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	Commit      string                 `protobuf:"bytes,4,opt,name=commit,proto3" json:"commit,omitempty"`
	BuildTime   string                 `protobuf:"bytes,5,opt,name=build_time,json=buildTime,proto3" json:"build_time,omitempty"`
	// Populated by reading the writeback file.
	InstallTime   uint64 `protobuf:"varint,8,opt,name=install_time,json=installTime,proto3" json:"install_time,omitempty"`
	CiBuildUrl    string `protobuf:"bytes,6,opt,name=ci_build_url,json=ciBuildUrl,proto3" json:"ci_build_url,omitempty"`
	Compiler      string `protobuf:"bytes,7,opt,name=compiler,proto3" json:"compiler,omitempty"`
	System        string `protobuf:"bytes,9,opt,name=system,proto3" json:"system,omitempty"`
	Architecture  string `protobuf:"bytes,10,opt,name=architecture,proto3" json:"architecture,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Version) Reset() {
	*x = Version{}
	mi := &file_config_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Version) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Version) ProtoMessage() {}

func (x *Version) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Version.ProtoReflect.Descriptor instead.
func (*Version) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{0}
}

func (x *Version) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Version) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Version) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *Version) GetCommit() string {
	if x != nil {
		return x.Commit
	}
	return ""
}

func (x *Version) GetBuildTime() string {
	if x != nil {
		return x.BuildTime
	}
	return ""
}

func (x *Version) GetInstallTime() uint64 {
	if x != nil {
		return x.InstallTime
	}
	return 0
}

func (x *Version) GetCiBuildUrl() string {
	if x != nil {
		return x.CiBuildUrl
	}
	return ""
}

func (x *Version) GetCompiler() string {
	if x != nil {
		return x.Compiler
	}
	return ""
}

func (x *Version) GetSystem() string {
	if x != nil {
		return x.System
	}
	return ""
}

func (x *Version) GetArchitecture() string {
	if x != nil {
		return x.Architecture
	}
	return ""
}

// A pointer to cuurently executing flows.
type FlowCheckPoint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FlowId        string                 `protobuf:"bytes,1,opt,name=flow_id,json=flowId,proto3" json:"flow_id,omitempty"`
	Path          string                 `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowCheckPoint) Reset() {
	*x = FlowCheckPoint{}
	mi := &file_config_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowCheckPoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowCheckPoint) ProtoMessage() {}

func (x *FlowCheckPoint) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowCheckPoint.ProtoReflect.Descriptor instead.
func (*FlowCheckPoint) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{1}
}

func (x *FlowCheckPoint) GetFlowId() string {
	if x != nil {
		return x.FlowId
	}
	return ""
}

func (x *FlowCheckPoint) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

// The client's state which are persisted in the writeback file.
type Writeback struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// When the client was installed (basically the timestamp of the
	// writeback file).
	InstallTime uint64 `protobuf:"varint,16,opt,name=install_time,json=installTime,proto3" json:"install_time,omitempty"`
	PrivateKey  string `protobuf:"bytes,7,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// This is calculated from the public key above so it is only here
	// for information.
	ClientId               string `protobuf:"bytes,15,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	HuntLastTimestamp      uint64 `protobuf:"varint,13,opt,name=hunt_last_timestamp,json=huntLastTimestamp,proto3" json:"hunt_last_timestamp,omitempty"`
	LastServerSerialNumber uint64 `protobuf:"varint,14,opt,name=last_server_serial_number,json=lastServerSerialNumber,proto3" json:"last_server_serial_number,omitempty"`
	// Record the last seen server pem we saw. This is used in writing
	// encrypted logs before being able to connect to the server.
	LastServerPem string               `protobuf:"bytes,18,opt,name=last_server_pem,json=lastServerPem,proto3" json:"last_server_pem,omitempty"`
	EventQueries  *proto.VQLEventTable `protobuf:"bytes,1,opt,name=event_queries,json=eventQueries,proto3" json:"event_queries,omitempty"`
	Checkpoints   []*FlowCheckPoint    `protobuf:"bytes,17,rep,name=checkpoints,proto3" json:"checkpoints,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Writeback) Reset() {
	*x = Writeback{}
	mi := &file_config_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Writeback) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Writeback) ProtoMessage() {}

func (x *Writeback) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Writeback.ProtoReflect.Descriptor instead.
func (*Writeback) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{2}
}

func (x *Writeback) GetInstallTime() uint64 {
	if x != nil {
		return x.InstallTime
	}
	return 0
}

func (x *Writeback) GetPrivateKey() string {
	if x != nil {
		return x.PrivateKey
	}
	return ""
}

func (x *Writeback) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *Writeback) GetHuntLastTimestamp() uint64 {
	if x != nil {
		return x.HuntLastTimestamp
	}
	return 0
}

func (x *Writeback) GetLastServerSerialNumber() uint64 {
	if x != nil {
		return x.LastServerSerialNumber
	}
	return 0
}

func (x *Writeback) GetLastServerPem() string {
	if x != nil {
		return x.LastServerPem
	}
	return ""
}

func (x *Writeback) GetEventQueries() *proto.VQLEventTable {
	if x != nil {
		return x.EventQueries
	}
	return nil
}

func (x *Writeback) GetCheckpoints() []*FlowCheckPoint {
	if x != nil {
		return x.Checkpoints
	}
	return nil
}

// TODO - refactor from api/orgs.proto
type InitialOrgRecord struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	OrgId string                 `protobuf:"bytes,1,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
	Name  string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// If this is empty we use the org id
	Nonce         string `protobuf:"bytes,3,opt,name=nonce,proto3" json:"nonce,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InitialOrgRecord) Reset() {
	*x = InitialOrgRecord{}
	mi := &file_config_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitialOrgRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitialOrgRecord) ProtoMessage() {}

func (x *InitialOrgRecord) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitialOrgRecord.ProtoReflect.Descriptor instead.
func (*InitialOrgRecord) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{3}
}

func (x *InitialOrgRecord) GetOrgId() string {
	if x != nil {
		return x.OrgId
	}
	return ""
}

func (x *InitialOrgRecord) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *InitialOrgRecord) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

// Configuration for the windows installer. NOTE: This is not used
// much - it is only used when running `velociraptor service
// install`. We typically use an MSI to deploy (see the docs/wix/
// directory).
type WindowsInstallerConfig struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	ServiceName        string                 `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	InstallPath        string                 `protobuf:"bytes,2,opt,name=install_path,json=installPath,proto3" json:"install_path,omitempty"`
	ServiceDescription string                 `protobuf:"bytes,3,opt,name=service_description,json=serviceDescription,proto3" json:"service_description,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *WindowsInstallerConfig) Reset() {
	*x = WindowsInstallerConfig{}
	mi := &file_config_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WindowsInstallerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WindowsInstallerConfig) ProtoMessage() {}

func (x *WindowsInstallerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WindowsInstallerConfig.ProtoReflect.Descriptor instead.
func (*WindowsInstallerConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{4}
}

func (x *WindowsInstallerConfig) GetServiceName() string {
	if x != nil {
		return x.ServiceName
	}
	return ""
}

func (x *WindowsInstallerConfig) GetInstallPath() string {
	if x != nil {
		return x.InstallPath
	}
	return ""
}

func (x *WindowsInstallerConfig) GetServiceDescription() string {
	if x != nil {
		return x.ServiceDescription
	}
	return ""
}

type DarwinInstallerConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ServiceName   string                 `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	InstallPath   string                 `protobuf:"bytes,2,opt,name=install_path,json=installPath,proto3" json:"install_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DarwinInstallerConfig) Reset() {
	*x = DarwinInstallerConfig{}
	mi := &file_config_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DarwinInstallerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DarwinInstallerConfig) ProtoMessage() {}

func (x *DarwinInstallerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DarwinInstallerConfig.ProtoReflect.Descriptor instead.
func (*DarwinInstallerConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{5}
}

func (x *DarwinInstallerConfig) GetServiceName() string {
	if x != nil {
		return x.ServiceName
	}
	return ""
}

func (x *DarwinInstallerConfig) GetInstallPath() string {
	if x != nil {
		return x.InstallPath
	}
	return ""
}

type RingBufferConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Deprecated: Marked as deprecated in config.proto.
	Filename        string `protobuf:"bytes,3,opt,name=filename,proto3" json:"filename,omitempty"`
	MemorySize      uint64 `protobuf:"varint,1,opt,name=memory_size,json=memorySize,proto3" json:"memory_size,omitempty"`
	DiskSize        uint64 `protobuf:"varint,2,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	FilenameLinux   string `protobuf:"bytes,4,opt,name=filename_linux,json=filenameLinux,proto3" json:"filename_linux,omitempty"`
	FilenameWindows string `protobuf:"bytes,5,opt,name=filename_windows,json=filenameWindows,proto3" json:"filename_windows,omitempty"`
	FilenameDarwin  string `protobuf:"bytes,6,opt,name=filename_darwin,json=filenameDarwin,proto3" json:"filename_darwin,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *RingBufferConfig) Reset() {
	*x = RingBufferConfig{}
	mi := &file_config_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RingBufferConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RingBufferConfig) ProtoMessage() {}

func (x *RingBufferConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RingBufferConfig.ProtoReflect.Descriptor instead.
func (*RingBufferConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{6}
}

// Deprecated: Marked as deprecated in config.proto.
func (x *RingBufferConfig) GetFilename() string {
	if x != nil {
		return x.Filename
	}
	return ""
}

func (x *RingBufferConfig) GetMemorySize() uint64 {
	if x != nil {
		return x.MemorySize
	}
	return 0
}

func (x *RingBufferConfig) GetDiskSize() uint64 {
	if x != nil {
		return x.DiskSize
	}
	return 0
}

func (x *RingBufferConfig) GetFilenameLinux() string {
	if x != nil {
		return x.FilenameLinux
	}
	return ""
}

func (x *RingBufferConfig) GetFilenameWindows() string {
	if x != nil {
		return x.FilenameWindows
	}
	return ""
}

func (x *RingBufferConfig) GetFilenameDarwin() string {
	if x != nil {
		return x.FilenameDarwin
	}
	return ""
}

type ClientConfig struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	Labels     []string               `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty"`
	ServerUrls []string               `protobuf:"bytes,8,rep,name=server_urls,json=serverUrls,proto3" json:"server_urls,omitempty"`
	// A proxy setting to use.
	Proxy string `protobuf:"bytes,32,opt,name=proxy,proto3" json:"proxy,omitempty"`
	// For more complex proxy configurations use this setting
	// (overrides the `proxy` configuration above).
	ProxyConfig      *ProxyConfig `protobuf:"bytes,46,opt,name=proxy_config,json=proxyConfig,proto3" json:"proxy_config,omitempty"`
	CaCertificate    string       `protobuf:"bytes,11,opt,name=ca_certificate,json=caCertificate,proto3" json:"ca_certificate,omitempty"`
	Nonce            string       `protobuf:"bytes,12,opt,name=nonce,proto3" json:"nonce,omitempty"`
	WritebackDarwin  string       `protobuf:"bytes,20,opt,name=writeback_darwin,json=writebackDarwin,proto3" json:"writeback_darwin,omitempty"`
	WritebackLinux   string       `protobuf:"bytes,9,opt,name=writeback_linux,json=writebackLinux,proto3" json:"writeback_linux,omitempty"`
	WritebackWindows string       `protobuf:"bytes,10,opt,name=writeback_windows,json=writebackWindows,proto3" json:"writeback_windows,omitempty"`
	// If this is set we use a second file for the level2
	// writeback. The string expected here is added to the regular
	// writeback filename. For example setting to "l2" will create a
	// file named "velociraptor.writeback.yaml.l2"
	Level2WritebackSuffix string `protobuf:"bytes,44,opt,name=level2_writeback_suffix,json=level2WritebackSuffix,proto3" json:"level2_writeback_suffix,omitempty"`
	// A path to set the temp directory. If not set we use the system
	// default. The path may be relative to the current directory
	// (usually the location of the executable). If the path does not
	// exist we fall back to the system temp directory.
	TempdirLinux   string `protobuf:"bytes,1,opt,name=tempdir_linux,json=tempdirLinux,proto3" json:"tempdir_linux,omitempty"`
	TempdirWindows string `protobuf:"bytes,2,opt,name=tempdir_windows,json=tempdirWindows,proto3" json:"tempdir_windows,omitempty"`
	TempdirDarwin  string `protobuf:"bytes,3,opt,name=tempdir_darwin,json=tempdirDarwin,proto3" json:"tempdir_darwin,omitempty"`
	// Number of seconds to wait between polls (default 1
	// second). NOTE: Velociraptor typically holds the connection up
	// for at least max_poll time and then refreshes the
	// connection. The min poll is used to determine how quickly
	// connections should resume.
	MinPoll    uint64 `protobuf:"varint,14,opt,name=min_poll,json=minPoll,proto3" json:"min_poll,omitempty"`
	MaxPoll    uint64 `protobuf:"varint,15,opt,name=max_poll,json=maxPoll,proto3" json:"max_poll,omitempty"`
	MaxPollStd uint64 `protobuf:"varint,27,opt,name=max_poll_std,json=maxPollStd,proto3" json:"max_poll_std,omitempty"`
	// When using websockets the server pings the client periodically
	// to see if it is still there. This setting controls how often
	// this ping occurs (default 10).
	WsPingWaitSec uint64 `protobuf:"varint,45,opt,name=ws_ping_wait_sec,json=wsPingWaitSec,proto3" json:"ws_ping_wait_sec,omitempty"`
	// If this is set, the nanny will exit if we are not able to send
	// messages to the server within this many seconds. NOTE - even a
	// failed connection will reset the counter, the nanny will only
	// fire if the client has failed in some way - e.g. the
	// communicator is stopped for some reason
	NannyMaxConnectionDelay uint64                  `protobuf:"varint,36,opt,name=nanny_max_connection_delay,json=nannyMaxConnectionDelay,proto3" json:"nanny_max_connection_delay,omitempty"`
	WindowsInstaller        *WindowsInstallerConfig `protobuf:"bytes,16,opt,name=windows_installer,json=windowsInstaller,proto3" json:"windows_installer,omitempty"`
	DarwinInstaller         *DarwinInstallerConfig  `protobuf:"bytes,21,opt,name=darwin_installer,json=darwinInstaller,proto3" json:"darwin_installer,omitempty"`
	// If this is set, prevent arbitrary code execution on
	// clients. NOTE: Deprecated. You can now allow and reject any
	// plugin (not just execve) using the allowed_plugins,
	// allowed_functions and allowed_accessors parameters below.
	PreventExecve bool `protobuf:"varint,17,opt,name=prevent_execve,json=preventExecve,proto3" json:"prevent_execve,omitempty"`
	// Deprecated, new configs use server_version
	Version *Version `protobuf:"bytes,18,opt,name=version,proto3" json:"version,omitempty"`
	// The version of the server that originally generated this config
	// file.
	ServerVersion      *Version          `protobuf:"bytes,50,opt,name=server_version,json=serverVersion,proto3" json:"server_version,omitempty"`
	DefaultMaxWait     uint64            `protobuf:"varint,19,opt,name=default_max_wait,json=defaultMaxWait,proto3" json:"default_max_wait,omitempty"`
	UseSelfSignedSsl   bool              `protobuf:"varint,24,opt,name=use_self_signed_ssl,json=useSelfSignedSsl,proto3" json:"use_self_signed_ssl,omitempty"`
	PinnedServerName   string            `protobuf:"bytes,28,opt,name=pinned_server_name,json=pinnedServerName,proto3" json:"pinned_server_name,omitempty"`
	MaxUploadSize      uint64            `protobuf:"varint,25,opt,name=max_upload_size,json=maxUploadSize,proto3" json:"max_upload_size,omitempty"`
	LocalBuffer        *RingBufferConfig `protobuf:"bytes,26,opt,name=local_buffer,json=localBuffer,proto3" json:"local_buffer,omitempty"`
	MaxMemoryHardLimit uint64            `protobuf:"varint,29,opt,name=max_memory_hard_limit,json=maxMemoryHardLimit,proto3" json:"max_memory_hard_limit,omitempty"`
	// Maximum number of concurrent queries the client will allow (default 2).
	Concurrency uint64 `protobuf:"varint,31,opt,name=concurrency,proto3" json:"concurrency,omitempty"`
	// Maximum timeout for connection retry - the length of time we
	// try a connection before restarting it (default 5 min).
	ConnectionTimeout uint64        `protobuf:"varint,35,opt,name=connection_timeout,json=connectionTimeout,proto3" json:"connection_timeout,omitempty"`
	Crypto            *CryptoConfig `protobuf:"bytes,33,opt,name=Crypto,proto3" json:"Crypto,omitempty"`
	// Deprecated - do not set.
	DisableCompression bool `protobuf:"varint,37,opt,name=disable_compression,json=disableCompression,proto3" json:"disable_compression,omitempty"`
	// How often clients inform the server about flow progress
	// (default 5 seconds).
	DefaultServerFlowStatsUpdate uint64 `protobuf:"varint,39,opt,name=default_server_flow_stats_update,json=defaultServerFlowStatsUpdate,proto3" json:"default_server_flow_stats_update,omitempty"`
	// Clients will send a Server.Internal.ClientInfo message to the
	// server every this many seconds. This helps to keep the server
	// info up to date about each client. This should not be sent too
	// frequently. The default is 1 day (86400 seconds).
	ClientInfoUpdateTime int64 `protobuf:"varint,40,opt,name=client_info_update_time,json=clientInfoUpdateTime,proto3" json:"client_info_update_time,omitempty"`
	// Clients may not be able to reach a given host in the
	// internet. For that case, this mapping contains alternatives
	// which may be used instead. It's crucial that the addresses
	// include the port after a colon (see net.Dial).
	//
	// Example (yaml):
	//
	//	Client:
	//	  fallback_addresses:
	//	    "my-velociraptor-server.com:443": "123.123.123.123:443"
	//
	// This makes that if https://my-velociraptor-server.com is not
	// reachable (for example if DNS is not available due to a network
	// isolation because of an ongoing incident), 123.123.123.123:443
	// will be used as a fallback.
	FallbackAddresses map[string]string `protobuf:"bytes,41,rep,name=fallback_addresses,json=fallbackAddresses,proto3" json:"fallback_addresses,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// If greater than 0 we install a local DNS cache. This is usually
	// not needed as most operating systems already have local DNS
	// caching resolvers. This DNS cache will be refreshed
	// periodically from upstream. Note that the ttl of the record is
	// currently ignored and we refresh according to this setting.
	// This setting takes effect both on the client and on the server.
	DnsCacheRefreshMin uint64 `protobuf:"varint,54,opt,name=dns_cache_refresh_min,json=dnsCacheRefreshMin,proto3" json:"dns_cache_refresh_min,omitempty"`
	// If set we disable client checkpoints and so we can not report
	// to the server when the client crashes while collecting an
	// artifact.
	DisableCheckpoints bool `protobuf:"varint,42,opt,name=disable_checkpoints,json=disableCheckpoints,proto3" json:"disable_checkpoints,omitempty"`
	// Here you can specify a list of event artifacts to automatically
	// collect in addition to the list sent by the server. This is
	// most useful to initialize the client.
	AdditionalEventArtifacts []string `protobuf:"bytes,43,rep,name=additional_event_artifacts,json=additionalEventArtifacts,proto3" json:"additional_event_artifacts,omitempty"`
	// Path relative to the relevant tmpdir above where client side
	// logs are kept. These logs are encrypted client side and need to
	// be decrypted on the server to read.
	LogfileName string `protobuf:"bytes,47,opt,name=logfile_name,json=logfileName,proto3" json:"logfile_name,omitempty"`
	LogfileSize uint64 `protobuf:"varint,48,opt,name=logfile_size,json=logfileSize,proto3" json:"logfile_size,omitempty"`
	PanicFile   string `protobuf:"bytes,49,opt,name=panic_file,json=panicFile,proto3" json:"panic_file,omitempty"`
	// NOTE: Velociraptor has 2 layers of encryption - this setting
	// bypasses the outer TLS layer to expose the underlying HTTP
	// communications. Client->server communication still remain
	// encrypted however.
	InsecureNetworkTraceFile string `protobuf:"bytes,51,opt,name=insecure_network_trace_file,json=insecureNetworkTraceFile,proto3" json:"insecure_network_trace_file,omitempty"`
	// By default when running on a low resource machine we cap the
	// CPU use to 50%. This allows to change that - needs to be
	// between 0 and 100 (100 disables throttling).
	LowResourceMaxCpu uint64 `protobuf:"varint,52,opt,name=low_resource_max_cpu,json=lowResourceMaxCpu,proto3" json:"low_resource_max_cpu,omitempty"`
	// We determine we are running on a low resource machine if the
	// system has less than 2 cores. This allows to increase the
	// threadhold. Set to a large number to disable.
	LowResourceCpuCount uint64 `protobuf:"varint,53,opt,name=low_resource_cpu_count,json=lowResourceCpuCount,proto3" json:"low_resource_cpu_count,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *ClientConfig) Reset() {
	*x = ClientConfig{}
	mi := &file_config_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientConfig) ProtoMessage() {}

func (x *ClientConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientConfig.ProtoReflect.Descriptor instead.
func (*ClientConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{7}
}

func (x *ClientConfig) GetLabels() []string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *ClientConfig) GetServerUrls() []string {
	if x != nil {
		return x.ServerUrls
	}
	return nil
}

func (x *ClientConfig) GetProxy() string {
	if x != nil {
		return x.Proxy
	}
	return ""
}

func (x *ClientConfig) GetProxyConfig() *ProxyConfig {
	if x != nil {
		return x.ProxyConfig
	}
	return nil
}

func (x *ClientConfig) GetCaCertificate() string {
	if x != nil {
		return x.CaCertificate
	}
	return ""
}

func (x *ClientConfig) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

func (x *ClientConfig) GetWritebackDarwin() string {
	if x != nil {
		return x.WritebackDarwin
	}
	return ""
}

func (x *ClientConfig) GetWritebackLinux() string {
	if x != nil {
		return x.WritebackLinux
	}
	return ""
}

func (x *ClientConfig) GetWritebackWindows() string {
	if x != nil {
		return x.WritebackWindows
	}
	return ""
}

func (x *ClientConfig) GetLevel2WritebackSuffix() string {
	if x != nil {
		return x.Level2WritebackSuffix
	}
	return ""
}

func (x *ClientConfig) GetTempdirLinux() string {
	if x != nil {
		return x.TempdirLinux
	}
	return ""
}

func (x *ClientConfig) GetTempdirWindows() string {
	if x != nil {
		return x.TempdirWindows
	}
	return ""
}

func (x *ClientConfig) GetTempdirDarwin() string {
	if x != nil {
		return x.TempdirDarwin
	}
	return ""
}

func (x *ClientConfig) GetMinPoll() uint64 {
	if x != nil {
		return x.MinPoll
	}
	return 0
}

func (x *ClientConfig) GetMaxPoll() uint64 {
	if x != nil {
		return x.MaxPoll
	}
	return 0
}

func (x *ClientConfig) GetMaxPollStd() uint64 {
	if x != nil {
		return x.MaxPollStd
	}
	return 0
}

func (x *ClientConfig) GetWsPingWaitSec() uint64 {
	if x != nil {
		return x.WsPingWaitSec
	}
	return 0
}

func (x *ClientConfig) GetNannyMaxConnectionDelay() uint64 {
	if x != nil {
		return x.NannyMaxConnectionDelay
	}
	return 0
}

func (x *ClientConfig) GetWindowsInstaller() *WindowsInstallerConfig {
	if x != nil {
		return x.WindowsInstaller
	}
	return nil
}

func (x *ClientConfig) GetDarwinInstaller() *DarwinInstallerConfig {
	if x != nil {
		return x.DarwinInstaller
	}
	return nil
}

func (x *ClientConfig) GetPreventExecve() bool {
	if x != nil {
		return x.PreventExecve
	}
	return false
}

func (x *ClientConfig) GetVersion() *Version {
	if x != nil {
		return x.Version
	}
	return nil
}

func (x *ClientConfig) GetServerVersion() *Version {
	if x != nil {
		return x.ServerVersion
	}
	return nil
}

func (x *ClientConfig) GetDefaultMaxWait() uint64 {
	if x != nil {
		return x.DefaultMaxWait
	}
	return 0
}

func (x *ClientConfig) GetUseSelfSignedSsl() bool {
	if x != nil {
		return x.UseSelfSignedSsl
	}
	return false
}

func (x *ClientConfig) GetPinnedServerName() string {
	if x != nil {
		return x.PinnedServerName
	}
	return ""
}

func (x *ClientConfig) GetMaxUploadSize() uint64 {
	if x != nil {
		return x.MaxUploadSize
	}
	return 0
}

func (x *ClientConfig) GetLocalBuffer() *RingBufferConfig {
	if x != nil {
		return x.LocalBuffer
	}
	return nil
}

func (x *ClientConfig) GetMaxMemoryHardLimit() uint64 {
	if x != nil {
		return x.MaxMemoryHardLimit
	}
	return 0
}

func (x *ClientConfig) GetConcurrency() uint64 {
	if x != nil {
		return x.Concurrency
	}
	return 0
}

func (x *ClientConfig) GetConnectionTimeout() uint64 {
	if x != nil {
		return x.ConnectionTimeout
	}
	return 0
}

func (x *ClientConfig) GetCrypto() *CryptoConfig {
	if x != nil {
		return x.Crypto
	}
	return nil
}

func (x *ClientConfig) GetDisableCompression() bool {
	if x != nil {
		return x.DisableCompression
	}
	return false
}

func (x *ClientConfig) GetDefaultServerFlowStatsUpdate() uint64 {
	if x != nil {
		return x.DefaultServerFlowStatsUpdate
	}
	return 0
}

func (x *ClientConfig) GetClientInfoUpdateTime() int64 {
	if x != nil {
		return x.ClientInfoUpdateTime
	}
	return 0
}

func (x *ClientConfig) GetFallbackAddresses() map[string]string {
	if x != nil {
		return x.FallbackAddresses
	}
	return nil
}

func (x *ClientConfig) GetDnsCacheRefreshMin() uint64 {
	if x != nil {
		return x.DnsCacheRefreshMin
	}
	return 0
}

func (x *ClientConfig) GetDisableCheckpoints() bool {
	if x != nil {
		return x.DisableCheckpoints
	}
	return false
}

func (x *ClientConfig) GetAdditionalEventArtifacts() []string {
	if x != nil {
		return x.AdditionalEventArtifacts
	}
	return nil
}

func (x *ClientConfig) GetLogfileName() string {
	if x != nil {
		return x.LogfileName
	}
	return ""
}

func (x *ClientConfig) GetLogfileSize() uint64 {
	if x != nil {
		return x.LogfileSize
	}
	return 0
}

func (x *ClientConfig) GetPanicFile() string {
	if x != nil {
		return x.PanicFile
	}
	return ""
}

func (x *ClientConfig) GetInsecureNetworkTraceFile() string {
	if x != nil {
		return x.InsecureNetworkTraceFile
	}
	return ""
}

func (x *ClientConfig) GetLowResourceMaxCpu() uint64 {
	if x != nil {
		return x.LowResourceMaxCpu
	}
	return 0
}

func (x *ClientConfig) GetLowResourceCpuCount() uint64 {
	if x != nil {
		return x.LowResourceCpuCount
	}
	return 0
}

type APIConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Publicly accessible hostname.
	Hostname      string `protobuf:"bytes,5,opt,name=hostname,proto3" json:"hostname,omitempty"`
	BindAddress   string `protobuf:"bytes,1,opt,name=bind_address,json=bindAddress,proto3" json:"bind_address,omitempty"`
	BindPort      uint32 `protobuf:"varint,2,opt,name=bind_port,json=bindPort,proto3" json:"bind_port,omitempty"`
	BindScheme    string `protobuf:"bytes,3,opt,name=bind_scheme,json=bindScheme,proto3" json:"bind_scheme,omitempty"`
	PinnedGwName  string `protobuf:"bytes,4,opt,name=pinned_gw_name,json=pinnedGwName,proto3" json:"pinned_gw_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *APIConfig) Reset() {
	*x = APIConfig{}
	mi := &file_config_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *APIConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*APIConfig) ProtoMessage() {}

func (x *APIConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use APIConfig.ProtoReflect.Descriptor instead.
func (*APIConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{8}
}

func (x *APIConfig) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *APIConfig) GetBindAddress() string {
	if x != nil {
		return x.BindAddress
	}
	return ""
}

func (x *APIConfig) GetBindPort() uint32 {
	if x != nil {
		return x.BindPort
	}
	return 0
}

func (x *APIConfig) GetBindScheme() string {
	if x != nil {
		return x.BindScheme
	}
	return ""
}

func (x *APIConfig) GetPinnedGwName() string {
	if x != nil {
		return x.PinnedGwName
	}
	return ""
}

// Configuration to be consumed by api clients.
type ApiClientConfig struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	CaCertificate       string                 `protobuf:"bytes,1,opt,name=ca_certificate,json=caCertificate,proto3" json:"ca_certificate,omitempty"`
	ClientCert          string                 `protobuf:"bytes,2,opt,name=client_cert,json=clientCert,proto3" json:"client_cert,omitempty"`
	ClientPrivateKey    string                 `protobuf:"bytes,3,opt,name=client_private_key,json=clientPrivateKey,proto3" json:"client_private_key,omitempty"`
	ApiConnectionString string                 `protobuf:"bytes,4,opt,name=api_connection_string,json=apiConnectionString,proto3" json:"api_connection_string,omitempty"`
	Name                string                 `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	PinnedServerName    string                 `protobuf:"bytes,6,opt,name=pinned_server_name,json=pinnedServerName,proto3" json:"pinned_server_name,omitempty"`
	// This is 4mb by default but you can increase it if you like.
	MaxGrpcRecvSize uint64 `protobuf:"varint,7,opt,name=max_grpc_recv_size,json=maxGrpcRecvSize,proto3" json:"max_grpc_recv_size,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ApiClientConfig) Reset() {
	*x = ApiClientConfig{}
	mi := &file_config_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApiClientConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApiClientConfig) ProtoMessage() {}

func (x *ApiClientConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApiClientConfig.ProtoReflect.Descriptor instead.
func (*ApiClientConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{9}
}

func (x *ApiClientConfig) GetCaCertificate() string {
	if x != nil {
		return x.CaCertificate
	}
	return ""
}

func (x *ApiClientConfig) GetClientCert() string {
	if x != nil {
		return x.ClientCert
	}
	return ""
}

func (x *ApiClientConfig) GetClientPrivateKey() string {
	if x != nil {
		return x.ClientPrivateKey
	}
	return ""
}

func (x *ApiClientConfig) GetApiConnectionString() string {
	if x != nil {
		return x.ApiConnectionString
	}
	return ""
}

func (x *ApiClientConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ApiClientConfig) GetPinnedServerName() string {
	if x != nil {
		return x.PinnedServerName
	}
	return ""
}

func (x *ApiClientConfig) GetMaxGrpcRecvSize() uint64 {
	if x != nil {
		return x.MaxGrpcRecvSize
	}
	return 0
}

// Fine grained configuration of proxies for http connections.
type ProxyConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Https string                 `protobuf:"bytes,1,opt,name=https,proto3" json:"https,omitempty"`
	Http  string                 `protobuf:"bytes,2,opt,name=http,proto3" json:"http,omitempty"`
	// A list of url regexp to match the url and connect to the
	// target. Use and empty string to denote direct connection.  For
	// example: {"^https://localhost/": "",
	//
	//	"^https://www.example.com/": "http://localhost:3182"}
	ProxyUrlRegexp map[string]string `protobuf:"bytes,3,rep,name=proxy_url_regexp,json=proxyUrlRegexp,proto3" json:"proxy_url_regexp,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Location of a PAC file (overrides the above settings).
	Pac string `protobuf:"bytes,4,opt,name=pac,proto3" json:"pac,omitempty"`
	// If this is set we ignore the HTTP_PROXY and HTTPS_PROXY
	// environment variables.
	IgnoreEnvironment bool `protobuf:"varint,5,opt,name=ignore_environment,json=ignoreEnvironment,proto3" json:"ignore_environment,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ProxyConfig) Reset() {
	*x = ProxyConfig{}
	mi := &file_config_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxyConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxyConfig) ProtoMessage() {}

func (x *ProxyConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxyConfig.ProtoReflect.Descriptor instead.
func (*ProxyConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{10}
}

func (x *ProxyConfig) GetHttps() string {
	if x != nil {
		return x.Https
	}
	return ""
}

func (x *ProxyConfig) GetHttp() string {
	if x != nil {
		return x.Http
	}
	return ""
}

func (x *ProxyConfig) GetProxyUrlRegexp() map[string]string {
	if x != nil {
		return x.ProxyUrlRegexp
	}
	return nil
}

func (x *ProxyConfig) GetPac() string {
	if x != nil {
		return x.Pac
	}
	return ""
}

func (x *ProxyConfig) GetIgnoreEnvironment() bool {
	if x != nil {
		return x.IgnoreEnvironment
	}
	return false
}

type GUILink struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Text    string                 `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Url     string                 `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	IconUrl string                 `protobuf:"bytes,3,opt,name=icon_url,json=iconUrl,proto3" json:"icon_url,omitempty"`
	// This can be "sidebar" (default), "context"
	Type string `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	// If set we open in new tab
	NewTab bool `protobuf:"varint,5,opt,name=new_tab,json=newTab,proto3" json:"new_tab,omitempty"`
	// Encode value first using this (can be "plain", "base64")
	Encode    string `protobuf:"bytes,6,opt,name=encode,proto3" json:"encode,omitempty"`
	Parameter string `protobuf:"bytes,7,opt,name=parameter,proto3" json:"parameter,omitempty"`
	// Can be GET (default) or POST
	Method string `protobuf:"bytes,8,opt,name=method,proto3" json:"method,omitempty"`
	// If set we ignore this entry completely
	Disabled      bool `protobuf:"varint,9,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GUILink) Reset() {
	*x = GUILink{}
	mi := &file_config_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GUILink) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GUILink) ProtoMessage() {}

func (x *GUILink) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GUILink.ProtoReflect.Descriptor instead.
func (*GUILink) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{11}
}

func (x *GUILink) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

func (x *GUILink) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *GUILink) GetIconUrl() string {
	if x != nil {
		return x.IconUrl
	}
	return ""
}

func (x *GUILink) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *GUILink) GetNewTab() bool {
	if x != nil {
		return x.NewTab
	}
	return false
}

func (x *GUILink) GetEncode() string {
	if x != nil {
		return x.Encode
	}
	return ""
}

func (x *GUILink) GetParameter() string {
	if x != nil {
		return x.Parameter
	}
	return ""
}

func (x *GUILink) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

func (x *GUILink) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type OIDCACL struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Roles         []string               `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OIDCACL) Reset() {
	*x = OIDCACL{}
	mi := &file_config_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OIDCACL) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OIDCACL) ProtoMessage() {}

func (x *OIDCACL) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OIDCACL.ProtoReflect.Descriptor instead.
func (*OIDCACL) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{12}
}

func (x *OIDCACL) GetRoles() []string {
	if x != nil {
		return x.Roles
	}
	return nil
}

// Allow flexible claims in OIDC response - only set if you need to.
type OIDCClaims struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the claim that represents the username (by default
	// this is 'email'). Be careful that this MUST be unique across
	// the domain! It is vulnerability to allow something like 'name'
	// across a public domain because anyone can set this name in
	// their OIDC accounts!
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// The field that specifies the roles. If this not set, we do not
	// allow roles to be set via OIDC.
	Roles string `protobuf:"bytes,2,opt,name=roles,proto3" json:"roles,omitempty"`
	// A mapping between OIDC claim roles and Velociraptor roles.
	// For example:
	// role_map:
	//
	//	Velociraptor.Reader:
	//	  roles:
	//	    - reader
	RoleMap map[string]*OIDCACL `protobuf:"bytes,3,rep,name=role_map,json=roleMap,proto3" json:"role_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Velociraptor usually requires the email_verified claim before
	// we can trust the email claim and use it as the
	// username. However, some IDP (e.g. Azure) do not set this. If
	// you want to ignore this requirement, set the below to true.
	AllowUnverifiedEmail bool `protobuf:"varint,4,opt,name=allow_unverified_email,json=allowUnverifiedEmail,proto3" json:"allow_unverified_email,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *OIDCClaims) Reset() {
	*x = OIDCClaims{}
	mi := &file_config_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OIDCClaims) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OIDCClaims) ProtoMessage() {}

func (x *OIDCClaims) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OIDCClaims.ProtoReflect.Descriptor instead.
func (*OIDCClaims) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{13}
}

func (x *OIDCClaims) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *OIDCClaims) GetRoles() string {
	if x != nil {
		return x.Roles
	}
	return ""
}

func (x *OIDCClaims) GetRoleMap() map[string]*OIDCACL {
	if x != nil {
		return x.RoleMap
	}
	return nil
}

func (x *OIDCClaims) GetAllowUnverifiedEmail() bool {
	if x != nil {
		return x.AllowUnverifiedEmail
	}
	return false
}

type Authenticator struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Type  string                 `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// OIDC/OAuth2 Authenticator (Google, Github, Azure etc).
	OidcIssuer        string            `protobuf:"bytes,4,opt,name=oidc_issuer,json=oidcIssuer,proto3" json:"oidc_issuer,omitempty"`
	OidcName          string            `protobuf:"bytes,18,opt,name=oidc_name,json=oidcName,proto3" json:"oidc_name,omitempty"`
	OidcAuthUrlParams map[string]string `protobuf:"bytes,24,rep,name=oidc_auth_url_params,json=oidcAuthUrlParams,proto3" json:"oidc_auth_url_params,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Can be an img src for the avatar
	Avatar            string      `protobuf:"bytes,19,opt,name=avatar,proto3" json:"avatar,omitempty"`
	OauthClientId     string      `protobuf:"bytes,5,opt,name=oauth_client_id,json=oauthClientId,proto3" json:"oauth_client_id,omitempty"`
	OauthClientSecret string      `protobuf:"bytes,6,opt,name=oauth_client_secret,json=oauthClientSecret,proto3" json:"oauth_client_secret,omitempty"`
	Claims            *OIDCClaims `protobuf:"bytes,25,opt,name=claims,proto3" json:"claims,omitempty"`
	// When this is set we emit detailed logging.
	OidcDebug bool `protobuf:"varint,26,opt,name=oidc_debug,json=oidcDebug,proto3" json:"oidc_debug,omitempty"`
	// Azure requires a tenancy as well.
	Tenant string `protobuf:"bytes,7,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// SAML Authenticator
	SamlCertificate       string   `protobuf:"bytes,12,opt,name=saml_certificate,json=samlCertificate,proto3" json:"saml_certificate,omitempty"`
	SamlPrivateKey        string   `protobuf:"bytes,13,opt,name=saml_private_key,json=samlPrivateKey,proto3" json:"saml_private_key,omitempty"`
	SamlIdpMetadataUrl    string   `protobuf:"bytes,14,opt,name=saml_idp_metadata_url,json=samlIdpMetadataUrl,proto3" json:"saml_idp_metadata_url,omitempty"`
	SamlRootUrl           string   `protobuf:"bytes,15,opt,name=saml_root_url,json=samlRootUrl,proto3" json:"saml_root_url,omitempty"`
	SamlUserAttribute     string   `protobuf:"bytes,16,opt,name=saml_user_attribute,json=samlUserAttribute,proto3" json:"saml_user_attribute,omitempty"`
	SamlUserRoles         []string `protobuf:"bytes,23,rep,name=saml_user_roles,json=samlUserRoles,proto3" json:"saml_user_roles,omitempty"`
	SamlAllowIdpInitiated bool     `protobuf:"varint,27,opt,name=saml_allow_idp_initiated,json=samlAllowIdpInitiated,proto3" json:"saml_allow_idp_initiated,omitempty"`
	// MultiAuthenticator delegates to multiple other authenticators.
	SubAuthenticators    []*Authenticator `protobuf:"bytes,17,rep,name=sub_authenticators,json=subAuthenticators,proto3" json:"sub_authenticators,omitempty"`
	AuthRedirectTemplate string           `protobuf:"bytes,21,opt,name=auth_redirect_template,json=authRedirectTemplate,proto3" json:"auth_redirect_template,omitempty"`
	// Certs authenticator: If a user presents a certificate but does
	// not exist in the system, the user will receive a default
	// role. If this is not set the user will be rejected.
	DefaultRolesForUnknownUser []string `protobuf:"bytes,22,rep,name=default_roles_for_unknown_user,json=defaultRolesForUnknownUser,proto3" json:"default_roles_for_unknown_user,omitempty"`
	// How long to keep the session alive between auth flows - default
	// 24 hours
	DefaultSessionExpiryMin uint64 `protobuf:"varint,20,opt,name=default_session_expiry_min,json=defaultSessionExpiryMin,proto3" json:"default_session_expiry_min,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *Authenticator) Reset() {
	*x = Authenticator{}
	mi := &file_config_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Authenticator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Authenticator) ProtoMessage() {}

func (x *Authenticator) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Authenticator.ProtoReflect.Descriptor instead.
func (*Authenticator) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{14}
}

func (x *Authenticator) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *Authenticator) GetOidcIssuer() string {
	if x != nil {
		return x.OidcIssuer
	}
	return ""
}

func (x *Authenticator) GetOidcName() string {
	if x != nil {
		return x.OidcName
	}
	return ""
}

func (x *Authenticator) GetOidcAuthUrlParams() map[string]string {
	if x != nil {
		return x.OidcAuthUrlParams
	}
	return nil
}

func (x *Authenticator) GetAvatar() string {
	if x != nil {
		return x.Avatar
	}
	return ""
}

func (x *Authenticator) GetOauthClientId() string {
	if x != nil {
		return x.OauthClientId
	}
	return ""
}

func (x *Authenticator) GetOauthClientSecret() string {
	if x != nil {
		return x.OauthClientSecret
	}
	return ""
}

func (x *Authenticator) GetClaims() *OIDCClaims {
	if x != nil {
		return x.Claims
	}
	return nil
}

func (x *Authenticator) GetOidcDebug() bool {
	if x != nil {
		return x.OidcDebug
	}
	return false
}

func (x *Authenticator) GetTenant() string {
	if x != nil {
		return x.Tenant
	}
	return ""
}

func (x *Authenticator) GetSamlCertificate() string {
	if x != nil {
		return x.SamlCertificate
	}
	return ""
}

func (x *Authenticator) GetSamlPrivateKey() string {
	if x != nil {
		return x.SamlPrivateKey
	}
	return ""
}

func (x *Authenticator) GetSamlIdpMetadataUrl() string {
	if x != nil {
		return x.SamlIdpMetadataUrl
	}
	return ""
}

func (x *Authenticator) GetSamlRootUrl() string {
	if x != nil {
		return x.SamlRootUrl
	}
	return ""
}

func (x *Authenticator) GetSamlUserAttribute() string {
	if x != nil {
		return x.SamlUserAttribute
	}
	return ""
}

func (x *Authenticator) GetSamlUserRoles() []string {
	if x != nil {
		return x.SamlUserRoles
	}
	return nil
}

func (x *Authenticator) GetSamlAllowIdpInitiated() bool {
	if x != nil {
		return x.SamlAllowIdpInitiated
	}
	return false
}

func (x *Authenticator) GetSubAuthenticators() []*Authenticator {
	if x != nil {
		return x.SubAuthenticators
	}
	return nil
}

func (x *Authenticator) GetAuthRedirectTemplate() string {
	if x != nil {
		return x.AuthRedirectTemplate
	}
	return ""
}

func (x *Authenticator) GetDefaultRolesForUnknownUser() []string {
	if x != nil {
		return x.DefaultRolesForUnknownUser
	}
	return nil
}

func (x *Authenticator) GetDefaultSessionExpiryMin() uint64 {
	if x != nil {
		return x.DefaultSessionExpiryMin
	}
	return 0
}

type GUIConfig struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	BindAddress string                 `protobuf:"bytes,1,opt,name=bind_address,json=bindAddress,proto3" json:"bind_address,omitempty"`
	BindPort    uint32                 `protobuf:"varint,2,opt,name=bind_port,json=bindPort,proto3" json:"bind_port,omitempty"`
	// A list of CIDR addresses from permitted networks. If this is
	// not set, permit all connections to the GUI from anywhere.
	AllowedCidr []string `protobuf:"bytes,23,rep,name=allowed_cidr,json=allowedCidr,proto3" json:"allowed_cidr,omitempty"`
	// Header defined by the proxy containing the remote address. This
	// header will be used in the allowed_cidr matching if specified.
	// NOTE: Only use this if you do have a reverse proxy in front of
	// the server. Otherwise an attacker can simply send this header
	// to pretent to come from any IP address. If this setting is
	// specified we take the src address from the header, otherwise
	// from the remote IP address.
	ForwardedProxyHeader string `protobuf:"bytes,24,opt,name=forwarded_proxy_header,json=forwardedProxyHeader,proto3" json:"forwarded_proxy_header,omitempty"`
	// Allows the GUI to start with no encryption - **WARNING** This
	// only makes sense if you have TLS proxy in front. In fact the
	// GUI **will not work** without a TLS proxy because the csrf
	// cookie is set to secure only.
	UsePlainHttp bool `protobuf:"varint,20,opt,name=use_plain_http,json=usePlainHttp,proto3" json:"use_plain_http,omitempty"`
	// Serve the GUI from this base path instead of "/"
	BasePath      string                `protobuf:"bytes,21,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
	GwCertificate string                `protobuf:"bytes,10,opt,name=gw_certificate,json=gwCertificate,proto3" json:"gw_certificate,omitempty"`
	GwPrivateKey  string                `protobuf:"bytes,11,opt,name=gw_private_key,json=gwPrivateKey,proto3" json:"gw_private_key,omitempty"`
	PublicUrl     string                `protobuf:"bytes,7,opt,name=public_url,json=publicUrl,proto3" json:"public_url,omitempty"`
	ReverseProxy  []*ReverseProxyConfig `protobuf:"bytes,8,rep,name=reverse_proxy,json=reverseProxy,proto3" json:"reverse_proxy,omitempty"`
	Links         []*GUILink            `protobuf:"bytes,9,rep,name=links,proto3" json:"links,omitempty"`
	// These users are created with administrator role if they do not
	// already exist in the data store. This is useful for
	// initializing the server with some valid administrators.
	InitialUsers []*GUIUser          `protobuf:"bytes,17,rep,name=initial_users,json=initialUsers,proto3" json:"initial_users,omitempty"`
	InitialOrgs  []*InitialOrgRecord `protobuf:"bytes,22,rep,name=initial_orgs,json=initialOrgs,proto3" json:"initial_orgs,omitempty"`
	// The authenticator to use - can not be null.
	Authenticator *Authenticator `protobuf:"bytes,19,opt,name=authenticator,proto3" json:"authenticator,omitempty"`
	// The GUI will filter artifact search results by this regular
	// expression. This is useful to restrict the number of choices
	// available in the GUI to a small subset (e.g. only certain
	// packs).
	ArtifactSearchFilter string `protobuf:"bytes,18,opt,name=artifact_search_filter,json=artifactSearchFilter,proto3" json:"artifact_search_filter,omitempty"`
	// A list of domains that we will trust to send us the CSRF
	// token. Use this only when serving the JS from a different
	// domain than the API server.
	TrustedOrigins []string `protobuf:"bytes,25,rep,name=trusted_origins,json=trustedOrigins,proto3" json:"trusted_origins,omitempty"`
	// SAML info deprecated - will be moved to a saml authenticator.
	SamlCertificate    string `protobuf:"bytes,12,opt,name=saml_certificate,json=samlCertificate,proto3" json:"saml_certificate,omitempty"`
	SamlPrivateKey     string `protobuf:"bytes,13,opt,name=saml_private_key,json=samlPrivateKey,proto3" json:"saml_private_key,omitempty"`
	SamlIdpMetadataUrl string `protobuf:"bytes,14,opt,name=saml_idp_metadata_url,json=samlIdpMetadataUrl,proto3" json:"saml_idp_metadata_url,omitempty"`
	SamlRootUrl        string `protobuf:"bytes,15,opt,name=saml_root_url,json=samlRootUrl,proto3" json:"saml_root_url,omitempty"`
	SamlUserAttribute  string `protobuf:"bytes,16,opt,name=saml_user_attribute,json=samlUserAttribute,proto3" json:"saml_user_attribute,omitempty"`
	// DEPRECATED: Will be moved to a Google authenticator
	GoogleOauthClientId     string `protobuf:"bytes,5,opt,name=google_oauth_client_id,json=googleOauthClientId,proto3" json:"google_oauth_client_id,omitempty"`
	GoogleOauthClientSecret string `protobuf:"bytes,6,opt,name=google_oauth_client_secret,json=googleOauthClientSecret,proto3" json:"google_oauth_client_secret,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *GUIConfig) Reset() {
	*x = GUIConfig{}
	mi := &file_config_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GUIConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GUIConfig) ProtoMessage() {}

func (x *GUIConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GUIConfig.ProtoReflect.Descriptor instead.
func (*GUIConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{15}
}

func (x *GUIConfig) GetBindAddress() string {
	if x != nil {
		return x.BindAddress
	}
	return ""
}

func (x *GUIConfig) GetBindPort() uint32 {
	if x != nil {
		return x.BindPort
	}
	return 0
}

func (x *GUIConfig) GetAllowedCidr() []string {
	if x != nil {
		return x.AllowedCidr
	}
	return nil
}

func (x *GUIConfig) GetForwardedProxyHeader() string {
	if x != nil {
		return x.ForwardedProxyHeader
	}
	return ""
}

func (x *GUIConfig) GetUsePlainHttp() bool {
	if x != nil {
		return x.UsePlainHttp
	}
	return false
}

func (x *GUIConfig) GetBasePath() string {
	if x != nil {
		return x.BasePath
	}
	return ""
}

func (x *GUIConfig) GetGwCertificate() string {
	if x != nil {
		return x.GwCertificate
	}
	return ""
}

func (x *GUIConfig) GetGwPrivateKey() string {
	if x != nil {
		return x.GwPrivateKey
	}
	return ""
}

func (x *GUIConfig) GetPublicUrl() string {
	if x != nil {
		return x.PublicUrl
	}
	return ""
}

func (x *GUIConfig) GetReverseProxy() []*ReverseProxyConfig {
	if x != nil {
		return x.ReverseProxy
	}
	return nil
}

func (x *GUIConfig) GetLinks() []*GUILink {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *GUIConfig) GetInitialUsers() []*GUIUser {
	if x != nil {
		return x.InitialUsers
	}
	return nil
}

func (x *GUIConfig) GetInitialOrgs() []*InitialOrgRecord {
	if x != nil {
		return x.InitialOrgs
	}
	return nil
}

func (x *GUIConfig) GetAuthenticator() *Authenticator {
	if x != nil {
		return x.Authenticator
	}
	return nil
}

func (x *GUIConfig) GetArtifactSearchFilter() string {
	if x != nil {
		return x.ArtifactSearchFilter
	}
	return ""
}

func (x *GUIConfig) GetTrustedOrigins() []string {
	if x != nil {
		return x.TrustedOrigins
	}
	return nil
}

func (x *GUIConfig) GetSamlCertificate() string {
	if x != nil {
		return x.SamlCertificate
	}
	return ""
}

func (x *GUIConfig) GetSamlPrivateKey() string {
	if x != nil {
		return x.SamlPrivateKey
	}
	return ""
}

func (x *GUIConfig) GetSamlIdpMetadataUrl() string {
	if x != nil {
		return x.SamlIdpMetadataUrl
	}
	return ""
}

func (x *GUIConfig) GetSamlRootUrl() string {
	if x != nil {
		return x.SamlRootUrl
	}
	return ""
}

func (x *GUIConfig) GetSamlUserAttribute() string {
	if x != nil {
		return x.SamlUserAttribute
	}
	return ""
}

func (x *GUIConfig) GetGoogleOauthClientId() string {
	if x != nil {
		return x.GoogleOauthClientId
	}
	return ""
}

func (x *GUIConfig) GetGoogleOauthClientSecret() string {
	if x != nil {
		return x.GoogleOauthClientSecret
	}
	return ""
}

type GUIUser struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	PasswordHash  string                 `protobuf:"bytes,2,opt,name=password_hash,json=passwordHash,proto3" json:"password_hash,omitempty"`
	PasswordSalt  string                 `protobuf:"bytes,3,opt,name=password_salt,json=passwordSalt,proto3" json:"password_salt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GUIUser) Reset() {
	*x = GUIUser{}
	mi := &file_config_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GUIUser) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GUIUser) ProtoMessage() {}

func (x *GUIUser) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GUIUser.ProtoReflect.Descriptor instead.
func (*GUIUser) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{16}
}

func (x *GUIUser) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GUIUser) GetPasswordHash() string {
	if x != nil {
		return x.PasswordHash
	}
	return ""
}

func (x *GUIUser) GetPasswordSalt() string {
	if x != nil {
		return x.PasswordSalt
	}
	return ""
}

type CAConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PrivateKey    string                 `protobuf:"bytes,1,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CAConfig) Reset() {
	*x = CAConfig{}
	mi := &file_config_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CAConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CAConfig) ProtoMessage() {}

func (x *CAConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CAConfig.ProtoReflect.Descriptor instead.
func (*CAConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{17}
}

func (x *CAConfig) GetPrivateKey() string {
	if x != nil {
		return x.PrivateKey
	}
	return ""
}

type ReverseProxyConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Route         string                 `protobuf:"bytes,1,opt,name=route,proto3" json:"route,omitempty"`
	Url           string                 `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	RequireAuth   bool                   `protobuf:"varint,3,opt,name=require_auth,json=requireAuth,proto3" json:"require_auth,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReverseProxyConfig) Reset() {
	*x = ReverseProxyConfig{}
	mi := &file_config_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReverseProxyConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReverseProxyConfig) ProtoMessage() {}

func (x *ReverseProxyConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReverseProxyConfig.ProtoReflect.Descriptor instead.
func (*ReverseProxyConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{18}
}

func (x *ReverseProxyConfig) GetRoute() string {
	if x != nil {
		return x.Route
	}
	return ""
}

func (x *ReverseProxyConfig) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *ReverseProxyConfig) GetRequireAuth() bool {
	if x != nil {
		return x.RequireAuth
	}
	return false
}

type DynDNSConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Deprecated: Marked as deprecated in config.proto.
	Hostname string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Type of DynDNS server. Currently supported:
	// * empty string or dyndns
	// * cloudflare
	Type         string `protobuf:"bytes,8,opt,name=type,proto3" json:"type,omitempty"`
	DdnsUsername string `protobuf:"bytes,2,opt,name=ddns_username,json=ddnsUsername,proto3" json:"ddns_username,omitempty"`
	DdnsPassword string `protobuf:"bytes,3,opt,name=ddns_password,json=ddnsPassword,proto3" json:"ddns_password,omitempty"`
	// Some providers require a different hostname be updated that the
	// actual hostname (e.g. no-ip.com uses all.ddnskey.com to hide
	// the domain)
	DdnsHostname string `protobuf:"bytes,11,opt,name=ddns_hostname,json=ddnsHostname,proto3" json:"ddns_hostname,omitempty"`
	// This can be a full golang template for example
	// http://ip1.dynupdate.no-ip.com/nic/update?hostname={{.Hostname}}&myip={{.IP}}
	// or just the base URL
	UpdateUrl string `protobuf:"bytes,4,opt,name=update_url,json=updateUrl,proto3" json:"update_url,omitempty"`
	Frequency uint64 `protobuf:"varint,5,opt,name=frequency,proto3" json:"frequency,omitempty"`
	// The url we will use to check the ip. Should return a plain IP address
	CheckipUrl string `protobuf:"bytes,6,opt,name=checkip_url,json=checkipUrl,proto3" json:"checkip_url,omitempty"`
	// DNS server we query for our own hostname/ip mapping (default 8.8.8.8:53)
	DnsServer string `protobuf:"bytes,7,opt,name=dns_server,json=dnsServer,proto3" json:"dns_server,omitempty"`
	// cloudflare settings - required
	ApiToken      string `protobuf:"bytes,9,opt,name=api_token,json=apiToken,proto3" json:"api_token,omitempty"`
	ZoneName      string `protobuf:"bytes,10,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DynDNSConfig) Reset() {
	*x = DynDNSConfig{}
	mi := &file_config_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DynDNSConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DynDNSConfig) ProtoMessage() {}

func (x *DynDNSConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DynDNSConfig.ProtoReflect.Descriptor instead.
func (*DynDNSConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{19}
}

// Deprecated: Marked as deprecated in config.proto.
func (x *DynDNSConfig) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *DynDNSConfig) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *DynDNSConfig) GetDdnsUsername() string {
	if x != nil {
		return x.DdnsUsername
	}
	return ""
}

func (x *DynDNSConfig) GetDdnsPassword() string {
	if x != nil {
		return x.DdnsPassword
	}
	return ""
}

func (x *DynDNSConfig) GetDdnsHostname() string {
	if x != nil {
		return x.DdnsHostname
	}
	return ""
}

func (x *DynDNSConfig) GetUpdateUrl() string {
	if x != nil {
		return x.UpdateUrl
	}
	return ""
}

func (x *DynDNSConfig) GetFrequency() uint64 {
	if x != nil {
		return x.Frequency
	}
	return 0
}

func (x *DynDNSConfig) GetCheckipUrl() string {
	if x != nil {
		return x.CheckipUrl
	}
	return ""
}

func (x *DynDNSConfig) GetDnsServer() string {
	if x != nil {
		return x.DnsServer
	}
	return ""
}

func (x *DynDNSConfig) GetApiToken() string {
	if x != nil {
		return x.ApiToken
	}
	return ""
}

func (x *DynDNSConfig) GetZoneName() string {
	if x != nil {
		return x.ZoneName
	}
	return ""
}

type FrontendResourceControl struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Connections are limited to this rate - faster client
	// connections will result in 500 errors which will in turn cause
	// the clients to back off. This mechanism allows the server to
	// loadshed client connections. We allow up to 10 seconds
	// sustained QPS above this limit before we start load shedding.
	ConnectionsPerSecond uint64 `protobuf:"varint,1,opt,name=connections_per_second,json=connectionsPerSecond,proto3" json:"connections_per_second,omitempty"`
	// How fast to notify clients of a new hunt creation (This
	// effectively limits client recruitment rate). Default 10
	// notifications per sec.
	NotificationsPerSecond uint64 `protobuf:"varint,2,opt,name=notifications_per_second,json=notificationsPerSecond,proto3" json:"notifications_per_second,omitempty"`
	// How quickly do we enroll clients (default 100/s, -1 to disable enrollments)
	EnrollmentsPerSecond int64 `protobuf:"varint,3,opt,name=enrollments_per_second,json=enrollmentsPerSecond,proto3" json:"enrollments_per_second,omitempty"`
	// The maximum number of concurrent client connections we can
	// process. Concurrency limits helps to ensure the server is not
	// overloaded serving too many clients at the same time.
	// Concurrency refers to the actual serving time of a client
	// (i.e. time taken to read the response and write to the
	// datastore), not the total number of clients served by
	// server. Default is number of cores * 2.
	Concurrency uint64 `protobuf:"varint,9,opt,name=concurrency,proto3" json:"concurrency,omitempty"`
	// Aim for this heap size (default 2Gb). If actual memory usage
	// approaches this maximum, the frontend will begin to limit
	// client connections.
	// DEPRECATED
	TargetHeapSize uint64 `protobuf:"varint,10,opt,name=target_heap_size,json=targetHeapSize,proto3" json:"target_heap_size,omitempty"`
	// The maximum time a client will be waiting for a concurrency
	// slot before timing out. A small value will result in many
	// reconnections under load.
	ConcurrencyTimeout uint64 `protobuf:"varint,24,opt,name=concurrency_timeout,json=concurrencyTimeout,proto3" json:"concurrency_timeout,omitempty"`
	// Increasing this allows the frontend to receive larger POST
	// messages lowering crypto overheads but this comes at the
	// expense of more memory use.
	MaxUploadSize uint64 `protobuf:"varint,11,opt,name=max_upload_size,json=maxUploadSize,proto3" json:"max_upload_size,omitempty"`
	// This setting controls the size of various LRU caches in the
	// frontend (e.g. the session key cache, client info cache). This
	// number should be larger than the number of actual clients or
	// else the system will see high CPU load from cache misses.
	ExpectedClients int64 `protobuf:"varint,15,opt,name=expected_clients,json=expectedClients,proto3" json:"expected_clients,omitempty"`
	// Bandwidth control: Per client and global rates in bytes/sec
	PerClientUploadRate int64 `protobuf:"varint,21,opt,name=per_client_upload_rate,json=perClientUploadRate,proto3" json:"per_client_upload_rate,omitempty"`
	GlobalUploadRate    int64 `protobuf:"varint,22,opt,name=global_upload_rate,json=globalUploadRate,proto3" json:"global_upload_rate,omitempty"`
	// Wait time for collecting events from clients - smaller means
	// less latency to respond to client events but also means more
	// TLS handshake and network overheads due to frequent POST.
	ClientEventMaxWait uint64 `protobuf:"varint,23,opt,name=client_event_max_wait,json=clientEventMaxWait,proto3" json:"client_event_max_wait,omitempty"`
	// Minions batch updates to the master so as to minimize RPC as
	// much as possible, this controls how often these batches are
	// flushed to the master (default 10 sec).
	MinionBatchWaitTimeMs uint64 `protobuf:"varint,25,opt,name=minion_batch_wait_time_ms,json=minionBatchWaitTimeMs,proto3" json:"minion_batch_wait_time_ms,omitempty"`
	// How often to save an index snapshot to storage (default 600
	// sec). Index files are typically 150kb / 1000 clients.
	IndexSnapshotFrequency uint64 `protobuf:"varint,26,opt,name=index_snapshot_frequency,json=indexSnapshotFrequency,proto3" json:"index_snapshot_frequency,omitempty"`
	// Number of seconds before expiring client info cache
	// entries. Default (0) means do not expire at all. Expiring
	// client info from cache too frequently can result in a lot more
	// IO. Default size of this cache is the expected_clients above.
	ClientInfoLruTtl uint64 `protobuf:"varint,27,opt,name=client_info_lru_ttl,json=clientInfoLruTtl,proto3" json:"client_info_lru_ttl,omitempty"`
	// How often to sync client info records (ms)
	ClientInfoSyncTime  uint64 `protobuf:"varint,29,opt,name=client_info_sync_time,json=clientInfoSyncTime,proto3" json:"client_info_sync_time,omitempty"`
	ClientInfoWriteTime uint64 `protobuf:"varint,30,opt,name=client_info_write_time,json=clientInfoWriteTime,proto3" json:"client_info_write_time,omitempty"`
	// The journal files are used to queue messages between event
	// generators and event consumers when the consumer is unable to
	// drain these quickly enough. The setting specifies the maximum
	// size of the file - when it is exceeded, the file will be
	// truncated and events will be lost. Default is 1gb
	MaxJournalBufferSize int64 `protobuf:"varint,28,opt,name=max_journal_buffer_size,json=maxJournalBufferSize,proto3" json:"max_journal_buffer_size,omitempty"`
	// The maximum time in seconds the client will batch log messages
	// before forwarding them to the server (default 1 second).
	DefaultLogBatchTime uint64 `protobuf:"varint,31,opt,name=default_log_batch_time,json=defaultLogBatchTime,proto3" json:"default_log_batch_time,omitempty"`
	// The maximum time in seconds the client will batch minitoring
	// log messages before forwarding them to the server (default 600
	// second).
	DefaultMonitoringLogBatchTime uint64 `protobuf:"varint,32,opt,name=default_monitoring_log_batch_time,json=defaultMonitoringLogBatchTime,proto3" json:"default_monitoring_log_batch_time,omitempty"`
	// Disables file buffering for event queues. This may result in
	// poor performance under load.
	DisableFileBuffering bool `protobuf:"varint,33,opt,name=disable_file_buffering,json=disableFileBuffering,proto3" json:"disable_file_buffering,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *FrontendResourceControl) Reset() {
	*x = FrontendResourceControl{}
	mi := &file_config_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FrontendResourceControl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FrontendResourceControl) ProtoMessage() {}

func (x *FrontendResourceControl) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FrontendResourceControl.ProtoReflect.Descriptor instead.
func (*FrontendResourceControl) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{20}
}

func (x *FrontendResourceControl) GetConnectionsPerSecond() uint64 {
	if x != nil {
		return x.ConnectionsPerSecond
	}
	return 0
}

func (x *FrontendResourceControl) GetNotificationsPerSecond() uint64 {
	if x != nil {
		return x.NotificationsPerSecond
	}
	return 0
}

func (x *FrontendResourceControl) GetEnrollmentsPerSecond() int64 {
	if x != nil {
		return x.EnrollmentsPerSecond
	}
	return 0
}

func (x *FrontendResourceControl) GetConcurrency() uint64 {
	if x != nil {
		return x.Concurrency
	}
	return 0
}

func (x *FrontendResourceControl) GetTargetHeapSize() uint64 {
	if x != nil {
		return x.TargetHeapSize
	}
	return 0
}

func (x *FrontendResourceControl) GetConcurrencyTimeout() uint64 {
	if x != nil {
		return x.ConcurrencyTimeout
	}
	return 0
}

func (x *FrontendResourceControl) GetMaxUploadSize() uint64 {
	if x != nil {
		return x.MaxUploadSize
	}
	return 0
}

func (x *FrontendResourceControl) GetExpectedClients() int64 {
	if x != nil {
		return x.ExpectedClients
	}
	return 0
}

func (x *FrontendResourceControl) GetPerClientUploadRate() int64 {
	if x != nil {
		return x.PerClientUploadRate
	}
	return 0
}

func (x *FrontendResourceControl) GetGlobalUploadRate() int64 {
	if x != nil {
		return x.GlobalUploadRate
	}
	return 0
}

func (x *FrontendResourceControl) GetClientEventMaxWait() uint64 {
	if x != nil {
		return x.ClientEventMaxWait
	}
	return 0
}

func (x *FrontendResourceControl) GetMinionBatchWaitTimeMs() uint64 {
	if x != nil {
		return x.MinionBatchWaitTimeMs
	}
	return 0
}

func (x *FrontendResourceControl) GetIndexSnapshotFrequency() uint64 {
	if x != nil {
		return x.IndexSnapshotFrequency
	}
	return 0
}

func (x *FrontendResourceControl) GetClientInfoLruTtl() uint64 {
	if x != nil {
		return x.ClientInfoLruTtl
	}
	return 0
}

func (x *FrontendResourceControl) GetClientInfoSyncTime() uint64 {
	if x != nil {
		return x.ClientInfoSyncTime
	}
	return 0
}

func (x *FrontendResourceControl) GetClientInfoWriteTime() uint64 {
	if x != nil {
		return x.ClientInfoWriteTime
	}
	return 0
}

func (x *FrontendResourceControl) GetMaxJournalBufferSize() int64 {
	if x != nil {
		return x.MaxJournalBufferSize
	}
	return 0
}

func (x *FrontendResourceControl) GetDefaultLogBatchTime() uint64 {
	if x != nil {
		return x.DefaultLogBatchTime
	}
	return 0
}

func (x *FrontendResourceControl) GetDefaultMonitoringLogBatchTime() uint64 {
	if x != nil {
		return x.DefaultMonitoringLogBatchTime
	}
	return 0
}

func (x *FrontendResourceControl) GetDisableFileBuffering() bool {
	if x != nil {
		return x.DisableFileBuffering
	}
	return false
}

type FrontendConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Deprecated: Marked as deprecated in config.proto.
	PublicPath string `protobuf:"bytes,8,opt,name=public_path,json=publicPath,proto3" json:"public_path,omitempty"`
	// Publicly accessible hostname for this frontend.
	Hostname string `protobuf:"bytes,19,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Address to bind frontend endpoint. Clients connect to this
	// endpoint to poll for jobs.
	BindAddress string `protobuf:"bytes,1,opt,name=bind_address,json=bindAddress,proto3" json:"bind_address,omitempty"`
	// Port to bind to
	BindPort uint32 `protobuf:"varint,2,opt,name=bind_port,json=bindPort,proto3" json:"bind_port,omitempty"`
	// Serve the GUI from this base path instead of "/"
	BasePath string `protobuf:"bytes,25,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
	// This allows the frontends to listen on plain HTTP - It is
	// useful if you have SSL offloading (e.g. ngix). This is not
	// configured by the wizard - you will need to manually configure
	// it. You better know what you are doing here!
	UsePlainHttp bool `protobuf:"varint,24,opt,name=use_plain_http,json=usePlainHttp,proto3" json:"use_plain_http,omitempty"`
	// Enabling this requires the clients to present a valid
	// certificate (signed by one of the Root CAs listed in
	// Client.Crypto.root_certs or the Velociraptor built in CA
	// itself).
	RequireClientCertificates bool `protobuf:"varint,36,opt,name=require_client_certificates,json=requireClientCertificates,proto3" json:"require_client_certificates,omitempty"`
	// A proxy setting to use - Velociraptor needs to connect to
	// download tools. This setting will force it to go out over this
	// proxy. NOTE- If you dont want your server to allow outbound
	// connections, just set this to an non existant setting.
	Proxy string `protobuf:"bytes,33,opt,name=proxy,proto3" json:"proxy,omitempty"`
	// For more complex proxy configurations use this setting
	// (overrides the `proxy` configuration above).
	ProxyConfig *ProxyConfig `protobuf:"bytes,37,opt,name=proxy_config,json=proxyConfig,proto3" json:"proxy_config,omitempty"`
	// These are used to secure the client/server communications -
	// Even when using external TLS certificates! This certificate
	// must be signed by the Velociraptor rooot CA in all cases. If
	// using an external TLS configuration this layer of encryption
	// happens **in addition** to the external TLS certificates.
	Certificate string `protobuf:"bytes,3,opt,name=certificate,proto3" json:"certificate,omitempty"`
	PrivateKey  string `protobuf:"bytes,4,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// Be sure to set Client.use_self_signed_ssl=false when you set this.
	TlsCertificateFilename           string        `protobuf:"bytes,28,opt,name=tls_certificate_filename,json=tlsCertificateFilename,proto3" json:"tls_certificate_filename,omitempty"`
	TlsPrivateKeyFilename            string        `protobuf:"bytes,29,opt,name=tls_private_key_filename,json=tlsPrivateKeyFilename,proto3" json:"tls_private_key_filename,omitempty"`
	DnsName                          string        `protobuf:"bytes,6,opt,name=dns_name,json=dnsName,proto3" json:"dns_name,omitempty"`
	DoNotCompressArtifacts           bool          `protobuf:"varint,10,opt,name=do_not_compress_artifacts,json=doNotCompressArtifacts,proto3" json:"do_not_compress_artifacts,omitempty"`
	DynDns                           *DynDNSConfig `protobuf:"bytes,12,opt,name=dyn_dns,json=dynDns,proto3" json:"dyn_dns,omitempty"`
	ProxyHeader                      string        `protobuf:"bytes,13,opt,name=proxy_header,json=proxyHeader,proto3" json:"proxy_header,omitempty"`
	DefaultClientMonitoringArtifacts []string      `protobuf:"bytes,14,rep,name=default_client_monitoring_artifacts,json=defaultClientMonitoringArtifacts,proto3" json:"default_client_monitoring_artifacts,omitempty"`
	// We have the Server.Monitor.Health enabled always but these are
	// any additional artifacts that should be installed by default.
	DefaultServerMonitoringArtifacts []string `protobuf:"bytes,31,rep,name=default_server_monitoring_artifacts,json=defaultServerMonitoringArtifacts,proto3" json:"default_server_monitoring_artifacts,omitempty"`
	// If set this will cause the frontend to collect these artifacts
	// the first time it is run after install.
	InitialServerArtifacts []string                 `protobuf:"bytes,34,rep,name=initial_server_artifacts,json=initialServerArtifacts,proto3" json:"initial_server_artifacts,omitempty"`
	RunAsUser              string                   `protobuf:"bytes,16,opt,name=run_as_user,json=runAsUser,proto3" json:"run_as_user,omitempty"`
	GRPCPoolMaxSize        int64                    `protobuf:"varint,17,opt,name=GRPC_pool_max_size,json=GRPCPoolMaxSize,proto3" json:"GRPC_pool_max_size,omitempty"`
	GRPCPoolMaxWait        int64                    `protobuf:"varint,18,opt,name=GRPC_pool_max_wait,json=GRPCPoolMaxWait,proto3" json:"GRPC_pool_max_wait,omitempty"`
	Resources              *FrontendResourceControl `protobuf:"bytes,27,opt,name=resources,proto3" json:"resources,omitempty"`
	// Used internally to tag this frontend as the master.
	IsMinion bool `protobuf:"varint,30,opt,name=is_minion,json=isMinion,proto3" json:"is_minion,omitempty"`
	// Below options are DEPRECATED - moved to resources by migration code.
	Concurrency   uint64 `protobuf:"varint,9,opt,name=concurrency,proto3" json:"concurrency,omitempty"`
	MaxUploadSize uint64 `protobuf:"varint,11,opt,name=max_upload_size,json=maxUploadSize,proto3" json:"max_upload_size,omitempty"`
	// Various performoance related tweaks.
	ExpectedClients int64 `protobuf:"varint,15,opt,name=expected_clients,json=expectedClients,proto3" json:"expected_clients,omitempty"`
	// Per client rate in bytes/sec
	PerClientUploadRate int64 `protobuf:"varint,21,opt,name=per_client_upload_rate,json=perClientUploadRate,proto3" json:"per_client_upload_rate,omitempty"`
	GlobalUploadRate    int64 `protobuf:"varint,22,opt,name=global_upload_rate,json=globalUploadRate,proto3" json:"global_upload_rate,omitempty"`
	// Wait time for collecting events from clients - smaller means
	// less latency to respond to client events but also means more
	// TLS handshake and network overheads due to frequent POST.
	ClientEventMaxWait uint64 `protobuf:"varint,23,opt,name=client_event_max_wait,json=clientEventMaxWait,proto3" json:"client_event_max_wait,omitempty"`
	// Load artifacts from this directory at startup
	ArtifactDefinitionsDirectory string `protobuf:"bytes,32,opt,name=artifact_definitions_directory,json=artifactDefinitionsDirectory,proto3" json:"artifact_definitions_directory,omitempty"`
	// A regular expression that if matches any log messages from the
	// client's query represent a failure of the collection.
	CollectionErrorRegex string `protobuf:"bytes,35,opt,name=collection_error_regex,json=collectionErrorRegex,proto3" json:"collection_error_regex,omitempty"`
	// DEPRECATED - ignored.
	DoNotRedirect bool `protobuf:"varint,26,opt,name=do_not_redirect,json=doNotRedirect,proto3" json:"do_not_redirect,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FrontendConfig) Reset() {
	*x = FrontendConfig{}
	mi := &file_config_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FrontendConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FrontendConfig) ProtoMessage() {}

func (x *FrontendConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FrontendConfig.ProtoReflect.Descriptor instead.
func (*FrontendConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{21}
}

// Deprecated: Marked as deprecated in config.proto.
func (x *FrontendConfig) GetPublicPath() string {
	if x != nil {
		return x.PublicPath
	}
	return ""
}

func (x *FrontendConfig) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *FrontendConfig) GetBindAddress() string {
	if x != nil {
		return x.BindAddress
	}
	return ""
}

func (x *FrontendConfig) GetBindPort() uint32 {
	if x != nil {
		return x.BindPort
	}
	return 0
}

func (x *FrontendConfig) GetBasePath() string {
	if x != nil {
		return x.BasePath
	}
	return ""
}

func (x *FrontendConfig) GetUsePlainHttp() bool {
	if x != nil {
		return x.UsePlainHttp
	}
	return false
}

func (x *FrontendConfig) GetRequireClientCertificates() bool {
	if x != nil {
		return x.RequireClientCertificates
	}
	return false
}

func (x *FrontendConfig) GetProxy() string {
	if x != nil {
		return x.Proxy
	}
	return ""
}

func (x *FrontendConfig) GetProxyConfig() *ProxyConfig {
	if x != nil {
		return x.ProxyConfig
	}
	return nil
}

func (x *FrontendConfig) GetCertificate() string {
	if x != nil {
		return x.Certificate
	}
	return ""
}

func (x *FrontendConfig) GetPrivateKey() string {
	if x != nil {
		return x.PrivateKey
	}
	return ""
}

func (x *FrontendConfig) GetTlsCertificateFilename() string {
	if x != nil {
		return x.TlsCertificateFilename
	}
	return ""
}

func (x *FrontendConfig) GetTlsPrivateKeyFilename() string {
	if x != nil {
		return x.TlsPrivateKeyFilename
	}
	return ""
}

func (x *FrontendConfig) GetDnsName() string {
	if x != nil {
		return x.DnsName
	}
	return ""
}

func (x *FrontendConfig) GetDoNotCompressArtifacts() bool {
	if x != nil {
		return x.DoNotCompressArtifacts
	}
	return false
}

func (x *FrontendConfig) GetDynDns() *DynDNSConfig {
	if x != nil {
		return x.DynDns
	}
	return nil
}

func (x *FrontendConfig) GetProxyHeader() string {
	if x != nil {
		return x.ProxyHeader
	}
	return ""
}

func (x *FrontendConfig) GetDefaultClientMonitoringArtifacts() []string {
	if x != nil {
		return x.DefaultClientMonitoringArtifacts
	}
	return nil
}

func (x *FrontendConfig) GetDefaultServerMonitoringArtifacts() []string {
	if x != nil {
		return x.DefaultServerMonitoringArtifacts
	}
	return nil
}

func (x *FrontendConfig) GetInitialServerArtifacts() []string {
	if x != nil {
		return x.InitialServerArtifacts
	}
	return nil
}

func (x *FrontendConfig) GetRunAsUser() string {
	if x != nil {
		return x.RunAsUser
	}
	return ""
}

func (x *FrontendConfig) GetGRPCPoolMaxSize() int64 {
	if x != nil {
		return x.GRPCPoolMaxSize
	}
	return 0
}

func (x *FrontendConfig) GetGRPCPoolMaxWait() int64 {
	if x != nil {
		return x.GRPCPoolMaxWait
	}
	return 0
}

func (x *FrontendConfig) GetResources() *FrontendResourceControl {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *FrontendConfig) GetIsMinion() bool {
	if x != nil {
		return x.IsMinion
	}
	return false
}

func (x *FrontendConfig) GetConcurrency() uint64 {
	if x != nil {
		return x.Concurrency
	}
	return 0
}

func (x *FrontendConfig) GetMaxUploadSize() uint64 {
	if x != nil {
		return x.MaxUploadSize
	}
	return 0
}

func (x *FrontendConfig) GetExpectedClients() int64 {
	if x != nil {
		return x.ExpectedClients
	}
	return 0
}

func (x *FrontendConfig) GetPerClientUploadRate() int64 {
	if x != nil {
		return x.PerClientUploadRate
	}
	return 0
}

func (x *FrontendConfig) GetGlobalUploadRate() int64 {
	if x != nil {
		return x.GlobalUploadRate
	}
	return 0
}

func (x *FrontendConfig) GetClientEventMaxWait() uint64 {
	if x != nil {
		return x.ClientEventMaxWait
	}
	return 0
}

func (x *FrontendConfig) GetArtifactDefinitionsDirectory() string {
	if x != nil {
		return x.ArtifactDefinitionsDirectory
	}
	return ""
}

func (x *FrontendConfig) GetCollectionErrorRegex() string {
	if x != nil {
		return x.CollectionErrorRegex
	}
	return ""
}

func (x *FrontendConfig) GetDoNotRedirect() bool {
	if x != nil {
		return x.DoNotRedirect
	}
	return false
}

type DatastoreConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	//  4. FileBasedWithRPC - Large files are written to disk (File
	//     store) but small files are accessed via RPC to a local
	//     memcache server. This configuration is suitable for the
	//     Minion node on a slow EFS backed filesystem. All data store
	//     access will go through to the master memcache using gRPC.
	Implementation string `protobuf:"bytes,1,opt,name=implementation,proto3" json:"implementation,omitempty"`
	// For FileBaseDataStore
	Location           string `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
	FilestoreDirectory string `protobuf:"bytes,3,opt,name=filestore_directory,json=filestoreDirectory,proto3" json:"filestore_directory,omitempty"`
	// Allowed settings:
	//   - none: No compression - disable compression in client
	//     transmission. Note that for older clients (prior to 0.75),
	//     compression is not supported anyway, but this setting will
	//     disable compression on new clients as well.
	//   - zlib: Zlib compression enabled on collections. This is the
	//     default setting when communicating with newer clients.
	Compression string `protobuf:"bytes,19,opt,name=compression,proto3" json:"compression,omitempty"`
	// Set to the min required disk space. When we fall below this
	// available disk space, we refuse to write files. This avoids the
	// possibility of writing corrupted files. Default is 50mb. Set to
	// -1 to disable disk space checking.
	MinAllowedFileSpaceMb int64 `protobuf:"varint,15,opt,name=min_allowed_file_space_mb,json=minAllowedFileSpaceMb,proto3" json:"min_allowed_file_space_mb,omitempty"`
	// How often to check the disk space (default 10 sec)
	DiskCheckFrequencySec int64 `protobuf:"varint,16,opt,name=disk_check_frequency_sec,json=diskCheckFrequencySec,proto3" json:"disk_check_frequency_sec,omitempty"`
	// Cap directories to this size after reporting error - this
	// should not happen normally but may happen if the deployment has
	// been very active or due to a bug!
	MaxDirSize uint64 `protobuf:"varint,13,opt,name=max_dir_size,json=maxDirSize,proto3" json:"max_dir_size,omitempty"`
	// How long to expire the memcache (default 10 min)
	MemcacheExpirationSec uint64 `protobuf:"varint,4,opt,name=memcache_expiration_sec,json=memcacheExpirationSec,proto3" json:"memcache_expiration_sec,omitempty"`
	// How many mutations to queue up ahead of busy writers. By
	// default 0 means writes will be blocked until they are handed
	// off to a writer thread. Set to -1 to disable asynchronous
	// writes.
	MemcacheWriteMutationBuffer int64 `protobuf:"varint,5,opt,name=memcache_write_mutation_buffer,json=memcacheWriteMutationBuffer,proto3" json:"memcache_write_mutation_buffer,omitempty"`
	// Number of writing threads - increase for high latency
	// filesystems (default 100).
	MemcacheWriteMutationWriters int64 `protobuf:"varint,6,opt,name=memcache_write_mutation_writers,json=memcacheWriteMutationWriters,proto3" json:"memcache_write_mutation_writers,omitempty"`
	// Aim to not exceed this memory limit.
	MemcacheWriteMaxMemory int64 `protobuf:"varint,17,opt,name=memcache_write_max_memory,json=memcacheWriteMaxMemory,proto3" json:"memcache_write_max_memory,omitempty"` // Default 100Mb
	// How long to delay writes so they can be combined. This applies
	// for writing result sets - we keep the writes in memory for
	// min_age seconds in order to combine further writes. If another
	// write occurs to the same result sets the TTL is extended and
	// writes are delayed. However, once we read max_age, a write is
	// forced. The aim is to keep combine separate writes as much as
	// possible into larger writes but at the same time keep
	// frequently written files from never flushing to disk.
	MemcacheWriteMutationMinAge int64 `protobuf:"varint,14,opt,name=memcache_write_mutation_min_age,json=memcacheWriteMutationMinAge,proto3" json:"memcache_write_mutation_min_age,omitempty"` // Default 1000 msec
	MemcacheWriteMutationMaxAge int64 `protobuf:"varint,9,opt,name=memcache_write_mutation_max_age,json=memcacheWriteMutationMaxAge,proto3" json:"memcache_write_mutation_max_age,omitempty"`  // Default 5000 msec
	// Maximum size of memcache lru (default 10000)
	MemcacheDatastoreMaxSize     int64 `protobuf:"varint,10,opt,name=memcache_datastore_max_size,json=memcacheDatastoreMaxSize,proto3" json:"memcache_datastore_max_size,omitempty"`
	MemcacheDatastoreMaxItemSize int64 `protobuf:"varint,11,opt,name=memcache_datastore_max_item_size,json=memcacheDatastoreMaxItemSize,proto3" json:"memcache_datastore_max_item_size,omitempty"`
	MemcacheDatastoreMaxDirSize  int64 `protobuf:"varint,12,opt,name=memcache_datastore_max_dir_size,json=memcacheDatastoreMaxDirSize,proto3" json:"memcache_datastore_max_dir_size,omitempty"`
	// Remote datastore is used by the minion (default 1000 sec)
	RemoteDatastoreRpcDeadline int64 `protobuf:"varint,18,opt,name=remote_datastore_rpc_deadline,json=remoteDatastoreRpcDeadline,proto3" json:"remote_datastore_rpc_deadline,omitempty"`
	// Experimental - do not set in configs yet!
	MinionImplementation string `protobuf:"bytes,7,opt,name=minion_implementation,json=minionImplementation,proto3" json:"minion_implementation,omitempty"`
	MasterImplementation string `protobuf:"bytes,8,opt,name=master_implementation,json=masterImplementation,proto3" json:"master_implementation,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *DatastoreConfig) Reset() {
	*x = DatastoreConfig{}
	mi := &file_config_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DatastoreConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DatastoreConfig) ProtoMessage() {}

func (x *DatastoreConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DatastoreConfig.ProtoReflect.Descriptor instead.
func (*DatastoreConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{22}
}

func (x *DatastoreConfig) GetImplementation() string {
	if x != nil {
		return x.Implementation
	}
	return ""
}

func (x *DatastoreConfig) GetLocation() string {
	if x != nil {
		return x.Location
	}
	return ""
}

func (x *DatastoreConfig) GetFilestoreDirectory() string {
	if x != nil {
		return x.FilestoreDirectory
	}
	return ""
}

func (x *DatastoreConfig) GetCompression() string {
	if x != nil {
		return x.Compression
	}
	return ""
}

func (x *DatastoreConfig) GetMinAllowedFileSpaceMb() int64 {
	if x != nil {
		return x.MinAllowedFileSpaceMb
	}
	return 0
}

func (x *DatastoreConfig) GetDiskCheckFrequencySec() int64 {
	if x != nil {
		return x.DiskCheckFrequencySec
	}
	return 0
}

func (x *DatastoreConfig) GetMaxDirSize() uint64 {
	if x != nil {
		return x.MaxDirSize
	}
	return 0
}

func (x *DatastoreConfig) GetMemcacheExpirationSec() uint64 {
	if x != nil {
		return x.MemcacheExpirationSec
	}
	return 0
}

func (x *DatastoreConfig) GetMemcacheWriteMutationBuffer() int64 {
	if x != nil {
		return x.MemcacheWriteMutationBuffer
	}
	return 0
}

func (x *DatastoreConfig) GetMemcacheWriteMutationWriters() int64 {
	if x != nil {
		return x.MemcacheWriteMutationWriters
	}
	return 0
}

func (x *DatastoreConfig) GetMemcacheWriteMaxMemory() int64 {
	if x != nil {
		return x.MemcacheWriteMaxMemory
	}
	return 0
}

func (x *DatastoreConfig) GetMemcacheWriteMutationMinAge() int64 {
	if x != nil {
		return x.MemcacheWriteMutationMinAge
	}
	return 0
}

func (x *DatastoreConfig) GetMemcacheWriteMutationMaxAge() int64 {
	if x != nil {
		return x.MemcacheWriteMutationMaxAge
	}
	return 0
}

func (x *DatastoreConfig) GetMemcacheDatastoreMaxSize() int64 {
	if x != nil {
		return x.MemcacheDatastoreMaxSize
	}
	return 0
}

func (x *DatastoreConfig) GetMemcacheDatastoreMaxItemSize() int64 {
	if x != nil {
		return x.MemcacheDatastoreMaxItemSize
	}
	return 0
}

func (x *DatastoreConfig) GetMemcacheDatastoreMaxDirSize() int64 {
	if x != nil {
		return x.MemcacheDatastoreMaxDirSize
	}
	return 0
}

func (x *DatastoreConfig) GetRemoteDatastoreRpcDeadline() int64 {
	if x != nil {
		return x.RemoteDatastoreRpcDeadline
	}
	return 0
}

func (x *DatastoreConfig) GetMinionImplementation() string {
	if x != nil {
		return x.MinionImplementation
	}
	return ""
}

func (x *DatastoreConfig) GetMasterImplementation() string {
	if x != nil {
		return x.MasterImplementation
	}
	return ""
}

// This override occurs at config load times so you can see the final configuration using
// velociraptor --minion --config server.config.yaml config show
type MinionConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Used to override Defaults.notebook_number_of_local_workers
	NotebookNumberOfLocalWorkers int64 `protobuf:"varint,1,opt,name=notebook_number_of_local_workers,json=notebookNumberOfLocalWorkers,proto3" json:"notebook_number_of_local_workers,omitempty"`
	NotebookWorkerPriority       int64 `protobuf:"varint,2,opt,name=notebook_worker_priority,json=notebookWorkerPriority,proto3" json:"notebook_worker_priority,omitempty"`
	unknownFields                protoimpl.UnknownFields
	sizeCache                    protoimpl.SizeCache
}

func (x *MinionConfig) Reset() {
	*x = MinionConfig{}
	mi := &file_config_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MinionConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MinionConfig) ProtoMessage() {}

func (x *MinionConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MinionConfig.ProtoReflect.Descriptor instead.
func (*MinionConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{23}
}

func (x *MinionConfig) GetNotebookNumberOfLocalWorkers() int64 {
	if x != nil {
		return x.NotebookNumberOfLocalWorkers
	}
	return 0
}

func (x *MinionConfig) GetNotebookWorkerPriority() int64 {
	if x != nil {
		return x.NotebookWorkerPriority
	}
	return 0
}

// Configuration for the mail server.
type MailConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	From          string                 `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Server        string                 `protobuf:"bytes,2,opt,name=server,proto3" json:"server,omitempty"`
	ServerPort    uint64                 `protobuf:"varint,3,opt,name=server_port,json=serverPort,proto3" json:"server_port,omitempty"`
	AuthUsername  string                 `protobuf:"bytes,4,opt,name=auth_username,json=authUsername,proto3" json:"auth_username,omitempty"`
	AuthPassword  string                 `protobuf:"bytes,5,opt,name=auth_password,json=authPassword,proto3" json:"auth_password,omitempty"`
	SkipVerify    bool                   `protobuf:"varint,6,opt,name=skip_verify,json=skipVerify,proto3" json:"skip_verify,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MailConfig) Reset() {
	*x = MailConfig{}
	mi := &file_config_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MailConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MailConfig) ProtoMessage() {}

func (x *MailConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MailConfig.ProtoReflect.Descriptor instead.
func (*MailConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{24}
}

func (x *MailConfig) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *MailConfig) GetServer() string {
	if x != nil {
		return x.Server
	}
	return ""
}

func (x *MailConfig) GetServerPort() uint64 {
	if x != nil {
		return x.ServerPort
	}
	return 0
}

func (x *MailConfig) GetAuthUsername() string {
	if x != nil {
		return x.AuthUsername
	}
	return ""
}

func (x *MailConfig) GetAuthPassword() string {
	if x != nil {
		return x.AuthPassword
	}
	return ""
}

func (x *MailConfig) GetSkipVerify() bool {
	if x != nil {
		return x.SkipVerify
	}
	return false
}

type LoggingRetentionConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// How often to rotate the files in seconds.
	RotationTime uint64 `protobuf:"varint,3,opt,name=rotation_time,json=rotationTime,proto3" json:"rotation_time,omitempty"`
	// Maximum age of each file (File will be deleted after this time (1 year).
	MaxAge uint64 `protobuf:"varint,4,opt,name=max_age,json=maxAge,proto3" json:"max_age,omitempty"`
	// If this is true this log source is disabled.
	Disabled      bool `protobuf:"varint,5,opt,name=disabled,proto3" json:"disabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LoggingRetentionConfig) Reset() {
	*x = LoggingRetentionConfig{}
	mi := &file_config_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LoggingRetentionConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoggingRetentionConfig) ProtoMessage() {}

func (x *LoggingRetentionConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoggingRetentionConfig.ProtoReflect.Descriptor instead.
func (*LoggingRetentionConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{25}
}

func (x *LoggingRetentionConfig) GetRotationTime() uint64 {
	if x != nil {
		return x.RotationTime
	}
	return 0
}

func (x *LoggingRetentionConfig) GetMaxAge() uint64 {
	if x != nil {
		return x.MaxAge
	}
	return 0
}

func (x *LoggingRetentionConfig) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

type LoggingConfig struct {
	state                    protoimpl.MessageState  `protogen:"open.v1"`
	OutputDirectory          string                  `protobuf:"bytes,1,opt,name=output_directory,json=outputDirectory,proto3" json:"output_directory,omitempty"`
	SeparateLogsPerComponent bool                    `protobuf:"varint,2,opt,name=separate_logs_per_component,json=separateLogsPerComponent,proto3" json:"separate_logs_per_component,omitempty"`
	RotationTime             uint64                  `protobuf:"varint,3,opt,name=rotation_time,json=rotationTime,proto3" json:"rotation_time,omitempty"`
	MaxAge                   uint64                  `protobuf:"varint,4,opt,name=max_age,json=maxAge,proto3" json:"max_age,omitempty"`
	Debug                    *LoggingRetentionConfig `protobuf:"bytes,5,opt,name=debug,proto3" json:"debug,omitempty"`
	Info                     *LoggingRetentionConfig `protobuf:"bytes,6,opt,name=info,proto3" json:"info,omitempty"`
	Error                    *LoggingRetentionConfig `protobuf:"bytes,7,opt,name=error,proto3" json:"error,omitempty"`
	RemoteSyslogServer       string                  `protobuf:"bytes,8,opt,name=remote_syslog_server,json=remoteSyslogServer,proto3" json:"remote_syslog_server,omitempty"`
	RemoteSyslogProtocol     string                  `protobuf:"bytes,9,opt,name=remote_syslog_protocol,json=remoteSyslogProtocol,proto3" json:"remote_syslog_protocol,omitempty"`
	RemoteSyslogComponents   []string                `protobuf:"bytes,10,rep,name=remote_syslog_components,json=remoteSyslogComponents,proto3" json:"remote_syslog_components,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *LoggingConfig) Reset() {
	*x = LoggingConfig{}
	mi := &file_config_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LoggingConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoggingConfig) ProtoMessage() {}

func (x *LoggingConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoggingConfig.ProtoReflect.Descriptor instead.
func (*LoggingConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{26}
}

func (x *LoggingConfig) GetOutputDirectory() string {
	if x != nil {
		return x.OutputDirectory
	}
	return ""
}

func (x *LoggingConfig) GetSeparateLogsPerComponent() bool {
	if x != nil {
		return x.SeparateLogsPerComponent
	}
	return false
}

func (x *LoggingConfig) GetRotationTime() uint64 {
	if x != nil {
		return x.RotationTime
	}
	return 0
}

func (x *LoggingConfig) GetMaxAge() uint64 {
	if x != nil {
		return x.MaxAge
	}
	return 0
}

func (x *LoggingConfig) GetDebug() *LoggingRetentionConfig {
	if x != nil {
		return x.Debug
	}
	return nil
}

func (x *LoggingConfig) GetInfo() *LoggingRetentionConfig {
	if x != nil {
		return x.Info
	}
	return nil
}

func (x *LoggingConfig) GetError() *LoggingRetentionConfig {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *LoggingConfig) GetRemoteSyslogServer() string {
	if x != nil {
		return x.RemoteSyslogServer
	}
	return ""
}

func (x *LoggingConfig) GetRemoteSyslogProtocol() string {
	if x != nil {
		return x.RemoteSyslogProtocol
	}
	return ""
}

func (x *LoggingConfig) GetRemoteSyslogComponents() []string {
	if x != nil {
		return x.RemoteSyslogComponents
	}
	return nil
}

type MonitoringConfig struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	BindAddress string                 `protobuf:"bytes,1,opt,name=bind_address,json=bindAddress,proto3" json:"bind_address,omitempty"`
	BindPort    uint32                 `protobuf:"varint,2,opt,name=bind_port,json=bindPort,proto3" json:"bind_port,omitempty"`
	// If set we use this in links etc, otherwise we take a guess
	// based on bind_address and bind_port above.
	MetricsUrl    string `protobuf:"bytes,3,opt,name=metrics_url,json=metricsUrl,proto3" json:"metrics_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MonitoringConfig) Reset() {
	*x = MonitoringConfig{}
	mi := &file_config_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MonitoringConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MonitoringConfig) ProtoMessage() {}

func (x *MonitoringConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MonitoringConfig.ProtoReflect.Descriptor instead.
func (*MonitoringConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{27}
}

func (x *MonitoringConfig) GetBindAddress() string {
	if x != nil {
		return x.BindAddress
	}
	return ""
}

func (x *MonitoringConfig) GetBindPort() uint32 {
	if x != nil {
		return x.BindPort
	}
	return 0
}

func (x *MonitoringConfig) GetMetricsUrl() string {
	if x != nil {
		return x.MetricsUrl
	}
	return ""
}

type AutoExecConfig struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	Argv                []string               `protobuf:"bytes,1,rep,name=argv,proto3" json:"argv,omitempty"`
	ArtifactDefinitions []*proto1.Artifact     `protobuf:"bytes,2,rep,name=artifact_definitions,json=artifactDefinitions,proto3" json:"artifact_definitions,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *AutoExecConfig) Reset() {
	*x = AutoExecConfig{}
	mi := &file_config_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutoExecConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoExecConfig) ProtoMessage() {}

func (x *AutoExecConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoExecConfig.ProtoReflect.Descriptor instead.
func (*AutoExecConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{28}
}

func (x *AutoExecConfig) GetArgv() []string {
	if x != nil {
		return x.Argv
	}
	return nil
}

func (x *AutoExecConfig) GetArtifactDefinitions() []*proto1.Artifact {
	if x != nil {
		return x.ArtifactDefinitions
	}
	return nil
}

// Do not set these in the configuration file - they are used internally.
type ServerServicesConfig struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	HuntManager           bool                   `protobuf:"varint,1,opt,name=hunt_manager,json=huntManager,proto3" json:"hunt_manager,omitempty"`
	HuntDispatcher        bool                   `protobuf:"varint,2,opt,name=hunt_dispatcher,json=huntDispatcher,proto3" json:"hunt_dispatcher,omitempty"`
	StatsCollector        bool                   `protobuf:"varint,3,opt,name=stats_collector,json=statsCollector,proto3" json:"stats_collector,omitempty"`
	ServerMonitoring      bool                   `protobuf:"varint,4,opt,name=server_monitoring,json=serverMonitoring,proto3" json:"server_monitoring,omitempty"`
	ServerArtifacts       bool                   `protobuf:"varint,5,opt,name=server_artifacts,json=serverArtifacts,proto3" json:"server_artifacts,omitempty"`
	DynDns                bool                   `protobuf:"varint,6,opt,name=dyn_dns,json=dynDns,proto3" json:"dyn_dns,omitempty"`
	Interrogation         bool                   `protobuf:"varint,7,opt,name=interrogation,proto3" json:"interrogation,omitempty"`
	SanityChecker         bool                   `protobuf:"varint,8,opt,name=sanity_checker,json=sanityChecker,proto3" json:"sanity_checker,omitempty"`
	VfsService            bool                   `protobuf:"varint,9,opt,name=vfs_service,json=vfsService,proto3" json:"vfs_service,omitempty"`
	UserManager           bool                   `protobuf:"varint,10,opt,name=user_manager,json=userManager,proto3" json:"user_manager,omitempty"`
	ClientMonitoring      bool                   `protobuf:"varint,11,opt,name=client_monitoring,json=clientMonitoring,proto3" json:"client_monitoring,omitempty"`
	MonitoringService     bool                   `protobuf:"varint,12,opt,name=monitoring_service,json=monitoringService,proto3" json:"monitoring_service,omitempty"`
	ApiServer             bool                   `protobuf:"varint,13,opt,name=api_server,json=apiServer,proto3" json:"api_server,omitempty"`
	FrontendServer        bool                   `protobuf:"varint,14,opt,name=frontend_server,json=frontendServer,proto3" json:"frontend_server,omitempty"`
	GuiServer             bool                   `protobuf:"varint,15,opt,name=gui_server,json=guiServer,proto3" json:"gui_server,omitempty"`
	IndexServer           bool                   `protobuf:"varint,16,opt,name=index_server,json=indexServer,proto3" json:"index_server,omitempty"`
	JournalService        bool                   `protobuf:"varint,17,opt,name=journal_service,json=journalService,proto3" json:"journal_service,omitempty"`
	ReplicationService    bool                   `protobuf:"varint,26,opt,name=replication_service,json=replicationService,proto3" json:"replication_service,omitempty"`
	NotificationService   bool                   `protobuf:"varint,18,opt,name=notification_service,json=notificationService,proto3" json:"notification_service,omitempty"`
	RepositoryManager     bool                   `protobuf:"varint,19,opt,name=repository_manager,json=repositoryManager,proto3" json:"repository_manager,omitempty"`
	TestRepositoryManager bool                   `protobuf:"varint,25,opt,name=test_repository_manager,json=testRepositoryManager,proto3" json:"test_repository_manager,omitempty"`
	InventoryService      bool                   `protobuf:"varint,20,opt,name=inventory_service,json=inventoryService,proto3" json:"inventory_service,omitempty"`
	ClientInfo            bool                   `protobuf:"varint,21,opt,name=client_info,json=clientInfo,proto3" json:"client_info,omitempty"`
	Label                 bool                   `protobuf:"varint,22,opt,name=label,proto3" json:"label,omitempty"`
	Launcher              bool                   `protobuf:"varint,23,opt,name=launcher,proto3" json:"launcher,omitempty"`
	NotebookService       bool                   `protobuf:"varint,24,opt,name=notebook_service,json=notebookService,proto3" json:"notebook_service,omitempty"`
	SchedulerService      bool                   `protobuf:"varint,29,opt,name=scheduler_service,json=schedulerService,proto3" json:"scheduler_service,omitempty"`
	BackupService         bool                   `protobuf:"varint,30,opt,name=backup_service,json=backupService,proto3" json:"backup_service,omitempty"`
	// Client services
	HttpCommunicator bool `protobuf:"varint,27,opt,name=http_communicator,json=httpCommunicator,proto3" json:"http_communicator,omitempty"`
	ClientEventTable bool `protobuf:"varint,28,opt,name=client_event_table,json=clientEventTable,proto3" json:"client_event_table,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ServerServicesConfig) Reset() {
	*x = ServerServicesConfig{}
	mi := &file_config_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerServicesConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerServicesConfig) ProtoMessage() {}

func (x *ServerServicesConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerServicesConfig.ProtoReflect.Descriptor instead.
func (*ServerServicesConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{29}
}

func (x *ServerServicesConfig) GetHuntManager() bool {
	if x != nil {
		return x.HuntManager
	}
	return false
}

func (x *ServerServicesConfig) GetHuntDispatcher() bool {
	if x != nil {
		return x.HuntDispatcher
	}
	return false
}

func (x *ServerServicesConfig) GetStatsCollector() bool {
	if x != nil {
		return x.StatsCollector
	}
	return false
}

func (x *ServerServicesConfig) GetServerMonitoring() bool {
	if x != nil {
		return x.ServerMonitoring
	}
	return false
}

func (x *ServerServicesConfig) GetServerArtifacts() bool {
	if x != nil {
		return x.ServerArtifacts
	}
	return false
}

func (x *ServerServicesConfig) GetDynDns() bool {
	if x != nil {
		return x.DynDns
	}
	return false
}

func (x *ServerServicesConfig) GetInterrogation() bool {
	if x != nil {
		return x.Interrogation
	}
	return false
}

func (x *ServerServicesConfig) GetSanityChecker() bool {
	if x != nil {
		return x.SanityChecker
	}
	return false
}

func (x *ServerServicesConfig) GetVfsService() bool {
	if x != nil {
		return x.VfsService
	}
	return false
}

func (x *ServerServicesConfig) GetUserManager() bool {
	if x != nil {
		return x.UserManager
	}
	return false
}

func (x *ServerServicesConfig) GetClientMonitoring() bool {
	if x != nil {
		return x.ClientMonitoring
	}
	return false
}

func (x *ServerServicesConfig) GetMonitoringService() bool {
	if x != nil {
		return x.MonitoringService
	}
	return false
}

func (x *ServerServicesConfig) GetApiServer() bool {
	if x != nil {
		return x.ApiServer
	}
	return false
}

func (x *ServerServicesConfig) GetFrontendServer() bool {
	if x != nil {
		return x.FrontendServer
	}
	return false
}

func (x *ServerServicesConfig) GetGuiServer() bool {
	if x != nil {
		return x.GuiServer
	}
	return false
}

func (x *ServerServicesConfig) GetIndexServer() bool {
	if x != nil {
		return x.IndexServer
	}
	return false
}

func (x *ServerServicesConfig) GetJournalService() bool {
	if x != nil {
		return x.JournalService
	}
	return false
}

func (x *ServerServicesConfig) GetReplicationService() bool {
	if x != nil {
		return x.ReplicationService
	}
	return false
}

func (x *ServerServicesConfig) GetNotificationService() bool {
	if x != nil {
		return x.NotificationService
	}
	return false
}

func (x *ServerServicesConfig) GetRepositoryManager() bool {
	if x != nil {
		return x.RepositoryManager
	}
	return false
}

func (x *ServerServicesConfig) GetTestRepositoryManager() bool {
	if x != nil {
		return x.TestRepositoryManager
	}
	return false
}

func (x *ServerServicesConfig) GetInventoryService() bool {
	if x != nil {
		return x.InventoryService
	}
	return false
}

func (x *ServerServicesConfig) GetClientInfo() bool {
	if x != nil {
		return x.ClientInfo
	}
	return false
}

func (x *ServerServicesConfig) GetLabel() bool {
	if x != nil {
		return x.Label
	}
	return false
}

func (x *ServerServicesConfig) GetLauncher() bool {
	if x != nil {
		return x.Launcher
	}
	return false
}

func (x *ServerServicesConfig) GetNotebookService() bool {
	if x != nil {
		return x.NotebookService
	}
	return false
}

func (x *ServerServicesConfig) GetSchedulerService() bool {
	if x != nil {
		return x.SchedulerService
	}
	return false
}

func (x *ServerServicesConfig) GetBackupService() bool {
	if x != nil {
		return x.BackupService
	}
	return false
}

func (x *ServerServicesConfig) GetHttpCommunicator() bool {
	if x != nil {
		return x.HttpCommunicator
	}
	return false
}

func (x *ServerServicesConfig) GetClientEventTable() bool {
	if x != nil {
		return x.ClientEventTable
	}
	return false
}

type Defaults struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	HuntExpiryHours int64                  `protobuf:"varint,1,opt,name=hunt_expiry_hours,json=huntExpiryHours,proto3" json:"hunt_expiry_hours,omitempty"`
	// How often to refresh the hunt index (default 600 sec)
	HuntDispatcherRefreshSec int64 `protobuf:"varint,43,opt,name=hunt_dispatcher_refresh_sec,json=huntDispatcherRefreshSec,proto3" json:"hunt_dispatcher_refresh_sec,omitempty"`
	// By default new cells only list 50 rows if there is no custom
	// cell template. This is to make refreshing the cell
	// quick. Usually users need to edit or the limit clause to see
	// the full result table in the cell. This setting increases the
	// default 50 rows.
	NotebookDefaultNewCellRows int64 `protobuf:"varint,57,opt,name=notebook_default_new_cell_rows,json=notebookDefaultNewCellRows,proto3" json:"notebook_default_new_cell_rows,omitempty"`
	NotebookCellTimeoutMin     int64 `protobuf:"varint,2,opt,name=notebook_cell_timeout_min,json=notebookCellTimeoutMin,proto3" json:"notebook_cell_timeout_min,omitempty"`
	// When calculating a new cell we do not start calculation until
	// the process memory is smaller than the low memory mark.
	NotebookMemoryLowWaterMark uint64 `protobuf:"varint,36,opt,name=notebook_memory_low_water_mark,json=notebookMemoryLowWaterMark,proto3" json:"notebook_memory_low_water_mark,omitempty"`
	// When the process memory exceeds the high water marrk, we
	// actively cancel in flight notebook cell calculations.
	NotebookMemoryHighWaterMark uint64 `protobuf:"varint,37,opt,name=notebook_memory_high_water_mark,json=notebookMemoryHighWaterMark,proto3" json:"notebook_memory_high_water_mark,omitempty"`
	// Wait this long for a worker to become available before giving
	// up.
	NotebookWaitTimeForWorkerMs int64 `protobuf:"varint,46,opt,name=notebook_wait_time_for_worker_ms,json=notebookWaitTimeForWorkerMs,proto3" json:"notebook_wait_time_for_worker_ms,omitempty"`
	// Set to -1 to disable local workers. The default is 5 local
	// workers. If you want the master to **not** perform any notebook
	// computations reduce this to -1 and set
	// Minion.notebook_number_of_local_workers to 5.
	NotebookNumberOfLocalWorkers int64 `protobuf:"varint,38,opt,name=notebook_number_of_local_workers,json=notebookNumberOfLocalWorkers,proto3" json:"notebook_number_of_local_workers,omitempty"`
	// The default priority of notebook processors (Higher priority
	// will receive jobs over lower priority).
	NotebookWorkerPriority int64 `protobuf:"varint,39,opt,name=notebook_worker_priority,json=notebookWorkerPriority,proto3" json:"notebook_worker_priority,omitempty"`
	// Total number of cell versions we keep for undo/redo support.
	NotebookVersions int64 `protobuf:"varint,42,opt,name=notebook_versions,json=notebookVersions,proto3" json:"notebook_versions,omitempty"`
	// The default CSV delimiter
	CsvDelimiter       string `protobuf:"bytes,3,opt,name=csv_delimiter,json=csvDelimiter,proto3" json:"csv_delimiter,omitempty"`
	EventMaxWait       uint64 `protobuf:"varint,4,opt,name=event_max_wait,json=eventMaxWait,proto3" json:"event_max_wait,omitempty"`
	EventMaxWaitJitter uint64 `protobuf:"varint,5,opt,name=event_max_wait_jitter,json=eventMaxWaitJitter,proto3" json:"event_max_wait_jitter,omitempty"`
	// If set we actively notify all clients as soon as event table is
	// changed. This causes a lot of load on large deployments so it
	// is off by default.
	EventChangeNotifyAllClients bool `protobuf:"varint,6,opt,name=event_change_notify_all_clients,json=eventChangeNotifyAllClients,proto3" json:"event_change_notify_all_clients,omitempty"`
	// Deprecated - not used
	MaxVfsDirectorySize uint64 `protobuf:"varint,7,opt,name=max_vfs_directory_size,json=maxVfsDirectorySize,proto3" json:"max_vfs_directory_size,omitempty"`
	// These artifact definitions will also be loaded at start and
	// will be considered built in.
	ArtifactDefinitionsDirectories []string `protobuf:"bytes,8,rep,name=artifact_definitions_directories,json=artifactDefinitionsDirectories,proto3" json:"artifact_definitions_directories,omitempty"`
	// The number of rows to keep in memory during a group by
	// operation. Once this is exceeded we switch to disk mode which
	// is a lot slower. Default 30000
	MaxInMemoryGroupBy uint64 `protobuf:"varint,9,opt,name=max_in_memory_group_by,json=maxInMemoryGroupBy,proto3" json:"max_in_memory_group_by,omitempty"`
	// How long to cache ACL policies (default 60 sec)
	AclLruTimeoutSec uint64 `protobuf:"varint,13,opt,name=acl_lru_timeout_sec,json=aclLruTimeoutSec,proto3" json:"acl_lru_timeout_sec,omitempty"`
	// Ignore messages from unauthenticated clients for this long -
	// gives them a chance to enrol first (default 10 sec).
	UnauthenticatedLruTimeoutSec int64 `protobuf:"varint,14,opt,name=unauthenticated_lru_timeout_sec,json=unauthenticatedLruTimeoutSec,proto3" json:"unauthenticated_lru_timeout_sec,omitempty"`
	// The Maximum size of a sparse file that can be expanded. Files
	// larger than this will not be expanded. This protects the server
	// from expanding potentially Tb worth of sparse files when
	// requested.
	MaxSparseExpandSize uint64 `protobuf:"varint,15,opt,name=max_sparse_expand_size,json=maxSparseExpandSize,proto3" json:"max_sparse_expand_size,omitempty"`
	// Control GUI features
	DisableServerEvents     bool   `protobuf:"varint,26,opt,name=disable_server_events,json=disableServerEvents,proto3" json:"disable_server_events,omitempty"`
	AuthRedirectTemplate    string `protobuf:"bytes,27,opt,name=auth_redirect_template,json=authRedirectTemplate,proto3" json:"auth_redirect_template,omitempty"`
	DisableQuarantineButton bool   `protobuf:"varint,28,opt,name=disable_quarantine_button,json=disableQuarantineButton,proto3" json:"disable_quarantine_button,omitempty"`
	DefaultTheme            string `protobuf:"bytes,29,opt,name=default_theme,json=defaultTheme,proto3" json:"default_theme,omitempty"`
	// Defaults for client communication limits. Decrease those if
	// your clients are behind a proxy that only accepts very small
	// POST messages. If not set we use client defaults.
	MaxRows          uint64 `protobuf:"varint,30,opt,name=max_rows,json=maxRows,proto3" json:"max_rows,omitempty"`
	MaxLogs          uint64 `protobuf:"varint,56,opt,name=max_logs,json=maxLogs,proto3" json:"max_logs,omitempty"`
	MaxRowBufferSize uint64 `protobuf:"varint,31,opt,name=max_row_buffer_size,json=maxRowBufferSize,proto3" json:"max_row_buffer_size,omitempty"`
	MaxBatchWait     uint64 `protobuf:"varint,35,opt,name=max_batch_wait,json=maxBatchWait,proto3" json:"max_batch_wait,omitempty"`
	// Controls how exports work (creating hunt or colletion exports
	// to a zip file).
	ExportConcurrency   int64 `protobuf:"varint,40,opt,name=export_concurrency,json=exportConcurrency,proto3" json:"export_concurrency,omitempty"`
	ExportMaxTimeoutSec int64 `protobuf:"varint,41,opt,name=export_max_timeout_sec,json=exportMaxTimeoutSec,proto3" json:"export_max_timeout_sec,omitempty"`
	// Watch plugin frequency sleep time in seconds: How often
	// watch_syslog() will check for changes (default 3).
	WatchPluginFrequency int64 `protobuf:"varint,44,opt,name=watch_plugin_frequency,json=watchPluginFrequency,proto3" json:"watch_plugin_frequency,omitempty"`
	// Maximum length of the line that will be parsed (16kb)
	WatchPluginBufferSize int64 `protobuf:"varint,45,opt,name=watch_plugin_buffer_size,json=watchPluginBufferSize,proto3" json:"watch_plugin_buffer_size,omitempty"`
	// Period in seconds when to produce a backup
	BackupPeriodSeconds int64 `protobuf:"varint,47,opt,name=backup_period_seconds,json=backupPeriodSeconds,proto3" json:"backup_period_seconds,omitempty"`
	// How often to run the client info's house keeping thread in
	// seconds (default 60 sec)
	ClientInfoHousekeepingPeriod int64 `protobuf:"varint,48,opt,name=client_info_housekeeping_period,json=clientInfoHousekeepingPeriod,proto3" json:"client_info_housekeeping_period,omitempty"`
	// Disable unicode usernames. By default Velociraptor allows
	// usernames to consist of any Unicode character for i8n support,
	// however this opens the possibility for Homoglyph
	// attacks. Setting the following to true will restrict usernames
	// to the set a-z and 0-9
	DisableUnicodeUsernames bool `protobuf:"varint,49,opt,name=disable_unicode_usernames,json=disableUnicodeUsernames,proto3" json:"disable_unicode_usernames,omitempty"`
	// How often to refresh the search index (default 5 min)
	ReindexPeriodSeconds int64 `protobuf:"varint,50,opt,name=reindex_period_seconds,json=reindexPeriodSeconds,proto3" json:"reindex_period_seconds,omitempty"`
	// For example, define here:
	// indexed_client_metadata:
	//   - department
	//
	// Then a search for `department:accounting` will match all
	// clients with the key department and value contains accounting
	// in their client metadata.
	IndexedClientMetadata []string `protobuf:"bytes,51,rep,name=indexed_client_metadata,json=indexedClientMetadata,proto3" json:"indexed_client_metadata,omitempty"`
	// If this is set we do not actively check the status of inflight
	// collections. This is a new feature and may need to be disabled
	// in some large deployments.
	DisableActiveInflightChecks bool  `protobuf:"varint,52,opt,name=disable_active_inflight_checks,json=disableActiveInflightChecks,proto3" json:"disable_active_inflight_checks,omitempty"`
	InflightCheckTime           int64 `protobuf:"varint,59,opt,name=inflight_check_time,json=inflightCheckTime,proto3" json:"inflight_check_time,omitempty"`
	// Normally internal event artifacts are not written to disk but
	// passed internally. For debugging it is useful to have a written
	// record though. Enabling this will also write them to disk.
	WriteInternalEvents bool `protobuf:"varint,53,opt,name=write_internal_events,json=writeInternalEvents,proto3" json:"write_internal_events,omitempty"`
	// DEPRECATED: The below are deprecated and will be moved by the
	// upgrade code.
	AllowedPlugins                        []string `protobuf:"bytes,10,rep,name=allowed_plugins,json=allowedPlugins,proto3" json:"allowed_plugins,omitempty"`
	AllowedFunctions                      []string `protobuf:"bytes,11,rep,name=allowed_functions,json=allowedFunctions,proto3" json:"allowed_functions,omitempty"`
	AllowedAccessors                      []string `protobuf:"bytes,12,rep,name=allowed_accessors,json=allowedAccessors,proto3" json:"allowed_accessors,omitempty"`
	DeniedPlugins                         []string `protobuf:"bytes,54,rep,name=denied_plugins,json=deniedPlugins,proto3" json:"denied_plugins,omitempty"`
	DeniedFunctions                       []string `protobuf:"bytes,55,rep,name=denied_functions,json=deniedFunctions,proto3" json:"denied_functions,omitempty"`
	DeniedAccessors                       []string `protobuf:"bytes,58,rep,name=denied_accessors,json=deniedAccessors,proto3" json:"denied_accessors,omitempty"`
	LockdownDeniedPermissions             []string `protobuf:"bytes,32,rep,name=lockdown_denied_permissions,json=lockdownDeniedPermissions,proto3" json:"lockdown_denied_permissions,omitempty"`
	CertificateValidityDays               int64    `protobuf:"varint,33,opt,name=certificate_validity_days,json=certificateValidityDays,proto3" json:"certificate_validity_days,omitempty"`
	DisableInventoryServiceExternalAccess bool     `protobuf:"varint,34,opt,name=disable_inventory_service_external_access,json=disableInventoryServiceExternalAccess,proto3" json:"disable_inventory_service_external_access,omitempty"`
	unknownFields                         protoimpl.UnknownFields
	sizeCache                             protoimpl.SizeCache
}

func (x *Defaults) Reset() {
	*x = Defaults{}
	mi := &file_config_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Defaults) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Defaults) ProtoMessage() {}

func (x *Defaults) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Defaults.ProtoReflect.Descriptor instead.
func (*Defaults) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{30}
}

func (x *Defaults) GetHuntExpiryHours() int64 {
	if x != nil {
		return x.HuntExpiryHours
	}
	return 0
}

func (x *Defaults) GetHuntDispatcherRefreshSec() int64 {
	if x != nil {
		return x.HuntDispatcherRefreshSec
	}
	return 0
}

func (x *Defaults) GetNotebookDefaultNewCellRows() int64 {
	if x != nil {
		return x.NotebookDefaultNewCellRows
	}
	return 0
}

func (x *Defaults) GetNotebookCellTimeoutMin() int64 {
	if x != nil {
		return x.NotebookCellTimeoutMin
	}
	return 0
}

func (x *Defaults) GetNotebookMemoryLowWaterMark() uint64 {
	if x != nil {
		return x.NotebookMemoryLowWaterMark
	}
	return 0
}

func (x *Defaults) GetNotebookMemoryHighWaterMark() uint64 {
	if x != nil {
		return x.NotebookMemoryHighWaterMark
	}
	return 0
}

func (x *Defaults) GetNotebookWaitTimeForWorkerMs() int64 {
	if x != nil {
		return x.NotebookWaitTimeForWorkerMs
	}
	return 0
}

func (x *Defaults) GetNotebookNumberOfLocalWorkers() int64 {
	if x != nil {
		return x.NotebookNumberOfLocalWorkers
	}
	return 0
}

func (x *Defaults) GetNotebookWorkerPriority() int64 {
	if x != nil {
		return x.NotebookWorkerPriority
	}
	return 0
}

func (x *Defaults) GetNotebookVersions() int64 {
	if x != nil {
		return x.NotebookVersions
	}
	return 0
}

func (x *Defaults) GetCsvDelimiter() string {
	if x != nil {
		return x.CsvDelimiter
	}
	return ""
}

func (x *Defaults) GetEventMaxWait() uint64 {
	if x != nil {
		return x.EventMaxWait
	}
	return 0
}

func (x *Defaults) GetEventMaxWaitJitter() uint64 {
	if x != nil {
		return x.EventMaxWaitJitter
	}
	return 0
}

func (x *Defaults) GetEventChangeNotifyAllClients() bool {
	if x != nil {
		return x.EventChangeNotifyAllClients
	}
	return false
}

func (x *Defaults) GetMaxVfsDirectorySize() uint64 {
	if x != nil {
		return x.MaxVfsDirectorySize
	}
	return 0
}

func (x *Defaults) GetArtifactDefinitionsDirectories() []string {
	if x != nil {
		return x.ArtifactDefinitionsDirectories
	}
	return nil
}

func (x *Defaults) GetMaxInMemoryGroupBy() uint64 {
	if x != nil {
		return x.MaxInMemoryGroupBy
	}
	return 0
}

func (x *Defaults) GetAclLruTimeoutSec() uint64 {
	if x != nil {
		return x.AclLruTimeoutSec
	}
	return 0
}

func (x *Defaults) GetUnauthenticatedLruTimeoutSec() int64 {
	if x != nil {
		return x.UnauthenticatedLruTimeoutSec
	}
	return 0
}

func (x *Defaults) GetMaxSparseExpandSize() uint64 {
	if x != nil {
		return x.MaxSparseExpandSize
	}
	return 0
}

func (x *Defaults) GetDisableServerEvents() bool {
	if x != nil {
		return x.DisableServerEvents
	}
	return false
}

func (x *Defaults) GetAuthRedirectTemplate() string {
	if x != nil {
		return x.AuthRedirectTemplate
	}
	return ""
}

func (x *Defaults) GetDisableQuarantineButton() bool {
	if x != nil {
		return x.DisableQuarantineButton
	}
	return false
}

func (x *Defaults) GetDefaultTheme() string {
	if x != nil {
		return x.DefaultTheme
	}
	return ""
}

func (x *Defaults) GetMaxRows() uint64 {
	if x != nil {
		return x.MaxRows
	}
	return 0
}

func (x *Defaults) GetMaxLogs() uint64 {
	if x != nil {
		return x.MaxLogs
	}
	return 0
}

func (x *Defaults) GetMaxRowBufferSize() uint64 {
	if x != nil {
		return x.MaxRowBufferSize
	}
	return 0
}

func (x *Defaults) GetMaxBatchWait() uint64 {
	if x != nil {
		return x.MaxBatchWait
	}
	return 0
}

func (x *Defaults) GetExportConcurrency() int64 {
	if x != nil {
		return x.ExportConcurrency
	}
	return 0
}

func (x *Defaults) GetExportMaxTimeoutSec() int64 {
	if x != nil {
		return x.ExportMaxTimeoutSec
	}
	return 0
}

func (x *Defaults) GetWatchPluginFrequency() int64 {
	if x != nil {
		return x.WatchPluginFrequency
	}
	return 0
}

func (x *Defaults) GetWatchPluginBufferSize() int64 {
	if x != nil {
		return x.WatchPluginBufferSize
	}
	return 0
}

func (x *Defaults) GetBackupPeriodSeconds() int64 {
	if x != nil {
		return x.BackupPeriodSeconds
	}
	return 0
}

func (x *Defaults) GetClientInfoHousekeepingPeriod() int64 {
	if x != nil {
		return x.ClientInfoHousekeepingPeriod
	}
	return 0
}

func (x *Defaults) GetDisableUnicodeUsernames() bool {
	if x != nil {
		return x.DisableUnicodeUsernames
	}
	return false
}

func (x *Defaults) GetReindexPeriodSeconds() int64 {
	if x != nil {
		return x.ReindexPeriodSeconds
	}
	return 0
}

func (x *Defaults) GetIndexedClientMetadata() []string {
	if x != nil {
		return x.IndexedClientMetadata
	}
	return nil
}

func (x *Defaults) GetDisableActiveInflightChecks() bool {
	if x != nil {
		return x.DisableActiveInflightChecks
	}
	return false
}

func (x *Defaults) GetInflightCheckTime() int64 {
	if x != nil {
		return x.InflightCheckTime
	}
	return 0
}

func (x *Defaults) GetWriteInternalEvents() bool {
	if x != nil {
		return x.WriteInternalEvents
	}
	return false
}

func (x *Defaults) GetAllowedPlugins() []string {
	if x != nil {
		return x.AllowedPlugins
	}
	return nil
}

func (x *Defaults) GetAllowedFunctions() []string {
	if x != nil {
		return x.AllowedFunctions
	}
	return nil
}

func (x *Defaults) GetAllowedAccessors() []string {
	if x != nil {
		return x.AllowedAccessors
	}
	return nil
}

func (x *Defaults) GetDeniedPlugins() []string {
	if x != nil {
		return x.DeniedPlugins
	}
	return nil
}

func (x *Defaults) GetDeniedFunctions() []string {
	if x != nil {
		return x.DeniedFunctions
	}
	return nil
}

func (x *Defaults) GetDeniedAccessors() []string {
	if x != nil {
		return x.DeniedAccessors
	}
	return nil
}

func (x *Defaults) GetLockdownDeniedPermissions() []string {
	if x != nil {
		return x.LockdownDeniedPermissions
	}
	return nil
}

func (x *Defaults) GetCertificateValidityDays() int64 {
	if x != nil {
		return x.CertificateValidityDays
	}
	return 0
}

func (x *Defaults) GetDisableInventoryServiceExternalAccess() bool {
	if x != nil {
		return x.DisableInventoryServiceExternalAccess
	}
	return false
}

// Configures crypto preferences
type CryptoConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Include these root CA's to verify certificates (in addition to
	// built in CA's). Certs should be concatenated in PEM format.
	RootCerts string `protobuf:"bytes,1,opt,name=root_certs,json=rootCerts,proto3" json:"root_certs,omitempty"`
	// Clients may connect to servers which use a self-signed certificate.
	// This list allows to specify a set of certificate thumbprints (SHA256)
	// which are used to validate TLS server certificates.
	//
	// Fingerprints can be generated with the OpenSSL command line utility:
	//
	//	openssl s_client -connect www.google.com:443 < /dev/null | openssl x509 -fingerprint -sha256 -noout
	//
	// Certificate thumbprints may or may not include colon characters. Capitalization
	// of the hex digits is ignored by Velociraptor. A thumbprint of any of the
	// following forms (or combinations thereof) is fine:
	//
	//	E6:E2:8B:35:CE:C5:BA:C4:53:C5:AF:BF:2B:76:34:62:40:5C:D0:60:80:E1:30:1A:A7:A5:A9:DA:0C:8B:11:E1
	//	E6E28B35CEC5BAC453C5AFBF2B763462405CD06080E1301AA7A5A9DA0C8B11E1
	//	e6e28b35cec5bac453c5afbf2b763462405cd06080e1301aa7a5a9da0c8b11e1
	CertificateThumbprints []string `protobuf:"bytes,2,rep,name=certificate_thumbprints,json=certificateThumbprints,proto3" json:"certificate_thumbprints,omitempty"`
	// Velociraptor supports several ways of verifying TLS certificates. The
	// certificate_verification_mode specifies which of the three modes is applied.
	// Currently, three modes are available:
	//   - PKI (the default): verify TLS certs against public CA lists, the list
	//     of additional root_certs, and the built-in CA cert
	//   - PKI_OR_THUMBPRINT: the same as PKI with the addition that certificates
	//     which have a thumbprint that is present in
	//     certificate_thumbprints will be accepted as well
	//   - THUMBPRINT_ONLY: Velociraptor only accepts certificates which have a
	//     matching thumbprint in certificate_thumbprints. All
	//     other certificates will be rejected. This mode is
	//     also known as certificate pinning.
	CertificateVerificationMode string `protobuf:"bytes,3,opt,name=certificate_verification_mode,json=certificateVerificationMode,proto3" json:"certificate_verification_mode,omitempty"`
	// If this is set we do not enforce minimum configuration for TLS
	// servers. This is required when connecting to Velociraptor with
	// some legacy clients (like Powershell) who do not support TLS13
	AllowWeakTlsServer bool `protobuf:"varint,4,opt,name=allow_weak_tls_server,json=allowWeakTlsServer,proto3" json:"allow_weak_tls_server,omitempty"`
	// If you want to use mTLS to mutually authenticate clients to the
	// server, place a list of pem encoded client certificates
	// here. They will be presented to the server if the server
	// requires mTLS authentication.
	ClientCertificate           string `protobuf:"bytes,5,opt,name=client_certificate,json=clientCertificate,proto3" json:"client_certificate,omitempty"`
	ClientCertificatePrivateKey string `protobuf:"bytes,6,opt,name=client_certificate_private_key,json=clientCertificatePrivateKey,proto3" json:"client_certificate_private_key,omitempty"`
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *CryptoConfig) Reset() {
	*x = CryptoConfig{}
	mi := &file_config_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CryptoConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CryptoConfig) ProtoMessage() {}

func (x *CryptoConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CryptoConfig.ProtoReflect.Descriptor instead.
func (*CryptoConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{31}
}

func (x *CryptoConfig) GetRootCerts() string {
	if x != nil {
		return x.RootCerts
	}
	return ""
}

func (x *CryptoConfig) GetCertificateThumbprints() []string {
	if x != nil {
		return x.CertificateThumbprints
	}
	return nil
}

func (x *CryptoConfig) GetCertificateVerificationMode() string {
	if x != nil {
		return x.CertificateVerificationMode
	}
	return ""
}

func (x *CryptoConfig) GetAllowWeakTlsServer() bool {
	if x != nil {
		return x.AllowWeakTlsServer
	}
	return false
}

func (x *CryptoConfig) GetClientCertificate() string {
	if x != nil {
		return x.ClientCertificate
	}
	return ""
}

func (x *CryptoConfig) GetClientCertificatePrivateKey() string {
	if x != nil {
		return x.ClientCertificatePrivateKey
	}
	return ""
}

type MountPoint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Accessor      string                 `protobuf:"bytes,1,opt,name=accessor,proto3" json:"accessor,omitempty"`
	Prefix        string                 `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
	PathType      string                 `protobuf:"bytes,3,opt,name=path_type,json=pathType,proto3" json:"path_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MountPoint) Reset() {
	*x = MountPoint{}
	mi := &file_config_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MountPoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MountPoint) ProtoMessage() {}

func (x *MountPoint) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MountPoint.ProtoReflect.Descriptor instead.
func (*MountPoint) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{32}
}

func (x *MountPoint) GetAccessor() string {
	if x != nil {
		return x.Accessor
	}
	return ""
}

func (x *MountPoint) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *MountPoint) GetPathType() string {
	if x != nil {
		return x.PathType
	}
	return ""
}

type RemappingConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Operation: Currently mount, identify
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Human readable description of what this mapping rule should
	// produce.
	Description string `protobuf:"bytes,10,opt,name=description,proto3" json:"description,omitempty"`
	// A Sequence of VQL LET statements to preconfigure the scope for
	// the accessor in the From clause.
	Scope string `protobuf:"bytes,11,opt,name=scope,proto3" json:"scope,omitempty"`
	// For mount options
	From *MountPoint `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	On   *MountPoint `protobuf:"bytes,3,opt,name=on,proto3" json:"on,omitempty"`
	// For type=permissions - permissions come from acls/acls.go
	Permissions []string `protobuf:"bytes,4,rep,name=permissions,proto3" json:"permissions,omitempty"`
	// For type=impersonation - can be windows, linux, darwin
	Os       string `protobuf:"bytes,5,opt,name=os,proto3" json:"os,omitempty"`
	Hostname string `protobuf:"bytes,6,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Variables to be added to environment strings.
	Env []*proto.VQLEnv `protobuf:"bytes,7,rep,name=env,proto3" json:"env,omitempty"`
	// Disable these plugins and functions (usually for OS specific
	// things that make no sense on an image).
	DisabledFunctions []string `protobuf:"bytes,8,rep,name=disabled_functions,json=disabledFunctions,proto3" json:"disabled_functions,omitempty"`
	DisabledPlugins   []string `protobuf:"bytes,9,rep,name=disabled_plugins,json=disabledPlugins,proto3" json:"disabled_plugins,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *RemappingConfig) Reset() {
	*x = RemappingConfig{}
	mi := &file_config_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemappingConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemappingConfig) ProtoMessage() {}

func (x *RemappingConfig) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemappingConfig.ProtoReflect.Descriptor instead.
func (*RemappingConfig) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{33}
}

func (x *RemappingConfig) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *RemappingConfig) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *RemappingConfig) GetScope() string {
	if x != nil {
		return x.Scope
	}
	return ""
}

func (x *RemappingConfig) GetFrom() *MountPoint {
	if x != nil {
		return x.From
	}
	return nil
}

func (x *RemappingConfig) GetOn() *MountPoint {
	if x != nil {
		return x.On
	}
	return nil
}

func (x *RemappingConfig) GetPermissions() []string {
	if x != nil {
		return x.Permissions
	}
	return nil
}

func (x *RemappingConfig) GetOs() string {
	if x != nil {
		return x.Os
	}
	return ""
}

func (x *RemappingConfig) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *RemappingConfig) GetEnv() []*proto.VQLEnv {
	if x != nil {
		return x.Env
	}
	return nil
}

func (x *RemappingConfig) GetDisabledFunctions() []string {
	if x != nil {
		return x.DisabledFunctions
	}
	return nil
}

func (x *RemappingConfig) GetDisabledPlugins() []string {
	if x != nil {
		return x.DisabledPlugins
	}
	return nil
}

// Various security related configuration options for the server.
type Security struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of path prefixes allowed for the 'file' accessor. If
	// this is empty the file accessor will work on all
	// directories. If you want to disable access to the server's
	// filesystem you can set this to a non existent directory,
	// e.g. /nonexistent/ .
	AllowedFileAccessorPrefix []string `protobuf:"bytes,1,rep,name=allowed_file_accessor_prefix,json=allowedFileAccessorPrefix,proto3" json:"allowed_file_accessor_prefix,omitempty"`
	// Deny takes precedent over allow.
	DeniedFileAccessorPrefix []string `protobuf:"bytes,59,rep,name=denied_file_accessor_prefix,json=deniedFileAccessorPrefix,proto3" json:"denied_file_accessor_prefix,omitempty"`
	// A list of prefixes allowed for the fs accessor. All other
	// prefixes will be rejected. The default is:
	// - artifact_definitions
	// - clients
	// - downloads
	// - notebooks
	// - public
	// - temp
	// - server_artifacts
	// - server_artifacts_logs
	//
	// to allow all access set this to "/"
	AllowedFsAccessorPrefix []string `protobuf:"bytes,2,rep,name=allowed_fs_accessor_prefix,json=allowedFsAccessorPrefix,proto3" json:"allowed_fs_accessor_prefix,omitempty"`
	DeniedFsAccessorPrefix  []string `protobuf:"bytes,60,rep,name=denied_fs_accessor_prefix,json=deniedFsAccessorPrefix,proto3" json:"denied_fs_accessor_prefix,omitempty"`
	// If these are set we enforce VQL to only have the specified
	// allowed VQL plugins and functions. This is a way to harden the
	// server by removing potentially sensitive functionality to allow
	// only approved VQL plugins to run.
	AllowedPlugins   []string `protobuf:"bytes,10,rep,name=allowed_plugins,json=allowedPlugins,proto3" json:"allowed_plugins,omitempty"`
	AllowedFunctions []string `protobuf:"bytes,11,rep,name=allowed_functions,json=allowedFunctions,proto3" json:"allowed_functions,omitempty"`
	AllowedAccessors []string `protobuf:"bytes,12,rep,name=allowed_accessors,json=allowedAccessors,proto3" json:"allowed_accessors,omitempty"`
	// Alternatively, it might be easier to deny specific plugins and
	// functions.
	DeniedPlugins   []string `protobuf:"bytes,54,rep,name=denied_plugins,json=deniedPlugins,proto3" json:"denied_plugins,omitempty"`
	DeniedFunctions []string `protobuf:"bytes,55,rep,name=denied_functions,json=deniedFunctions,proto3" json:"denied_functions,omitempty"`
	DeniedAccessors []string `protobuf:"bytes,58,rep,name=denied_accessors,json=deniedAccessors,proto3" json:"denied_accessors,omitempty"`
	// When the server is in lockdown mode the following permissions
	// will be denied (Even for administrators).
	// The default list is:
	// - ARTIFACT_WRITER
	// - SERVER_ARTIFACT_WRITER
	// - EXECVE
	// - SERVER_ADMIN
	// - FILESYSTEM_WRITE
	// - FILESYSTEM_READ
	// - MACHINE_STATE
	// - NETWORK
	LockdownDeniedPermissions []string `protobuf:"bytes,32,rep,name=lockdown_denied_permissions,json=lockdownDeniedPermissions,proto3" json:"lockdown_denied_permissions,omitempty"`
	// Default expiry of certificate issuances (default 365 days)
	CertificateValidityDays int64 `protobuf:"varint,33,opt,name=certificate_validity_days,json=certificateValidityDays,proto3" json:"certificate_validity_days,omitempty"`
	// Normally the inventory service attempts to download tools in
	// its own but if this is set, we prevent any external access.
	DisableInventoryServiceExternalAccess bool `protobuf:"varint,34,opt,name=disable_inventory_service_external_access,json=disableInventoryServiceExternalAccess,proto3" json:"disable_inventory_service_external_access,omitempty"`
	//  1. If it starts with env:// the secret will be taken from an
	//     Environment variable.
	//  2. If empty the secret is taken from obfuscation_nonce (which
	//     by default is the hash of the private key).
	//
	// In future further methods may be implemented (e.g. EKMS).
	SecretsDek string `protobuf:"bytes,3,opt,name=secrets_dek,json=secretsDek,proto3" json:"secrets_dek,omitempty"`
	// This controls VQL plugins that may accept secrets as well full
	// parameters. If this flag is set, those plugins will refuse to
	// accept direct parameters, instead only accepting a secret
	// name. This allows the admin to control exactly how these
	// plugins work without disabling them completely.
	VqlMustUseSecrets bool `protobuf:"varint,5,opt,name=vql_must_use_secrets,json=vqlMustUseSecrets,proto3" json:"vql_must_use_secrets,omitempty"`
	// Prevent VQL from having access to these environment
	// variables. Environment Vars sometimes may contain secrets and
	// confidential information.
	ShadowedEnvVars []string `protobuf:"bytes,4,rep,name=shadowed_env_vars,json=shadowedEnvVars,proto3" json:"shadowed_env_vars,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Security) Reset() {
	*x = Security{}
	mi := &file_config_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Security) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Security) ProtoMessage() {}

func (x *Security) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Security.ProtoReflect.Descriptor instead.
func (*Security) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{34}
}

func (x *Security) GetAllowedFileAccessorPrefix() []string {
	if x != nil {
		return x.AllowedFileAccessorPrefix
	}
	return nil
}

func (x *Security) GetDeniedFileAccessorPrefix() []string {
	if x != nil {
		return x.DeniedFileAccessorPrefix
	}
	return nil
}

func (x *Security) GetAllowedFsAccessorPrefix() []string {
	if x != nil {
		return x.AllowedFsAccessorPrefix
	}
	return nil
}

func (x *Security) GetDeniedFsAccessorPrefix() []string {
	if x != nil {
		return x.DeniedFsAccessorPrefix
	}
	return nil
}

func (x *Security) GetAllowedPlugins() []string {
	if x != nil {
		return x.AllowedPlugins
	}
	return nil
}

func (x *Security) GetAllowedFunctions() []string {
	if x != nil {
		return x.AllowedFunctions
	}
	return nil
}

func (x *Security) GetAllowedAccessors() []string {
	if x != nil {
		return x.AllowedAccessors
	}
	return nil
}

func (x *Security) GetDeniedPlugins() []string {
	if x != nil {
		return x.DeniedPlugins
	}
	return nil
}

func (x *Security) GetDeniedFunctions() []string {
	if x != nil {
		return x.DeniedFunctions
	}
	return nil
}

func (x *Security) GetDeniedAccessors() []string {
	if x != nil {
		return x.DeniedAccessors
	}
	return nil
}

func (x *Security) GetLockdownDeniedPermissions() []string {
	if x != nil {
		return x.LockdownDeniedPermissions
	}
	return nil
}

func (x *Security) GetCertificateValidityDays() int64 {
	if x != nil {
		return x.CertificateValidityDays
	}
	return 0
}

func (x *Security) GetDisableInventoryServiceExternalAccess() bool {
	if x != nil {
		return x.DisableInventoryServiceExternalAccess
	}
	return false
}

func (x *Security) GetSecretsDek() string {
	if x != nil {
		return x.SecretsDek
	}
	return ""
}

func (x *Security) GetVqlMustUseSecrets() bool {
	if x != nil {
		return x.VqlMustUseSecrets
	}
	return false
}

func (x *Security) GetShadowedEnvVars() []string {
	if x != nil {
		return x.ShadowedEnvVars
	}
	return nil
}

type Config struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Deprecated: Marked as deprecated in config.proto.
	AutocertDomain string          `protobuf:"bytes,21,opt,name=autocert_domain,json=autocertDomain,proto3" json:"autocert_domain,omitempty"`
	Version        *Version        `protobuf:"bytes,8,opt,name=version,proto3" json:"version,omitempty"`
	Client         *ClientConfig   `protobuf:"bytes,1,opt,name=Client,proto3" json:"Client,omitempty"`
	API            *APIConfig      `protobuf:"bytes,2,opt,name=API,proto3" json:"API,omitempty"`
	GUI            *GUIConfig      `protobuf:"bytes,3,opt,name=GUI,proto3" json:"GUI,omitempty"`
	CA             *CAConfig       `protobuf:"bytes,4,opt,name=CA,proto3" json:"CA,omitempty"`
	Frontend       *FrontendConfig `protobuf:"bytes,5,opt,name=Frontend,proto3" json:"Frontend,omitempty"`
	// A list of possible frontends to use. When deployed in
	// multi-frontend configuration we select on those and populate
	// the Frontend field above.
	ExtraFrontends []*FrontendConfig `protobuf:"bytes,31,rep,name=ExtraFrontends,proto3" json:"ExtraFrontends,omitempty"`
	Datastore      *DatastoreConfig  `protobuf:"bytes,6,opt,name=Datastore,proto3" json:"Datastore,omitempty"`
	// Deprecated - Should not appear in new configs and will be
	// ignored. It is only here for backwards compatibility.
	//
	// Deprecated: Marked as deprecated in config.proto.
	Writeback *Writeback `protobuf:"bytes,9,opt,name=Writeback,proto3" json:"Writeback,omitempty"`
	// Deprecated - Mail plugin setting are now provided by args.
	Mail    *MailConfig    `protobuf:"bytes,11,opt,name=Mail,proto3" json:"Mail,omitempty"`
	Logging *LoggingConfig `protobuf:"bytes,23,opt,name=Logging,proto3" json:"Logging,omitempty"`
	// Minion specific overrides
	Minion            *MinionConfig     `protobuf:"bytes,40,opt,name=Minion,proto3" json:"Minion,omitempty"`
	Verbose           bool              `protobuf:"varint,20,opt,name=verbose,proto3" json:"verbose,omitempty"`
	AutocertCertCache string            `protobuf:"bytes,22,opt,name=autocert_cert_cache,json=autocertCertCache,proto3" json:"autocert_cert_cache,omitempty"`
	Monitoring        *MonitoringConfig `protobuf:"bytes,25,opt,name=Monitoring,proto3" json:"Monitoring,omitempty"`
	ApiConfig         *ApiClientConfig  `protobuf:"bytes,26,opt,name=api_config,json=apiConfig,proto3" json:"api_config,omitempty"`
	Autoexec          *AutoExecConfig   `protobuf:"bytes,28,opt,name=autoexec,proto3" json:"autoexec,omitempty"`
	ServerType        string            `protobuf:"bytes,30,opt,name=server_type,json=serverType,proto3" json:"server_type,omitempty"`
	// If set we obfuscate VQL to the clients using this key. If not
	// set this is set to the hash of the Frontend.PrivateKey.
	ObfuscationNonce string `protobuf:"bytes,32,opt,name=obfuscation_nonce,json=obfuscationNonce,proto3" json:"obfuscation_nonce,omitempty"`
	// Various defaults can be changed here (usually not needed).
	Defaults *Defaults `protobuf:"bytes,33,opt,name=defaults,proto3" json:"defaults,omitempty"`
	// The Operating System of the analysis target. Only useful in conjunction
	// with the `device' parameter in case the host's operating system differs
	// from the operating system used on the device. DEPRECATED!
	AnalysisTarget string `protobuf:"bytes,34,opt,name=analysis_target,json=analysisTarget,proto3" json:"analysis_target,omitempty"`
	// host's own file system.
	Remappings []*RemappingConfig `protobuf:"bytes,35,rep,name=remappings,proto3" json:"remappings,omitempty"`
	// These should **not** be set by the user - they are tags
	// internally that mark each org's config object. They should
	// definitely not be set on the client's config because the client
	// does not know or use its own org id.
	OrgId     string `protobuf:"bytes,36,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
	OrgName   string `protobuf:"bytes,37,opt,name=org_name,json=orgName,proto3" json:"org_name,omitempty"`
	DebugMode bool   `protobuf:"varint,41,opt,name=debug_mode,json=debugMode,proto3" json:"debug_mode,omitempty"`
	// The services that will run at initialization. Note this is not
	// set in the config file by the user but is propagated from the
	// startup code.
	Services *ServerServicesConfig `protobuf:"bytes,38,opt,name=services,proto3" json:"services,omitempty"`
	// Specifies various security related configuration options for
	// the server.
	Security *Security `protobuf:"bytes,42,opt,name=security,proto3" json:"security,omitempty"`
	// The Velociraptor server may be placed into "lockdown"
	// mode. While in lockdown mode certain permissions are denied -
	// even for administrators. This additional protection mode helps
	// to mitigate the case when a Velociraptor administrator's
	// account is compromised. The server can be taken out of lockdown
	// mode by setting lockdown to false and restarting the server.
	Lockdown      bool `protobuf:"varint,39,opt,name=lockdown,proto3" json:"lockdown,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Config) Reset() {
	*x = Config{}
	mi := &file_config_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Config) ProtoMessage() {}

func (x *Config) ProtoReflect() protoreflect.Message {
	mi := &file_config_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Config.ProtoReflect.Descriptor instead.
func (*Config) Descriptor() ([]byte, []int) {
	return file_config_proto_rawDescGZIP(), []int{35}
}

// Deprecated: Marked as deprecated in config.proto.
func (x *Config) GetAutocertDomain() string {
	if x != nil {
		return x.AutocertDomain
	}
	return ""
}

func (x *Config) GetVersion() *Version {
	if x != nil {
		return x.Version
	}
	return nil
}

func (x *Config) GetClient() *ClientConfig {
	if x != nil {
		return x.Client
	}
	return nil
}

func (x *Config) GetAPI() *APIConfig {
	if x != nil {
		return x.API
	}
	return nil
}

func (x *Config) GetGUI() *GUIConfig {
	if x != nil {
		return x.GUI
	}
	return nil
}

func (x *Config) GetCA() *CAConfig {
	if x != nil {
		return x.CA
	}
	return nil
}

func (x *Config) GetFrontend() *FrontendConfig {
	if x != nil {
		return x.Frontend
	}
	return nil
}

func (x *Config) GetExtraFrontends() []*FrontendConfig {
	if x != nil {
		return x.ExtraFrontends
	}
	return nil
}

func (x *Config) GetDatastore() *DatastoreConfig {
	if x != nil {
		return x.Datastore
	}
	return nil
}

// Deprecated: Marked as deprecated in config.proto.
func (x *Config) GetWriteback() *Writeback {
	if x != nil {
		return x.Writeback
	}
	return nil
}

func (x *Config) GetMail() *MailConfig {
	if x != nil {
		return x.Mail
	}
	return nil
}

func (x *Config) GetLogging() *LoggingConfig {
	if x != nil {
		return x.Logging
	}
	return nil
}

func (x *Config) GetMinion() *MinionConfig {
	if x != nil {
		return x.Minion
	}
	return nil
}

func (x *Config) GetVerbose() bool {
	if x != nil {
		return x.Verbose
	}
	return false
}

func (x *Config) GetAutocertCertCache() string {
	if x != nil {
		return x.AutocertCertCache
	}
	return ""
}

func (x *Config) GetMonitoring() *MonitoringConfig {
	if x != nil {
		return x.Monitoring
	}
	return nil
}

func (x *Config) GetApiConfig() *ApiClientConfig {
	if x != nil {
		return x.ApiConfig
	}
	return nil
}

func (x *Config) GetAutoexec() *AutoExecConfig {
	if x != nil {
		return x.Autoexec
	}
	return nil
}

func (x *Config) GetServerType() string {
	if x != nil {
		return x.ServerType
	}
	return ""
}

func (x *Config) GetObfuscationNonce() string {
	if x != nil {
		return x.ObfuscationNonce
	}
	return ""
}

func (x *Config) GetDefaults() *Defaults {
	if x != nil {
		return x.Defaults
	}
	return nil
}

func (x *Config) GetAnalysisTarget() string {
	if x != nil {
		return x.AnalysisTarget
	}
	return ""
}

func (x *Config) GetRemappings() []*RemappingConfig {
	if x != nil {
		return x.Remappings
	}
	return nil
}

func (x *Config) GetOrgId() string {
	if x != nil {
		return x.OrgId
	}
	return ""
}

func (x *Config) GetOrgName() string {
	if x != nil {
		return x.OrgName
	}
	return ""
}

func (x *Config) GetDebugMode() bool {
	if x != nil {
		return x.DebugMode
	}
	return false
}

func (x *Config) GetServices() *ServerServicesConfig {
	if x != nil {
		return x.Services
	}
	return nil
}

func (x *Config) GetSecurity() *Security {
	if x != nil {
		return x.Security
	}
	return nil
}

func (x *Config) GetLockdown() bool {
	if x != nil {
		return x.Lockdown
	}
	return false
}

var File_config_proto protoreflect.FileDescriptor

const file_config_proto_rawDesc = "" +
	"\n" +
	"\fconfig.proto\x12\x05proto\x1a\x14proto/semantic.proto\x1a\x17actions/proto/vql.proto\x1a\x1eartifacts/proto/artifact.proto\"\x8d\x04\n" +
	"\aVersion\x12.\n" +
	"\x04name\x18\x01 \x01(\tB\x1a\xe2\xfc\xe3\xc4\x01\x14\x12\x12The client's name.R\x04name\x12N\n" +
	"\vdescription\x18\x02 \x01(\tB,\xe2\xfc\xe3\xc4\x01&\x12$The client's long description stringR\vdescription\x12a\n" +
	"\aversion\x18\x03 \x01(\tBG\xe2\xfc\xe3\xc4\x01A\x12?The client's version string using a semantic versioning scheme.R\aversion\x12?\n" +
	"\x06commit\x18\x04 \x01(\tB'\xe2\xfc\xe3\xc4\x01!\x12\x1fThe client's git commit string.R\x06commit\x12A\n" +
	"\n" +
	"build_time\x18\x05 \x01(\tB\"\xe2\xfc\xe3\xc4\x01\x1c\x12\x1aWhen the client was built.R\tbuildTime\x12!\n" +
	"\finstall_time\x18\b \x01(\x04R\vinstallTime\x12 \n" +
	"\fci_build_url\x18\x06 \x01(\tR\n" +
	"ciBuildUrl\x12\x1a\n" +
	"\bcompiler\x18\a \x01(\tR\bcompiler\x12\x16\n" +
	"\x06system\x18\t \x01(\tR\x06system\x12\"\n" +
	"\farchitecture\x18\n" +
	" \x01(\tR\farchitecture\"=\n" +
	"\x0eFlowCheckPoint\x12\x17\n" +
	"\aflow_id\x18\x01 \x01(\tR\x06flowId\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\"\x88\x05\n" +
	"\tWriteback\x12!\n" +
	"\finstall_time\x18\x10 \x01(\x04R\vinstallTime\x12R\n" +
	"\vprivate_key\x18\a \x01(\tB1\xe2\xfc\xe3\xc4\x01+\x12)The client's private key in PEM encoding.R\n" +
	"privateKey\x12\x1b\n" +
	"\tclient_id\x18\x0f \x01(\tR\bclientId\x12`\n" +
	"\x13hunt_last_timestamp\x18\r \x01(\x04B0\xe2\xfc\xe3\xc4\x01*\x12(The last hunt timestamp this client ran.R\x11huntLastTimestamp\x12\xe8\x01\n" +
	"\x19last_server_serial_number\x18\x0e \x01(\x04B\xac\x01\xe2\xfc\xe3\xc4\x01\xa5\x01\x12\xa2\x01The last certificate serial number we saw from the server. Clients refuse to connect to servers with older serial numbers as part of server key rotation protocol.R\x16lastServerSerialNumber\x12&\n" +
	"\x0flast_server_pem\x18\x12 \x01(\tR\rlastServerPem\x129\n" +
	"\revent_queries\x18\x01 \x01(\v2\x14.proto.VQLEventTableR\feventQueries\x127\n" +
	"\vcheckpoints\x18\x11 \x03(\v2\x15.proto.FlowCheckPointR\vcheckpoints\"S\n" +
	"\x10InitialOrgRecord\x12\x15\n" +
	"\x06org_id\x18\x01 \x01(\tR\x05orgId\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
	"\x05nonce\x18\x03 \x01(\tR\x05nonce\"\xea\x02\n" +
	"\x16WindowsInstallerConfig\x12M\n" +
	"\fservice_name\x18\x01 \x01(\tB*\xe2\xfc\xe3\xc4\x01$\x12\"The name of the service to create.R\vserviceName\x12\xa1\x01\n" +
	"\finstall_path\x18\x02 \x01(\tB~\xe2\xfc\xe3\xc4\x01x\x12vWhere should the binary be installed? The install command copies the binary to this location and installs the service.R\vinstallPath\x12]\n" +
	"\x13service_description\x18\x03 \x01(\tB,\xe2\xfc\xe3\xc4\x01&\x12$Description for the windows service.R\x12serviceDescription\"\x8a\x02\n" +
	"\x15DarwinInstallerConfig\x12M\n" +
	"\fservice_name\x18\x01 \x01(\tB*\xe2\xfc\xe3\xc4\x01$\x12\"The name of the service to create.R\vserviceName\x12\xa1\x01\n" +
	"\finstall_path\x18\x02 \x01(\tB~\xe2\xfc\xe3\xc4\x01x\x12vWhere should the binary be installed? The install command copies the binary to this location and installs the service.R\vinstallPath\"\xf6\x04\n" +
	"\x10RingBufferConfig\x12\x1e\n" +
	"\bfilename\x18\x03 \x01(\tB\x02\x18\x01R\bfilename\x12^\n" +
	"\vmemory_size\x18\x01 \x01(\x04B=\xe2\xfc\xe3\xc4\x017\x125How many bytes to store in the ring buffer in memory.R\n" +
	"memorySize\x12n\n" +
	"\tdisk_size\x18\x02 \x01(\x04BQ\xe2\xfc\xe3\xc4\x01K\x12IHow many bytes to store in the ring buffer on disk (0 mean no disk file).R\bdiskSize\x12x\n" +
	"\x0efilename_linux\x18\x04 \x01(\tBQ\xe2\xfc\xe3\xc4\x01K\x12IName of file to store the ring buffer in (if empty we do not use a file).R\rfilenameLinux\x12|\n" +
	"\x10filename_windows\x18\x05 \x01(\tBQ\xe2\xfc\xe3\xc4\x01K\x12IName of file to store the ring buffer in (if empty we do not use a file).R\x0ffilenameWindows\x12z\n" +
	"\x0ffilename_darwin\x18\x06 \x01(\tBQ\xe2\xfc\xe3\xc4\x01K\x12IName of file to store the ring buffer in (if empty we do not use a file).R\x0efilenameDarwin\"\xc1\x1c\n" +
	"\fClientConfig\x12\x80\x01\n" +
	"\x06labels\x18\x06 \x03(\tBh\xe2\xfc\xe3\xc4\x01b\x12`A list of labels the client has. This allows selected groups of clients to be targeted in hunts.R\x06labels\x12a\n" +
	"\vserver_urls\x18\b \x03(\tB@\xe2\xfc\xe3\xc4\x01:\x128A list of server URLs the client will try to connect to.R\n" +
	"serverUrls\x12\x14\n" +
	"\x05proxy\x18  \x01(\tR\x05proxy\x125\n" +
	"\fproxy_config\x18. \x01(\v2\x12.proto.ProxyConfigR\vproxyConfig\x12\x89\x01\n" +
	"\x0eca_certificate\x18\v \x01(\tBb\xe2\xfc\xe3\xc4\x01\\\x12ZThe CA's certificate encoded in PEM. The client will trust any server signed with this CA.R\rcaCertificate\x12\xbb\x01\n" +
	"\x05nonce\x18\f \x01(\tB\xa4\x01\xe2\xfc\xe3\xc4\x01\x9d\x01\x12\x9a\x01A shared nonce the client will present. The server will reject clients which do not present this key so it must be embedded in the client's configuration.R\x05nonce\x12f\n" +
	"\x10writeback_darwin\x18\x14 \x01(\tB;\xe2\xfc\xe3\xc4\x015\x123A path where darwin clients will write local state.R\x0fwritebackDarwin\x12c\n" +
	"\x0fwriteback_linux\x18\t \x01(\tB:\xe2\xfc\xe3\xc4\x014\x122A path where linux clients will write local state.R\x0ewritebackLinux\x12i\n" +
	"\x11writeback_windows\x18\n" +
	" \x01(\tB<\xe2\xfc\xe3\xc4\x016\x124A path where windows clients will write local state.R\x10writebackWindows\x126\n" +
	"\x17level2_writeback_suffix\x18, \x01(\tR\x15level2WritebackSuffix\x12#\n" +
	"\rtempdir_linux\x18\x01 \x01(\tR\ftempdirLinux\x12'\n" +
	"\x0ftempdir_windows\x18\x02 \x01(\tR\x0etempdirWindows\x12%\n" +
	"\x0etempdir_darwin\x18\x03 \x01(\tR\rtempdirDarwin\x12\x19\n" +
	"\bmin_poll\x18\x0e \x01(\x04R\aminPoll\x12[\n" +
	"\bmax_poll\x18\x0f \x01(\x04B@\xe2\xfc\xe3\xc4\x01:\x123The maximum number of seconds between server polls.2\x03600R\amaxPoll\x12S\n" +
	"\fmax_poll_std\x18\x1b \x01(\x04B1\xe2\xfc\xe3\xc4\x01+\x12%The standard deviation between polls.2\x0230R\n" +
	"maxPollStd\x12'\n" +
	"\x10ws_ping_wait_sec\x18- \x01(\x04R\rwsPingWaitSec\x12;\n" +
	"\x1ananny_max_connection_delay\x18$ \x01(\x04R\x17nannyMaxConnectionDelay\x12{\n" +
	"\x11windows_installer\x18\x10 \x01(\v2\x1d.proto.WindowsInstallerConfigB/\xe2\xfc\xe3\xc4\x01)\x12'Configuration of the windows installer.R\x10windowsInstaller\x12x\n" +
	"\x10darwin_installer\x18\x15 \x01(\v2\x1c.proto.DarwinInstallerConfigB/\xe2\xfc\xe3\xc4\x01)\x12'Configuration of the windows installer.R\x0fdarwinInstaller\x12%\n" +
	"\x0eprevent_execve\x18\x11 \x01(\bR\rpreventExecve\x12(\n" +
	"\aversion\x18\x12 \x01(\v2\x0e.proto.VersionR\aversion\x125\n" +
	"\x0eserver_version\x182 \x01(\v2\x0e.proto.VersionR\rserverVersion\x12r\n" +
	"\x10default_max_wait\x18\x13 \x01(\x04BH\xe2\xfc\xe3\xc4\x01B\x12@The default max time to wait before we send partial VQL results.R\x0edefaultMaxWait\x12\xeb\x01\n" +
	"\x13use_self_signed_ssl\x18\x18 \x01(\bB\xbb\x01\xe2\xfc\xe3\xc4\x01\xb4\x01\x12\xb1\x01If this is set, the client will expect a self signed certificate from the server.NOTE: The self signed certificate must be signed by the Velociraptor CA which is embedded above.R\x10useSelfSignedSsl\x12\xc0\x01\n" +
	"\x12pinned_server_name\x18\x1c \x01(\tB\x91\x01\xe2\xfc\xe3\xc4\x01\x8a\x01\x12\x87\x01Name of the frontend's certificate. If we are using self signed SSL the client will be pinned to this name (default VelociraptorServer)R\x10pinnedServerName\x12n\n" +
	"\x0fmax_upload_size\x18\x19 \x01(\x04BF\xe2\xfc\xe3\xc4\x01@\x12>Maximum size in Bytes we will create uploads for (default 5mb)R\rmaxUploadSize\x12d\n" +
	"\flocal_buffer\x18\x1a \x01(\v2\x17.proto.RingBufferConfigB(\xe2\xfc\xe3\xc4\x01\"\x12 Configure the local ring buffer.R\vlocalBuffer\x121\n" +
	"\x15max_memory_hard_limit\x18\x1d \x01(\x04R\x12maxMemoryHardLimit\x12 \n" +
	"\vconcurrency\x18\x1f \x01(\x04R\vconcurrency\x12-\n" +
	"\x12connection_timeout\x18# \x01(\x04R\x11connectionTimeout\x12+\n" +
	"\x06Crypto\x18! \x01(\v2\x13.proto.CryptoConfigR\x06Crypto\x12/\n" +
	"\x13disable_compression\x18% \x01(\bR\x12disableCompression\x12F\n" +
	" default_server_flow_stats_update\x18' \x01(\x04R\x1cdefaultServerFlowStatsUpdate\x125\n" +
	"\x17client_info_update_time\x18( \x01(\x03R\x14clientInfoUpdateTime\x12\xce\x01\n" +
	"\x12fallback_addresses\x18) \x03(\v2*.proto.ClientConfig.FallbackAddressesEntryBs\xe2\xfc\xe3\xc4\x01m\x12kThis mapping provides fallback addresses for network targets so that a connection may still be established.R\x11fallbackAddresses\x121\n" +
	"\x15dns_cache_refresh_min\x186 \x01(\x04R\x12dnsCacheRefreshMin\x12/\n" +
	"\x13disable_checkpoints\x18* \x01(\bR\x12disableCheckpoints\x12<\n" +
	"\x1aadditional_event_artifacts\x18+ \x03(\tR\x18additionalEventArtifacts\x12!\n" +
	"\flogfile_name\x18/ \x01(\tR\vlogfileName\x12!\n" +
	"\flogfile_size\x180 \x01(\x04R\vlogfileSize\x12\x1d\n" +
	"\n" +
	"panic_file\x181 \x01(\tR\tpanicFile\x12=\n" +
	"\x1binsecure_network_trace_file\x183 \x01(\tR\x18insecureNetworkTraceFile\x12/\n" +
	"\x14low_resource_max_cpu\x184 \x01(\x04R\x11lowResourceMaxCpu\x123\n" +
	"\x16low_resource_cpu_count\x185 \x01(\x04R\x13lowResourceCpuCount\x1aD\n" +
	"\x16FallbackAddressesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xad\x04\n" +
	"\tAPIConfig\x12\x1a\n" +
	"\bhostname\x18\x05 \x01(\tR\bhostname\x12\x99\x01\n" +
	"\fbind_address\x18\x01 \x01(\tBv\xe2\xfc\xe3\xc4\x01p\x12nAddress to bind gRPC endpoint. This should usually only be 127.0.0.1, otherwise be sure to properly secure it.R\vbindAddress\x125\n" +
	"\tbind_port\x18\x02 \x01(\rB\x18\xe2\xfc\xe3\xc4\x01\x12\x12\x10Port to bind to.R\bbindPort\x12b\n" +
	"\vbind_scheme\x18\x03 \x01(\tBA\xe2\xfc\xe3\xc4\x01;\x123A scheme for the listening socket (e.g. tcp, unix).2\x04unixR\n" +
	"bindScheme\x12\xcc\x01\n" +
	"\x0epinned_gw_name\x18\x04 \x01(\tB\xa5\x01\xe2\xfc\xe3\xc4\x01\x9e\x01\x12\x9b\x01Gateway certificate will carry this common name. Note that this name is special because it allows auth bypass for internal gateway calls. Default (GRPC_GW)R\fpinnedGwName\"\xf9\x04\n" +
	"\x0fApiClientConfig\x12a\n" +
	"\x0eca_certificate\x18\x01 \x01(\tB:\xe2\xfc\xe3\xc4\x014\x122The CA certificate used to verify API connections.R\rcaCertificate\x12\x97\x01\n" +
	"\vclient_cert\x18\x02 \x01(\tBv\xe2\xfc\xe3\xc4\x01p\x12nA client certificate that belongs to this client. Generated from the 'velociraptor config api_client' command.R\n" +
	"clientCert\x12]\n" +
	"\x12client_private_key\x18\x03 \x01(\tB/\xe2\xfc\xe3\xc4\x01)\x12'Private key to go with the client_cert.R\x10clientPrivateKey\x12n\n" +
	"\x15api_connection_string\x18\x04 \x01(\tB:\xe2\xfc\xe3\xc4\x014\x122Location where the api endpoint will be available.R\x13apiConnectionString\x12?\n" +
	"\x04name\x18\x05 \x01(\tB+\xe2\xfc\xe3\xc4\x01%\x12#The CommonName for this API client.R\x04name\x12,\n" +
	"\x12pinned_server_name\x18\x06 \x01(\tR\x10pinnedServerName\x12+\n" +
	"\x12max_grpc_recv_size\x18\a \x01(\x04R\x0fmaxGrpcRecvSize\"\x8d\x02\n" +
	"\vProxyConfig\x12\x14\n" +
	"\x05https\x18\x01 \x01(\tR\x05https\x12\x12\n" +
	"\x04http\x18\x02 \x01(\tR\x04http\x12P\n" +
	"\x10proxy_url_regexp\x18\x03 \x03(\v2&.proto.ProxyConfig.ProxyUrlRegexpEntryR\x0eproxyUrlRegexp\x12\x10\n" +
	"\x03pac\x18\x04 \x01(\tR\x03pac\x12-\n" +
	"\x12ignore_environment\x18\x05 \x01(\bR\x11ignoreEnvironment\x1aA\n" +
	"\x13ProxyUrlRegexpEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xe1\x01\n" +
	"\aGUILink\x12\x12\n" +
	"\x04text\x18\x01 \x01(\tR\x04text\x12\x10\n" +
	"\x03url\x18\x02 \x01(\tR\x03url\x12\x19\n" +
	"\bicon_url\x18\x03 \x01(\tR\aiconUrl\x12\x12\n" +
	"\x04type\x18\x04 \x01(\tR\x04type\x12\x17\n" +
	"\anew_tab\x18\x05 \x01(\bR\x06newTab\x12\x16\n" +
	"\x06encode\x18\x06 \x01(\tR\x06encode\x12\x1c\n" +
	"\tparameter\x18\a \x01(\tR\tparameter\x12\x16\n" +
	"\x06method\x18\b \x01(\tR\x06method\x12\x1a\n" +
	"\bdisabled\x18\t \x01(\bR\bdisabled\"\x1f\n" +
	"\aOIDCACL\x12\x14\n" +
	"\x05roles\x18\x01 \x03(\tR\x05roles\"\xfb\x01\n" +
	"\n" +
	"OIDCClaims\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\x12\x14\n" +
	"\x05roles\x18\x02 \x01(\tR\x05roles\x129\n" +
	"\brole_map\x18\x03 \x03(\v2\x1e.proto.OIDCClaims.RoleMapEntryR\aroleMap\x124\n" +
	"\x16allow_unverified_email\x18\x04 \x01(\bR\x14allowUnverifiedEmail\x1aJ\n" +
	"\fRoleMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12$\n" +
	"\x05value\x18\x02 \x01(\v2\x0e.proto.OIDCACLR\x05value:\x028\x01\"\xae\r\n" +
	"\rAuthenticator\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\xb9\x01\n" +
	"\voidc_issuer\x18\x04 \x01(\tB\x97\x01\xe2\xfc\xe3\xc4\x01\x90\x01\x12\x8d\x01URL to OIDC Configuration Document. The configuration should be available in the 'oidc_issuer + /.well-known/openid-configuration' endpoint. R\n" +
	"oidcIssuer\x12\x1b\n" +
	"\toidc_name\x18\x12 \x01(\tR\boidcName\x12\\\n" +
	"\x14oidc_auth_url_params\x18\x18 \x03(\v2+.proto.Authenticator.OidcAuthUrlParamsEntryR\x11oidcAuthUrlParams\x12\x16\n" +
	"\x06avatar\x18\x13 \x01(\tR\x06avatar\x12X\n" +
	"\x0foauth_client_id\x18\x05 \x01(\tB0\xe2\xfc\xe3\xc4\x01*\x12(If set we use oauth authentication flow.R\roauthClientId\x12`\n" +
	"\x13oauth_client_secret\x18\x06 \x01(\tB0\xe2\xfc\xe3\xc4\x01*\x12(If set we use oauth authentication flow.R\x11oauthClientSecret\x12)\n" +
	"\x06claims\x18\x19 \x01(\v2\x11.proto.OIDCClaimsR\x06claims\x12\x1d\n" +
	"\n" +
	"oidc_debug\x18\x1a \x01(\bR\toidcDebug\x12\x16\n" +
	"\x06tenant\x18\a \x01(\tR\x06tenant\x12D\n" +
	"\x10saml_certificate\x18\f \x01(\tB\x19\xe2\xfc\xe3\xc4\x01\x13\x12\x11SAML certificate.R\x0fsamlCertificate\x12C\n" +
	"\x10saml_private_key\x18\r \x01(\tB\x19\xe2\xfc\xe3\xc4\x01\x13\x12\x11SAML private key.R\x0esamlPrivateKey\x12_\n" +
	"\x15saml_idp_metadata_url\x18\x0e \x01(\tB,\xe2\xfc\xe3\xc4\x01&\x12$SAML identity provider metadata URL.R\x12samlIdpMetadataUrl\x12:\n" +
	"\rsaml_root_url\x18\x0f \x01(\tB\x16\xe2\xfc\xe3\xc4\x01\x10\x12\x0eSAML root URL.R\vsamlRootUrl\x12p\n" +
	"\x13saml_user_attribute\x18\x10 \x01(\tB@\xe2\xfc\xe3\xc4\x01:\x128SAML attribute containing value for user identification.R\x11samlUserAttribute\x12\xa9\x01\n" +
	"\x0fsaml_user_roles\x18\x17 \x03(\tB\x80\x01\xe2\xfc\xe3\xc4\x01z\x12xList of roles to assign authenticated SAML users. If this option is not set then no users will be created automatically.R\rsamlUserRoles\x12_\n" +
	"\x18saml_allow_idp_initiated\x18\x1b \x01(\bB&\xe2\xfc\xe3\xc4\x01 \x12\x1eAllow IdP-initiated SAML flow.R\x15samlAllowIdpInitiated\x12C\n" +
	"\x12sub_authenticators\x18\x11 \x03(\v2\x14.proto.AuthenticatorR\x11subAuthenticators\x12i\n" +
	"\x16auth_redirect_template\x18\x15 \x01(\tB3\xe2\xfc\xe3\xc4\x01-\x12+URL to redirect to on Unauthorized API callR\x14authRedirectTemplate\x12B\n" +
	"\x1edefault_roles_for_unknown_user\x18\x16 \x03(\tR\x1adefaultRolesForUnknownUser\x12;\n" +
	"\x1adefault_session_expiry_min\x18\x14 \x01(\x04R\x17defaultSessionExpiryMin\x1aD\n" +
	"\x16OidcAuthUrlParamsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x89\f\n" +
	"\tGUIConfig\x12\x98\x01\n" +
	"\fbind_address\x18\x01 \x01(\tBu\xe2\xfc\xe3\xc4\x01o\x12mAddress to bind GUI endpoint. This should usually only be 127.0.0.1, otherwise be sure to properly secure it.R\vbindAddress\x125\n" +
	"\tbind_port\x18\x02 \x01(\rB\x18\xe2\xfc\xe3\xc4\x01\x12\x12\x10Port to bind to.R\bbindPort\x12!\n" +
	"\fallowed_cidr\x18\x17 \x03(\tR\vallowedCidr\x124\n" +
	"\x16forwarded_proxy_header\x18\x18 \x01(\tR\x14forwardedProxyHeader\x12$\n" +
	"\x0euse_plain_http\x18\x14 \x01(\bR\fusePlainHttp\x12\x1b\n" +
	"\tbase_path\x18\x15 \x01(\tR\bbasePath\x12\xc3\x01\n" +
	"\x0egw_certificate\x18\n" +
	" \x01(\tB\x9b\x01\xe2\xfc\xe3\xc4\x01\x94\x01\x12\x91\x01The GUI exposes a HTTP interface to the gRPC end point.This is the certificate and private key that will be used to connect to the gRPC endpoint.R\rgwCertificate\x12k\n" +
	"\x0egw_private_key\x18\v \x01(\tBE\xe2\xfc\xe3\xc4\x01?\x12=The private key of the frontend server encoded in PEM format.R\fgwPrivateKey\x12E\n" +
	"\n" +
	"public_url\x18\a \x01(\tB&\xe2\xfc\xe3\xc4\x01 \x12\x1eThe public URL of this server.R\tpublicUrl\x12c\n" +
	"\rreverse_proxy\x18\b \x03(\v2\x19.proto.ReverseProxyConfigB#\xe2\xfc\xe3\xc4\x01\x1d\x12\x1bRoutes for reverse proxies.R\freverseProxy\x12U\n" +
	"\x05links\x18\t \x03(\v2\x0e.proto.GUILinkB/\xe2\xfc\xe3\xc4\x01)\x12'Additional links to present in the GUI.R\x05links\x123\n" +
	"\rinitial_users\x18\x11 \x03(\v2\x0e.proto.GUIUserR\finitialUsers\x12:\n" +
	"\finitial_orgs\x18\x16 \x03(\v2\x17.proto.InitialOrgRecordR\vinitialOrgs\x12:\n" +
	"\rauthenticator\x18\x13 \x01(\v2\x14.proto.AuthenticatorR\rauthenticator\x124\n" +
	"\x16artifact_search_filter\x18\x12 \x01(\tR\x14artifactSearchFilter\x12'\n" +
	"\x0ftrusted_origins\x18\x19 \x03(\tR\x0etrustedOrigins\x12)\n" +
	"\x10saml_certificate\x18\f \x01(\tR\x0fsamlCertificate\x12(\n" +
	"\x10saml_private_key\x18\r \x01(\tR\x0esamlPrivateKey\x121\n" +
	"\x15saml_idp_metadata_url\x18\x0e \x01(\tR\x12samlIdpMetadataUrl\x12\"\n" +
	"\rsaml_root_url\x18\x0f \x01(\tR\vsamlRootUrl\x12.\n" +
	"\x13saml_user_attribute\x18\x10 \x01(\tR\x11samlUserAttribute\x123\n" +
	"\x16google_oauth_client_id\x18\x05 \x01(\tR\x13googleOauthClientId\x12;\n" +
	"\x1agoogle_oauth_client_secret\x18\x06 \x01(\tR\x17googleOauthClientSecret\"g\n" +
	"\aGUIUser\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12#\n" +
	"\rpassword_hash\x18\x02 \x01(\tR\fpasswordHash\x12#\n" +
	"\rpassword_salt\x18\x03 \x01(\tR\fpasswordSalt\"\xa3\x01\n" +
	"\bCAConfig\x12\x96\x01\n" +
	"\vprivate_key\x18\x01 \x01(\tBu\xe2\xfc\xe3\xc4\x01o\x12mThe private key of the CA encoded in PEM. This must correspond with the certificate in Client.ca_certificate.R\n" +
	"privateKey\"_\n" +
	"\x12ReverseProxyConfig\x12\x14\n" +
	"\x05route\x18\x01 \x01(\tR\x05route\x12\x10\n" +
	"\x03url\x18\x02 \x01(\tR\x03url\x12!\n" +
	"\frequire_auth\x18\x03 \x01(\bR\vrequireAuth\"\xe8\x02\n" +
	"\fDynDNSConfig\x12\x1e\n" +
	"\bhostname\x18\x01 \x01(\tB\x02\x18\x01R\bhostname\x12\x12\n" +
	"\x04type\x18\b \x01(\tR\x04type\x12#\n" +
	"\rddns_username\x18\x02 \x01(\tR\fddnsUsername\x12#\n" +
	"\rddns_password\x18\x03 \x01(\tR\fddnsPassword\x12#\n" +
	"\rddns_hostname\x18\v \x01(\tR\fddnsHostname\x12\x1d\n" +
	"\n" +
	"update_url\x18\x04 \x01(\tR\tupdateUrl\x12\x1c\n" +
	"\tfrequency\x18\x05 \x01(\x04R\tfrequency\x12\x1f\n" +
	"\vcheckip_url\x18\x06 \x01(\tR\n" +
	"checkipUrl\x12\x1d\n" +
	"\n" +
	"dns_server\x18\a \x01(\tR\tdnsServer\x12\x1b\n" +
	"\tapi_token\x18\t \x01(\tR\bapiToken\x12\x1b\n" +
	"\tzone_name\x18\n" +
	" \x01(\tR\bzoneName\"\x9d\t\n" +
	"\x17FrontendResourceControl\x124\n" +
	"\x16connections_per_second\x18\x01 \x01(\x04R\x14connectionsPerSecond\x128\n" +
	"\x18notifications_per_second\x18\x02 \x01(\x04R\x16notificationsPerSecond\x124\n" +
	"\x16enrollments_per_second\x18\x03 \x01(\x03R\x14enrollmentsPerSecond\x12 \n" +
	"\vconcurrency\x18\t \x01(\x04R\vconcurrency\x12(\n" +
	"\x10target_heap_size\x18\n" +
	" \x01(\x04R\x0etargetHeapSize\x12/\n" +
	"\x13concurrency_timeout\x18\x18 \x01(\x04R\x12concurrencyTimeout\x12`\n" +
	"\x0fmax_upload_size\x18\v \x01(\x04B8\xe2\xfc\xe3\xc4\x012\x120Maximum size in Bytes we will accept uploads forR\rmaxUploadSize\x12p\n" +
	"\x10expected_clients\x18\x0f \x01(\x03BE\xe2\xfc\xe3\xc4\x01?\x12=Expected number of clients in this deployment (default 10000)R\x0fexpectedClients\x123\n" +
	"\x16per_client_upload_rate\x18\x15 \x01(\x03R\x13perClientUploadRate\x12,\n" +
	"\x12global_upload_rate\x18\x16 \x01(\x03R\x10globalUploadRate\x121\n" +
	"\x15client_event_max_wait\x18\x17 \x01(\x04R\x12clientEventMaxWait\x128\n" +
	"\x19minion_batch_wait_time_ms\x18\x19 \x01(\x04R\x15minionBatchWaitTimeMs\x128\n" +
	"\x18index_snapshot_frequency\x18\x1a \x01(\x04R\x16indexSnapshotFrequency\x12-\n" +
	"\x13client_info_lru_ttl\x18\x1b \x01(\x04R\x10clientInfoLruTtl\x121\n" +
	"\x15client_info_sync_time\x18\x1d \x01(\x04R\x12clientInfoSyncTime\x123\n" +
	"\x16client_info_write_time\x18\x1e \x01(\x04R\x13clientInfoWriteTime\x125\n" +
	"\x17max_journal_buffer_size\x18\x1c \x01(\x03R\x14maxJournalBufferSize\x123\n" +
	"\x16default_log_batch_time\x18\x1f \x01(\x04R\x13defaultLogBatchTime\x12H\n" +
	"!default_monitoring_log_batch_time\x18  \x01(\x04R\x1ddefaultMonitoringLogBatchTime\x124\n" +
	"\x16disable_file_buffering\x18! \x01(\bR\x14disableFileBuffering\"\xc6\x13\n" +
	"\x0eFrontendConfig\x12#\n" +
	"\vpublic_path\x18\b \x01(\tB\x02\x18\x01R\n" +
	"publicPath\x12\x1a\n" +
	"\bhostname\x18\x13 \x01(\tR\bhostname\x12!\n" +
	"\fbind_address\x18\x01 \x01(\tR\vbindAddress\x12\x1b\n" +
	"\tbind_port\x18\x02 \x01(\rR\bbindPort\x12\x1b\n" +
	"\tbase_path\x18\x19 \x01(\tR\bbasePath\x12$\n" +
	"\x0euse_plain_http\x18\x18 \x01(\bR\fusePlainHttp\x12>\n" +
	"\x1brequire_client_certificates\x18$ \x01(\bR\x19requireClientCertificates\x12\x14\n" +
	"\x05proxy\x18! \x01(\tR\x05proxy\x125\n" +
	"\fproxy_config\x18% \x01(\v2\x12.proto.ProxyConfigR\vproxyConfig\x12N\n" +
	"\vcertificate\x18\x03 \x01(\tB,\xe2\xfc\xe3\xc4\x01&\x12$X509 Certificate of frontend server.R\vcertificate\x12f\n" +
	"\vprivate_key\x18\x04 \x01(\tBE\xe2\xfc\xe3\xc4\x01?\x12=The private key of the frontend server encoded in PEM format.R\n" +
	"privateKey\x128\n" +
	"\x18tls_certificate_filename\x18\x1c \x01(\tR\x16tlsCertificateFilename\x127\n" +
	"\x18tls_private_key_filename\x18\x1d \x01(\tR\x15tlsPrivateKeyFilename\x12@\n" +
	"\bdns_name\x18\x06 \x01(\tB%\xe2\xfc\xe3\xc4\x01\x1f\x12\x1dThe DNS name of the frontend.R\adnsName\x12\xbb\x02\n" +
	"\x19do_not_compress_artifacts\x18\n" +
	" \x01(\bB\xff\x01\xe2\xfc\xe3\xc4\x01\xf8\x01\x12\xf5\x01When set we do not compress artifacts sent to the client. This is only useful for debugging. Note: Setting this will send the client artifact fields like name and description which may result in information disclosure if the client is untrusted.R\x16doNotCompressArtifacts\x12Z\n" +
	"\adyn_dns\x18\f \x01(\v2\x13.proto.DynDNSConfigB,\xe2\xfc\xe3\xc4\x01&\x12$If set we start the dyn dns service.R\x06dynDns\x12d\n" +
	"\fproxy_header\x18\r \x01(\tBA\xe2\xfc\xe3\xc4\x01;\x129Header defined by the proxy containing the remote addressR\vproxyHeader\x12\x86\x01\n" +
	"#default_client_monitoring_artifacts\x18\x0e \x03(\tB7\xe2\xfc\xe3\xc4\x011\x12/The initial set of client monitoring artifacts.R defaultClientMonitoringArtifacts\x12\x8d\x01\n" +
	"#default_server_monitoring_artifacts\x18\x1f \x03(\tB>\xe2\xfc\xe3\xc4\x018\x126Additional initial set of server monitoring artifacts.R defaultServerMonitoringArtifacts\x128\n" +
	"\x18initial_server_artifacts\x18\" \x03(\tR\x16initialServerArtifacts\x12~\n" +
	"\vrun_as_user\x18\x10 \x01(\tB^\xe2\xfc\xe3\xc4\x01X\x12VThe user that the frontend should run as. If set we refuse to run as a different user.R\trunAsUser\x12+\n" +
	"\x12GRPC_pool_max_size\x18\x11 \x01(\x03R\x0fGRPCPoolMaxSize\x12+\n" +
	"\x12GRPC_pool_max_wait\x18\x12 \x01(\x03R\x0fGRPCPoolMaxWait\x12<\n" +
	"\tresources\x18\x1b \x01(\v2\x1e.proto.FrontendResourceControlR\tresources\x12\x1b\n" +
	"\tis_minion\x18\x1e \x01(\bR\bisMinion\x12`\n" +
	"\vconcurrency\x18\t \x01(\x04B>\xe2\xfc\xe3\xc4\x018\x126The number of client messages to process concurrently.R\vconcurrency\x12`\n" +
	"\x0fmax_upload_size\x18\v \x01(\x04B8\xe2\xfc\xe3\xc4\x012\x120Maximum size in Bytes we will accept uploads forR\rmaxUploadSize\x12p\n" +
	"\x10expected_clients\x18\x0f \x01(\x03BE\xe2\xfc\xe3\xc4\x01?\x12=Expected number of clients in this deployment (default 10000)R\x0fexpectedClients\x123\n" +
	"\x16per_client_upload_rate\x18\x15 \x01(\x03R\x13perClientUploadRate\x12,\n" +
	"\x12global_upload_rate\x18\x16 \x01(\x03R\x10globalUploadRate\x121\n" +
	"\x15client_event_max_wait\x18\x17 \x01(\x04R\x12clientEventMaxWait\x12D\n" +
	"\x1eartifact_definitions_directory\x18  \x01(\tR\x1cartifactDefinitionsDirectory\x124\n" +
	"\x16collection_error_regex\x18# \x01(\tR\x14collectionErrorRegex\x12&\n" +
	"\x0fdo_not_redirect\x18\x1a \x01(\bR\rdoNotRedirect\"\xc2\b\n" +
	"\x0fDatastoreConfig\x12&\n" +
	"\x0eimplementation\x18\x01 \x01(\tR\x0eimplementation\x12\x1a\n" +
	"\blocation\x18\x02 \x01(\tR\blocation\x12/\n" +
	"\x13filestore_directory\x18\x03 \x01(\tR\x12filestoreDirectory\x12 \n" +
	"\vcompression\x18\x13 \x01(\tR\vcompression\x128\n" +
	"\x19min_allowed_file_space_mb\x18\x0f \x01(\x03R\x15minAllowedFileSpaceMb\x127\n" +
	"\x18disk_check_frequency_sec\x18\x10 \x01(\x03R\x15diskCheckFrequencySec\x12 \n" +
	"\fmax_dir_size\x18\r \x01(\x04R\n" +
	"maxDirSize\x126\n" +
	"\x17memcache_expiration_sec\x18\x04 \x01(\x04R\x15memcacheExpirationSec\x12C\n" +
	"\x1ememcache_write_mutation_buffer\x18\x05 \x01(\x03R\x1bmemcacheWriteMutationBuffer\x12E\n" +
	"\x1fmemcache_write_mutation_writers\x18\x06 \x01(\x03R\x1cmemcacheWriteMutationWriters\x129\n" +
	"\x19memcache_write_max_memory\x18\x11 \x01(\x03R\x16memcacheWriteMaxMemory\x12D\n" +
	"\x1fmemcache_write_mutation_min_age\x18\x0e \x01(\x03R\x1bmemcacheWriteMutationMinAge\x12D\n" +
	"\x1fmemcache_write_mutation_max_age\x18\t \x01(\x03R\x1bmemcacheWriteMutationMaxAge\x12=\n" +
	"\x1bmemcache_datastore_max_size\x18\n" +
	" \x01(\x03R\x18memcacheDatastoreMaxSize\x12F\n" +
	" memcache_datastore_max_item_size\x18\v \x01(\x03R\x1cmemcacheDatastoreMaxItemSize\x12D\n" +
	"\x1fmemcache_datastore_max_dir_size\x18\f \x01(\x03R\x1bmemcacheDatastoreMaxDirSize\x12A\n" +
	"\x1dremote_datastore_rpc_deadline\x18\x12 \x01(\x03R\x1aremoteDatastoreRpcDeadline\x123\n" +
	"\x15minion_implementation\x18\a \x01(\tR\x14minionImplementation\x123\n" +
	"\x15master_implementation\x18\b \x01(\tR\x14masterImplementation\"\x90\x01\n" +
	"\fMinionConfig\x12F\n" +
	" notebook_number_of_local_workers\x18\x01 \x01(\x03R\x1cnotebookNumberOfLocalWorkers\x128\n" +
	"\x18notebook_worker_priority\x18\x02 \x01(\x03R\x16notebookWorkerPriority\"\xaa\x03\n" +
	"\n" +
	"MailConfig\x12e\n" +
	"\x04from\x18\x01 \x01(\tBQ\xe2\xfc\xe3\xc4\x01K\x12IWhere the email should be sent from. If not set we use the auth_username.R\x04from\x12;\n" +
	"\x06server\x18\x02 \x01(\tB#\xe2\xfc\xe3\xc4\x01\x1d\x12\x1bAddress of the SMTP server.R\x06server\x12@\n" +
	"\vserver_port\x18\x03 \x01(\x04B\x1f\xe2\xfc\xe3\xc4\x01\x19\x12\x17Port of the SMTP serverR\n" +
	"serverPort\x12H\n" +
	"\rauth_username\x18\x04 \x01(\tB#\xe2\xfc\xe3\xc4\x01\x1d\x12\x1bName to authenticate under.R\fauthUsername\x12K\n" +
	"\rauth_password\x18\x05 \x01(\tB&\xe2\xfc\xe3\xc4\x01 \x12\x1epassword to authenticate with.R\fauthPassword\x12\x1f\n" +
	"\vskip_verify\x18\x06 \x01(\bR\n" +
	"skipVerify\"r\n" +
	"\x16LoggingRetentionConfig\x12#\n" +
	"\rrotation_time\x18\x03 \x01(\x04R\frotationTime\x12\x17\n" +
	"\amax_age\x18\x04 \x01(\x04R\x06maxAge\x12\x1a\n" +
	"\bdisabled\x18\x05 \x01(\bR\bdisabled\"\xfb\x05\n" +
	"\rLoggingConfig\x12u\n" +
	"\x10output_directory\x18\x01 \x01(\tBJ\xe2\xfc\xe3\xc4\x01D\x12BThe location to write log files. If not set we write no log files.R\x0foutputDirectory\x12z\n" +
	"\x1bseparate_logs_per_component\x18\x02 \x01(\bB;\xe2\xfc\xe3\xc4\x015\x123If set, each component will log to a separate file.R\x18separateLogsPerComponent\x12K\n" +
	"\rrotation_time\x18\x03 \x01(\x04B&\xe2\xfc\xe3\xc4\x01 \x12\x1eHow often to rotate the files.R\frotationTime\x12k\n" +
	"\amax_age\x18\x04 \x01(\x04BR\xe2\xfc\xe3\xc4\x01L\x12@Maximum age of each file (File will be deleted after this time).2\b31536000R\x06maxAge\x123\n" +
	"\x05debug\x18\x05 \x01(\v2\x1d.proto.LoggingRetentionConfigR\x05debug\x121\n" +
	"\x04info\x18\x06 \x01(\v2\x1d.proto.LoggingRetentionConfigR\x04info\x123\n" +
	"\x05error\x18\a \x01(\v2\x1d.proto.LoggingRetentionConfigR\x05error\x120\n" +
	"\x14remote_syslog_server\x18\b \x01(\tR\x12remoteSyslogServer\x124\n" +
	"\x16remote_syslog_protocol\x18\t \x01(\tR\x14remoteSyslogProtocol\x128\n" +
	"\x18remote_syslog_components\x18\n" +
	" \x03(\tR\x16remoteSyslogComponents\"\x99\x02\n" +
	"\x10MonitoringConfig\x12\x9f\x01\n" +
	"\fbind_address\x18\x01 \x01(\tB|\xe2\xfc\xe3\xc4\x01v\x12tAddress to bind monitoring endpoint. This should usually only be 127.0.0.1, otherwise be sure to properly secure it.R\vbindAddress\x12B\n" +
	"\tbind_port\x18\x02 \x01(\rB%\xe2\xfc\xe3\xc4\x01\x1f\x12\x1dPort to bind monitoring port.R\bbindPort\x12\x1f\n" +
	"\vmetrics_url\x18\x03 \x01(\tR\n" +
	"metricsUrl\"h\n" +
	"\x0eAutoExecConfig\x12\x12\n" +
	"\x04argv\x18\x01 \x03(\tR\x04argv\x12B\n" +
	"\x14artifact_definitions\x18\x02 \x03(\v2\x0f.proto.ArtifactR\x13artifactDefinitions\"\xc1\t\n" +
	"\x14ServerServicesConfig\x12!\n" +
	"\fhunt_manager\x18\x01 \x01(\bR\vhuntManager\x12'\n" +
	"\x0fhunt_dispatcher\x18\x02 \x01(\bR\x0ehuntDispatcher\x12'\n" +
	"\x0fstats_collector\x18\x03 \x01(\bR\x0estatsCollector\x12+\n" +
	"\x11server_monitoring\x18\x04 \x01(\bR\x10serverMonitoring\x12)\n" +
	"\x10server_artifacts\x18\x05 \x01(\bR\x0fserverArtifacts\x12\x17\n" +
	"\adyn_dns\x18\x06 \x01(\bR\x06dynDns\x12$\n" +
	"\rinterrogation\x18\a \x01(\bR\rinterrogation\x12%\n" +
	"\x0esanity_checker\x18\b \x01(\bR\rsanityChecker\x12\x1f\n" +
	"\vvfs_service\x18\t \x01(\bR\n" +
	"vfsService\x12!\n" +
	"\fuser_manager\x18\n" +
	" \x01(\bR\vuserManager\x12+\n" +
	"\x11client_monitoring\x18\v \x01(\bR\x10clientMonitoring\x12-\n" +
	"\x12monitoring_service\x18\f \x01(\bR\x11monitoringService\x12\x1d\n" +
	"\n" +
	"api_server\x18\r \x01(\bR\tapiServer\x12'\n" +
	"\x0ffrontend_server\x18\x0e \x01(\bR\x0efrontendServer\x12\x1d\n" +
	"\n" +
	"gui_server\x18\x0f \x01(\bR\tguiServer\x12!\n" +
	"\findex_server\x18\x10 \x01(\bR\vindexServer\x12'\n" +
	"\x0fjournal_service\x18\x11 \x01(\bR\x0ejournalService\x12/\n" +
	"\x13replication_service\x18\x1a \x01(\bR\x12replicationService\x121\n" +
	"\x14notification_service\x18\x12 \x01(\bR\x13notificationService\x12-\n" +
	"\x12repository_manager\x18\x13 \x01(\bR\x11repositoryManager\x126\n" +
	"\x17test_repository_manager\x18\x19 \x01(\bR\x15testRepositoryManager\x12+\n" +
	"\x11inventory_service\x18\x14 \x01(\bR\x10inventoryService\x12\x1f\n" +
	"\vclient_info\x18\x15 \x01(\bR\n" +
	"clientInfo\x12\x14\n" +
	"\x05label\x18\x16 \x01(\bR\x05label\x12\x1a\n" +
	"\blauncher\x18\x17 \x01(\bR\blauncher\x12)\n" +
	"\x10notebook_service\x18\x18 \x01(\bR\x0fnotebookService\x12+\n" +
	"\x11scheduler_service\x18\x1d \x01(\bR\x10schedulerService\x12%\n" +
	"\x0ebackup_service\x18\x1e \x01(\bR\rbackupService\x12+\n" +
	"\x11http_communicator\x18\x1b \x01(\bR\x10httpCommunicator\x12,\n" +
	"\x12client_event_table\x18\x1c \x01(\bR\x10clientEventTable\"\xe3\x14\n" +
	"\bDefaults\x12*\n" +
	"\x11hunt_expiry_hours\x18\x01 \x01(\x03R\x0fhuntExpiryHours\x12=\n" +
	"\x1bhunt_dispatcher_refresh_sec\x18+ \x01(\x03R\x18huntDispatcherRefreshSec\x12B\n" +
	"\x1enotebook_default_new_cell_rows\x189 \x01(\x03R\x1anotebookDefaultNewCellRows\x129\n" +
	"\x19notebook_cell_timeout_min\x18\x02 \x01(\x03R\x16notebookCellTimeoutMin\x12B\n" +
	"\x1enotebook_memory_low_water_mark\x18$ \x01(\x04R\x1anotebookMemoryLowWaterMark\x12D\n" +
	"\x1fnotebook_memory_high_water_mark\x18% \x01(\x04R\x1bnotebookMemoryHighWaterMark\x12E\n" +
	" notebook_wait_time_for_worker_ms\x18. \x01(\x03R\x1bnotebookWaitTimeForWorkerMs\x12F\n" +
	" notebook_number_of_local_workers\x18& \x01(\x03R\x1cnotebookNumberOfLocalWorkers\x128\n" +
	"\x18notebook_worker_priority\x18' \x01(\x03R\x16notebookWorkerPriority\x12+\n" +
	"\x11notebook_versions\x18* \x01(\x03R\x10notebookVersions\x12#\n" +
	"\rcsv_delimiter\x18\x03 \x01(\tR\fcsvDelimiter\x12$\n" +
	"\x0eevent_max_wait\x18\x04 \x01(\x04R\feventMaxWait\x121\n" +
	"\x15event_max_wait_jitter\x18\x05 \x01(\x04R\x12eventMaxWaitJitter\x12D\n" +
	"\x1fevent_change_notify_all_clients\x18\x06 \x01(\bR\x1beventChangeNotifyAllClients\x123\n" +
	"\x16max_vfs_directory_size\x18\a \x01(\x04R\x13maxVfsDirectorySize\x12H\n" +
	" artifact_definitions_directories\x18\b \x03(\tR\x1eartifactDefinitionsDirectories\x122\n" +
	"\x16max_in_memory_group_by\x18\t \x01(\x04R\x12maxInMemoryGroupBy\x12-\n" +
	"\x13acl_lru_timeout_sec\x18\r \x01(\x04R\x10aclLruTimeoutSec\x12E\n" +
	"\x1funauthenticated_lru_timeout_sec\x18\x0e \x01(\x03R\x1cunauthenticatedLruTimeoutSec\x123\n" +
	"\x16max_sparse_expand_size\x18\x0f \x01(\x04R\x13maxSparseExpandSize\x122\n" +
	"\x15disable_server_events\x18\x1a \x01(\bR\x13disableServerEvents\x124\n" +
	"\x16auth_redirect_template\x18\x1b \x01(\tR\x14authRedirectTemplate\x12:\n" +
	"\x19disable_quarantine_button\x18\x1c \x01(\bR\x17disableQuarantineButton\x12#\n" +
	"\rdefault_theme\x18\x1d \x01(\tR\fdefaultTheme\x12\x19\n" +
	"\bmax_rows\x18\x1e \x01(\x04R\amaxRows\x12\x19\n" +
	"\bmax_logs\x188 \x01(\x04R\amaxLogs\x12-\n" +
	"\x13max_row_buffer_size\x18\x1f \x01(\x04R\x10maxRowBufferSize\x12$\n" +
	"\x0emax_batch_wait\x18# \x01(\x04R\fmaxBatchWait\x12-\n" +
	"\x12export_concurrency\x18( \x01(\x03R\x11exportConcurrency\x123\n" +
	"\x16export_max_timeout_sec\x18) \x01(\x03R\x13exportMaxTimeoutSec\x124\n" +
	"\x16watch_plugin_frequency\x18, \x01(\x03R\x14watchPluginFrequency\x127\n" +
	"\x18watch_plugin_buffer_size\x18- \x01(\x03R\x15watchPluginBufferSize\x122\n" +
	"\x15backup_period_seconds\x18/ \x01(\x03R\x13backupPeriodSeconds\x12E\n" +
	"\x1fclient_info_housekeeping_period\x180 \x01(\x03R\x1cclientInfoHousekeepingPeriod\x12:\n" +
	"\x19disable_unicode_usernames\x181 \x01(\bR\x17disableUnicodeUsernames\x124\n" +
	"\x16reindex_period_seconds\x182 \x01(\x03R\x14reindexPeriodSeconds\x126\n" +
	"\x17indexed_client_metadata\x183 \x03(\tR\x15indexedClientMetadata\x12C\n" +
	"\x1edisable_active_inflight_checks\x184 \x01(\bR\x1bdisableActiveInflightChecks\x12.\n" +
	"\x13inflight_check_time\x18; \x01(\x03R\x11inflightCheckTime\x122\n" +
	"\x15write_internal_events\x185 \x01(\bR\x13writeInternalEvents\x12'\n" +
	"\x0fallowed_plugins\x18\n" +
	" \x03(\tR\x0eallowedPlugins\x12+\n" +
	"\x11allowed_functions\x18\v \x03(\tR\x10allowedFunctions\x12+\n" +
	"\x11allowed_accessors\x18\f \x03(\tR\x10allowedAccessors\x12%\n" +
	"\x0edenied_plugins\x186 \x03(\tR\rdeniedPlugins\x12)\n" +
	"\x10denied_functions\x187 \x03(\tR\x0fdeniedFunctions\x12)\n" +
	"\x10denied_accessors\x18: \x03(\tR\x0fdeniedAccessors\x12>\n" +
	"\x1blockdown_denied_permissions\x18  \x03(\tR\x19lockdownDeniedPermissions\x12:\n" +
	"\x19certificate_validity_days\x18! \x01(\x03R\x17certificateValidityDays\x12X\n" +
	")disable_inventory_service_external_access\x18\" \x01(\bR%disableInventoryServiceExternalAccess\"\xad\x04\n" +
	"\fCryptoConfig\x12\x1d\n" +
	"\n" +
	"root_certs\x18\x01 \x01(\tR\trootCerts\x12\x7f\n" +
	"\x17certificate_thumbprints\x18\x02 \x03(\tBF\xe2\xfc\xe3\xc4\x01@\x12>SHA256 thumbprints of certificates that the client will trust.R\x16certificateThumbprints\x12\xd5\x01\n" +
	"\x1dcertificate_verification_mode\x18\x03 \x01(\tB\x90\x01\xe2\xfc\xe3\xc4\x01\x89\x01\x12\x86\x01Selects the way in which Velociraptor verifies TLS certificates. Allowed values: PKI (the default), PKI_OR_THUMBPRINT, THUMBPRINT_ONLYR\x1bcertificateVerificationMode\x121\n" +
	"\x15allow_weak_tls_server\x18\x04 \x01(\bR\x12allowWeakTlsServer\x12-\n" +
	"\x12client_certificate\x18\x05 \x01(\tR\x11clientCertificate\x12C\n" +
	"\x1eclient_certificate_private_key\x18\x06 \x01(\tR\x1bclientCertificatePrivateKey\"]\n" +
	"\n" +
	"MountPoint\x12\x1a\n" +
	"\baccessor\x18\x01 \x01(\tR\baccessor\x12\x16\n" +
	"\x06prefix\x18\x02 \x01(\tR\x06prefix\x12\x1b\n" +
	"\tpath_type\x18\x03 \x01(\tR\bpathType\"\xf0\x02\n" +
	"\x0fRemappingConfig\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12 \n" +
	"\vdescription\x18\n" +
	" \x01(\tR\vdescription\x12\x14\n" +
	"\x05scope\x18\v \x01(\tR\x05scope\x12%\n" +
	"\x04from\x18\x02 \x01(\v2\x11.proto.MountPointR\x04from\x12!\n" +
	"\x02on\x18\x03 \x01(\v2\x11.proto.MountPointR\x02on\x12 \n" +
	"\vpermissions\x18\x04 \x03(\tR\vpermissions\x12\x0e\n" +
	"\x02os\x18\x05 \x01(\tR\x02os\x12\x1a\n" +
	"\bhostname\x18\x06 \x01(\tR\bhostname\x12\x1f\n" +
	"\x03env\x18\a \x03(\v2\r.proto.VQLEnvR\x03env\x12-\n" +
	"\x12disabled_functions\x18\b \x03(\tR\x11disabledFunctions\x12)\n" +
	"\x10disabled_plugins\x18\t \x03(\tR\x0fdisabledPlugins\"\xd6\x06\n" +
	"\bSecurity\x12?\n" +
	"\x1callowed_file_accessor_prefix\x18\x01 \x03(\tR\x19allowedFileAccessorPrefix\x12=\n" +
	"\x1bdenied_file_accessor_prefix\x18; \x03(\tR\x18deniedFileAccessorPrefix\x12;\n" +
	"\x1aallowed_fs_accessor_prefix\x18\x02 \x03(\tR\x17allowedFsAccessorPrefix\x129\n" +
	"\x19denied_fs_accessor_prefix\x18< \x03(\tR\x16deniedFsAccessorPrefix\x12'\n" +
	"\x0fallowed_plugins\x18\n" +
	" \x03(\tR\x0eallowedPlugins\x12+\n" +
	"\x11allowed_functions\x18\v \x03(\tR\x10allowedFunctions\x12+\n" +
	"\x11allowed_accessors\x18\f \x03(\tR\x10allowedAccessors\x12%\n" +
	"\x0edenied_plugins\x186 \x03(\tR\rdeniedPlugins\x12)\n" +
	"\x10denied_functions\x187 \x03(\tR\x0fdeniedFunctions\x12)\n" +
	"\x10denied_accessors\x18: \x03(\tR\x0fdeniedAccessors\x12>\n" +
	"\x1blockdown_denied_permissions\x18  \x03(\tR\x19lockdownDeniedPermissions\x12:\n" +
	"\x19certificate_validity_days\x18! \x01(\x03R\x17certificateValidityDays\x12X\n" +
	")disable_inventory_service_external_access\x18\" \x01(\bR%disableInventoryServiceExternalAccess\x12\x1f\n" +
	"\vsecrets_dek\x18\x03 \x01(\tR\n" +
	"secretsDek\x12/\n" +
	"\x14vql_must_use_secrets\x18\x05 \x01(\bR\x11vqlMustUseSecrets\x12*\n" +
	"\x11shadowed_env_vars\x18\x04 \x03(\tR\x0fshadowedEnvVars\"\xc3\r\n" +
	"\x06Config\x12+\n" +
	"\x0fautocert_domain\x18\x15 \x01(\tB\x02\x18\x01R\x0eautocertDomain\x12F\n" +
	"\aversion\x18\b \x01(\v2\x0e.proto.VersionB\x1c\xe2\xfc\xe3\xc4\x01\x16\x12\x14Version information.R\aversion\x12J\n" +
	"\x06Client\x18\x01 \x01(\v2\x13.proto.ClientConfigB\x1d\xe2\xfc\xe3\xc4\x01\x17\x12\x15Client configuration.R\x06Client\x12P\n" +
	"\x03API\x18\x02 \x01(\v2\x10.proto.APIConfigB,\xe2\xfc\xe3\xc4\x01&\x12$Configuration for gRPC API endpoint.R\x03API\x12\"\n" +
	"\x03GUI\x18\x03 \x01(\v2\x10.proto.GUIConfigR\x03GUI\x12\x1f\n" +
	"\x02CA\x18\x04 \x01(\v2\x0f.proto.CAConfigR\x02CA\x121\n" +
	"\bFrontend\x18\x05 \x01(\v2\x15.proto.FrontendConfigR\bFrontend\x12=\n" +
	"\x0eExtraFrontends\x18\x1f \x03(\v2\x15.proto.FrontendConfigR\x0eExtraFrontends\x124\n" +
	"\tDatastore\x18\x06 \x01(\v2\x16.proto.DatastoreConfigR\tDatastore\x122\n" +
	"\tWriteback\x18\t \x01(\v2\x10.proto.WritebackB\x02\x18\x01R\tWriteback\x12%\n" +
	"\x04Mail\x18\v \x01(\v2\x11.proto.MailConfigR\x04Mail\x12.\n" +
	"\aLogging\x18\x17 \x01(\v2\x14.proto.LoggingConfigR\aLogging\x12+\n" +
	"\x06Minion\x18( \x01(\v2\x13.proto.MinionConfigR\x06Minion\x12@\n" +
	"\averbose\x18\x14 \x01(\bB&\xe2\xfc\xe3\xc4\x01 \x12\x1eEnable verbose logging output.R\averbose\x12\\\n" +
	"\x13autocert_cert_cache\x18\x16 \x01(\tB,\xe2\xfc\xe3\xc4\x01&\x12$Path to store autocert certificates.R\x11autocertCertCache\x12n\n" +
	"\n" +
	"Monitoring\x18\x19 \x01(\v2\x17.proto.MonitoringConfigB5\xe2\xfc\xe3\xc4\x01/\x12-Where to bind prometheus monitoring endpoint.R\n" +
	"Monitoring\x12\x7f\n" +
	"\n" +
	"api_config\x18\x1a \x01(\v2\x16.proto.ApiClientConfigBH\xe2\xfc\xe3\xc4\x01B\x12@If we loaded the api config we load this into the global config.R\tapiConfig\x12\x8f\x01\n" +
	"\bautoexec\x18\x1c \x01(\v2\x15.proto.AutoExecConfigB\\\xe2\xfc\xe3\xc4\x01V\x12TIf this is specified we launch the binary with the given command line automatically.R\bautoexec\x12P\n" +
	"\vserver_type\x18\x1e \x01(\tB/\xe2\xfc\xe3\xc4\x01)\x12'Type of server (linux, windows, darwin)R\n" +
	"serverType\x12+\n" +
	"\x11obfuscation_nonce\x18  \x01(\tR\x10obfuscationNonce\x12+\n" +
	"\bdefaults\x18! \x01(\v2\x0f.proto.DefaultsR\bdefaults\x12'\n" +
	"\x0fanalysis_target\x18\" \x01(\tR\x0eanalysisTarget\x126\n" +
	"\n" +
	"remappings\x18# \x03(\v2\x16.proto.RemappingConfigR\n" +
	"remappings\x12\x15\n" +
	"\x06org_id\x18$ \x01(\tR\x05orgId\x12\x19\n" +
	"\borg_name\x18% \x01(\tR\aorgName\x12\x1d\n" +
	"\n" +
	"debug_mode\x18) \x01(\bR\tdebugMode\x127\n" +
	"\bservices\x18& \x01(\v2\x1b.proto.ServerServicesConfigR\bservices\x12+\n" +
	"\bsecurity\x18* \x01(\v2\x0f.proto.SecurityR\bsecurity\x12\x1a\n" +
	"\blockdown\x18' \x01(\bR\blockdownB4Z2www.velocidex.com/golang/velociraptor/config/protob\x06proto3"

var (
	file_config_proto_rawDescOnce sync.Once
	file_config_proto_rawDescData []byte
)

func file_config_proto_rawDescGZIP() []byte {
	file_config_proto_rawDescOnce.Do(func() {
		file_config_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_config_proto_rawDesc), len(file_config_proto_rawDesc)))
	})
	return file_config_proto_rawDescData
}

var file_config_proto_msgTypes = make([]protoimpl.MessageInfo, 40)
var file_config_proto_goTypes = []any{
	(*Version)(nil),                 // 0: proto.Version
	(*FlowCheckPoint)(nil),          // 1: proto.FlowCheckPoint
	(*Writeback)(nil),               // 2: proto.Writeback
	(*InitialOrgRecord)(nil),        // 3: proto.InitialOrgRecord
	(*WindowsInstallerConfig)(nil),  // 4: proto.WindowsInstallerConfig
	(*DarwinInstallerConfig)(nil),   // 5: proto.DarwinInstallerConfig
	(*RingBufferConfig)(nil),        // 6: proto.RingBufferConfig
	(*ClientConfig)(nil),            // 7: proto.ClientConfig
	(*APIConfig)(nil),               // 8: proto.APIConfig
	(*ApiClientConfig)(nil),         // 9: proto.ApiClientConfig
	(*ProxyConfig)(nil),             // 10: proto.ProxyConfig
	(*GUILink)(nil),                 // 11: proto.GUILink
	(*OIDCACL)(nil),                 // 12: proto.OIDCACL
	(*OIDCClaims)(nil),              // 13: proto.OIDCClaims
	(*Authenticator)(nil),           // 14: proto.Authenticator
	(*GUIConfig)(nil),               // 15: proto.GUIConfig
	(*GUIUser)(nil),                 // 16: proto.GUIUser
	(*CAConfig)(nil),                // 17: proto.CAConfig
	(*ReverseProxyConfig)(nil),      // 18: proto.ReverseProxyConfig
	(*DynDNSConfig)(nil),            // 19: proto.DynDNSConfig
	(*FrontendResourceControl)(nil), // 20: proto.FrontendResourceControl
	(*FrontendConfig)(nil),          // 21: proto.FrontendConfig
	(*DatastoreConfig)(nil),         // 22: proto.DatastoreConfig
	(*MinionConfig)(nil),            // 23: proto.MinionConfig
	(*MailConfig)(nil),              // 24: proto.MailConfig
	(*LoggingRetentionConfig)(nil),  // 25: proto.LoggingRetentionConfig
	(*LoggingConfig)(nil),           // 26: proto.LoggingConfig
	(*MonitoringConfig)(nil),        // 27: proto.MonitoringConfig
	(*AutoExecConfig)(nil),          // 28: proto.AutoExecConfig
	(*ServerServicesConfig)(nil),    // 29: proto.ServerServicesConfig
	(*Defaults)(nil),                // 30: proto.Defaults
	(*CryptoConfig)(nil),            // 31: proto.CryptoConfig
	(*MountPoint)(nil),              // 32: proto.MountPoint
	(*RemappingConfig)(nil),         // 33: proto.RemappingConfig
	(*Security)(nil),                // 34: proto.Security
	(*Config)(nil),                  // 35: proto.Config
	nil,                             // 36: proto.ClientConfig.FallbackAddressesEntry
	nil,                             // 37: proto.ProxyConfig.ProxyUrlRegexpEntry
	nil,                             // 38: proto.OIDCClaims.RoleMapEntry
	nil,                             // 39: proto.Authenticator.OidcAuthUrlParamsEntry
	(*proto.VQLEventTable)(nil),     // 40: proto.VQLEventTable
	(*proto1.Artifact)(nil),         // 41: proto.Artifact
	(*proto.VQLEnv)(nil),            // 42: proto.VQLEnv
}
var file_config_proto_depIdxs = []int32{
	40, // 0: proto.Writeback.event_queries:type_name -> proto.VQLEventTable
	1,  // 1: proto.Writeback.checkpoints:type_name -> proto.FlowCheckPoint
	10, // 2: proto.ClientConfig.proxy_config:type_name -> proto.ProxyConfig
	4,  // 3: proto.ClientConfig.windows_installer:type_name -> proto.WindowsInstallerConfig
	5,  // 4: proto.ClientConfig.darwin_installer:type_name -> proto.DarwinInstallerConfig
	0,  // 5: proto.ClientConfig.version:type_name -> proto.Version
	0,  // 6: proto.ClientConfig.server_version:type_name -> proto.Version
	6,  // 7: proto.ClientConfig.local_buffer:type_name -> proto.RingBufferConfig
	31, // 8: proto.ClientConfig.Crypto:type_name -> proto.CryptoConfig
	36, // 9: proto.ClientConfig.fallback_addresses:type_name -> proto.ClientConfig.FallbackAddressesEntry
	37, // 10: proto.ProxyConfig.proxy_url_regexp:type_name -> proto.ProxyConfig.ProxyUrlRegexpEntry
	38, // 11: proto.OIDCClaims.role_map:type_name -> proto.OIDCClaims.RoleMapEntry
	39, // 12: proto.Authenticator.oidc_auth_url_params:type_name -> proto.Authenticator.OidcAuthUrlParamsEntry
	13, // 13: proto.Authenticator.claims:type_name -> proto.OIDCClaims
	14, // 14: proto.Authenticator.sub_authenticators:type_name -> proto.Authenticator
	18, // 15: proto.GUIConfig.reverse_proxy:type_name -> proto.ReverseProxyConfig
	11, // 16: proto.GUIConfig.links:type_name -> proto.GUILink
	16, // 17: proto.GUIConfig.initial_users:type_name -> proto.GUIUser
	3,  // 18: proto.GUIConfig.initial_orgs:type_name -> proto.InitialOrgRecord
	14, // 19: proto.GUIConfig.authenticator:type_name -> proto.Authenticator
	10, // 20: proto.FrontendConfig.proxy_config:type_name -> proto.ProxyConfig
	19, // 21: proto.FrontendConfig.dyn_dns:type_name -> proto.DynDNSConfig
	20, // 22: proto.FrontendConfig.resources:type_name -> proto.FrontendResourceControl
	25, // 23: proto.LoggingConfig.debug:type_name -> proto.LoggingRetentionConfig
	25, // 24: proto.LoggingConfig.info:type_name -> proto.LoggingRetentionConfig
	25, // 25: proto.LoggingConfig.error:type_name -> proto.LoggingRetentionConfig
	41, // 26: proto.AutoExecConfig.artifact_definitions:type_name -> proto.Artifact
	32, // 27: proto.RemappingConfig.from:type_name -> proto.MountPoint
	32, // 28: proto.RemappingConfig.on:type_name -> proto.MountPoint
	42, // 29: proto.RemappingConfig.env:type_name -> proto.VQLEnv
	0,  // 30: proto.Config.version:type_name -> proto.Version
	7,  // 31: proto.Config.Client:type_name -> proto.ClientConfig
	8,  // 32: proto.Config.API:type_name -> proto.APIConfig
	15, // 33: proto.Config.GUI:type_name -> proto.GUIConfig
	17, // 34: proto.Config.CA:type_name -> proto.CAConfig
	21, // 35: proto.Config.Frontend:type_name -> proto.FrontendConfig
	21, // 36: proto.Config.ExtraFrontends:type_name -> proto.FrontendConfig
	22, // 37: proto.Config.Datastore:type_name -> proto.DatastoreConfig
	2,  // 38: proto.Config.Writeback:type_name -> proto.Writeback
	24, // 39: proto.Config.Mail:type_name -> proto.MailConfig
	26, // 40: proto.Config.Logging:type_name -> proto.LoggingConfig
	23, // 41: proto.Config.Minion:type_name -> proto.MinionConfig
	27, // 42: proto.Config.Monitoring:type_name -> proto.MonitoringConfig
	9,  // 43: proto.Config.api_config:type_name -> proto.ApiClientConfig
	28, // 44: proto.Config.autoexec:type_name -> proto.AutoExecConfig
	30, // 45: proto.Config.defaults:type_name -> proto.Defaults
	33, // 46: proto.Config.remappings:type_name -> proto.RemappingConfig
	29, // 47: proto.Config.services:type_name -> proto.ServerServicesConfig
	34, // 48: proto.Config.security:type_name -> proto.Security
	12, // 49: proto.OIDCClaims.RoleMapEntry.value:type_name -> proto.OIDCACL
	50, // [50:50] is the sub-list for method output_type
	50, // [50:50] is the sub-list for method input_type
	50, // [50:50] is the sub-list for extension type_name
	50, // [50:50] is the sub-list for extension extendee
	0,  // [0:50] is the sub-list for field type_name
}

func init() { file_config_proto_init() }
func file_config_proto_init() {
	if File_config_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_config_proto_rawDesc), len(file_config_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   40,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_config_proto_goTypes,
		DependencyIndexes: file_config_proto_depIdxs,
		MessageInfos:      file_config_proto_msgTypes,
	}.Build()
	File_config_proto = out.File
	file_config_proto_goTypes = nil
	file_config_proto_depIdxs = nil
}
