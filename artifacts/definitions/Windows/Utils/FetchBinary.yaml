name: Windows.Utils.FetchBinary
description: A utility artifact which fetches a binary from a URL and caches it on disk.
   We verify the hash of the binary on disk and if it does not match we fetch it again
   from the source URL.

   This artifact is designed to be called from other artifacts. The binary path will be
   emitted in the FullPath column.

parameters:
  - name: binaryURL
    description: |
      Specify this as the base of the binary store (if empty we use
      the server's public directory).
  - name: ToolName
    default: Autorun

sources:
  - queries:
      - LET info_cache <= SELECT * FROM info()

      # Figure out our binary cache path based on arch. Fallback to
      # the temp directory.
      - |
        LET binpath <= SELECT dirname(path=expand(path=Path)) AS Path FROM chain(
          a={SELECT config.WritebackWindows AS Path FROM info_cache WHERE OS="windows"},
          b={SELECT config.WritebacLinux AS Path FROM info_cache WHERE OS="linux"},
          c={SELECT config.WritebackDarwin AS Path FROM info_cache WHERE OS="darwin"},
          d={SELECT expand(path="$Temp") AS Path FROM scope()}
        ) LIMIT 1

      # Where should we download binaries from? Allow this to be
      # overriden by the user.
      - |
        LET inventory_url = SELECT URL from if(
         condition=binaryURL,
         then={SELECT binaryURL AS URL from scope()},
         else={
           SELECT get(
              item=config.ServerUrls + "public/",
              member="0") AS URL
           FROM scope()
        })

      # Fetch the inventory from the repository.
      - |
        LET inventory_data = SELECT * FROM foreach(
            row=inventory_url,
            query={SELECT * FROM http_client(url=URL + "inventory.csv")})

      # Parse the inventory: Tool,Type,URL,ExpectedHash
      - |
        LET inventory = SELECT * FROM foreach(
         row=inventory_data,
         query={
            SELECT * FROM parse_csv(filename=Content, accessor="data")
         })

      # Figure out which tool we need based on the Architecture and
      # the required tool.
      - |
        LET required_tool = SELECT * FROM foreach(
         row=inventory,
         query={
           SELECT Tool, ExpectedHash, URL FROM info_cache
           WHERE Architecture =~ Type AND Tool = ToolName
         })

      # Download the file from the binary URL and store in the local
      # binary cache.
      - |
        LET download = SELECT hash(path=Content) as Hash,
            copy(filename=Content,
                 dest=binpath.Path+"/"+basename(path=URL)) AS FullPath
        FROM http_client(
            url=inventory_url.URL + URL,
            tempfile_extension=".exe")
        WHERE Hash.SHA256 = ExpectedHash

      # Check if the existing file in the binary file cache matches
      # the hash.
      - |
        LET existing = SELECT FullPath, hash(path=FullPath) AS Hash
        FROM stat(filename=binpath.Path + "/" + basename(path=URL))
        WHERE Hash.SHA256 = ExpectedHash

      # Find the required_tool either if in the local cache or
      # download it (and put it in the cache for next time).
      - |
        SELECT * from foreach(row=required_tool, query={
          SELECT * FROM chain(a=existing, b=download) LIMIT 1
        })
