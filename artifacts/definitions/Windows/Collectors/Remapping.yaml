name: Windows.Collectors.Remapping
description: |
  Calculate a remapping file for a collection container (zip).

  You can create the collection container using the offline collector or by
  exporting the `Windows.Triage.Targets` collection from the GUI.

  This artifact calculates a remapping config that allows Velociraptor to
  directly analyze the contents of the zip file itself, without needing to
  extract it first. This is useful for serverless analysis without having to
  import the artifact first.

  The remapping allows Velociraptor to treat the collection zip as a dead disk
  image in a similar way to `Generic.Utils.DeadDiskRemapping`

  ## Usage instructions

  1. Collect files using a triage bulk file collection - For example
     `Windows.Registry.AppCompatCache` with the `_BasicCollection` target is a
     good option.

  2. Generate the remapping file:

  ```
  velociraptor artifacts collect -v Windows.Collectors.Remapping \
     --args ZipPath=/path/to/triage_collection.zip \
     --args WriteRemappingPath=/tmp/test.remapping.yaml
  ```

  3. Apply the remapping file when collecting further artifacts:

  ```
  velociraptor --remap /tmp/test.remapping.yaml \
    artifacts collect -v Windows.Registry.Hunter \
       --args RemappingStrategy=None
  ```

  Note that for `Windows.Registry.Hunter` we need to disable its own remapping
  config so that the remapping we provide takes hold.

type: SERVER

parameters:
  - name: ZipPath
    default: /tmp/exports/decrypted.zip
    description: Path to the collection zip file to inspect

  - name: Accessor
    default: collector
    type: hidden

  - name: Hostname
    description: If NOT specified we try to read it from the collection container

  - name: Upload
    type: bool
    default: "Y"
    description: If specified we upload the generated YAML

  - name: WriteRemappingPath
    description: If specified we write the yaml file to this path

  - name: CommonRemapping
    description: Common clauses for all remapping in YAML
    default: |
      remappings:
      - type: permissions
        permissions:
        - COLLECT_CLIENT
        - FILESYSTEM_READ
        - FILESYSTEM_WRITE
        - READ_RESULTS
        - MACHINE_STATE
        - SERVER_ADMIN
        - COLLECT_SERVER
        - EXECVE
      - type: impersonation
        os: windows
        hostname: "{{ .Hostname }}"
        env:
        - key: SystemRoot
          value: C:\Windows
        - key: WinDir
          value: C:\Windows
        disabled_functions:
        - amsi
        - lookupSID
        - token
        disabled_plugins:
        - execve
        - http_client
        - users
        - certificates
        - handles
        - pslist
        - interfaces
        - modules
        - netstat
        - partitions
        - proc_dump
        - proc_yara
        - vad
        - winobj
        - wmi
      - type: shadow
        from:
          accessor: zip
        "on":
          accessor: zip
      - type: shadow
        from:
          accessor: raw_reg
        "on":
          accessor: raw_reg
      - type: shadow
        from:
          accessor: data
        "on":
          accessor: data

export: |
  LET CollectionHostinfo = parse_json(
      data=read_file(accessor=Accessor,
                     filename=pathspec(DelegatePath=ZipPath,
                                       DelegateAccessor="file",
                                       path_type="zip",
                                       Path="client_info.json")))

  -- Set the hostname either from the parameters or read it from the
  -- file itself
  LET DerivedHostname = Hostname ||
     CollectionHostinfo.Hostname ||
     CollectionHostinfo.hostname

  LET Remappings = parse_yaml(
      filename=template(template=CommonRemapping,
                        expansion=dict(Hostname=DerivedHostname)),
      accessor="data")

  -- Normalize the drive name from device to drive. NTFS accessor uses
  -- device notation. TODO - we currently do nothing with VSS devices.
  LET NormalizeDrive(Path) = regex_transform(
      source=Path,
      map=dict(`\\\\\\\\.\\\\`=""), key="A")

  // Get all the unique drive letters so we can combine them at the
  // same place.
  LET AllDrives = SELECT enumerate(items=OSPath) AS Paths,
           NormalizeDrive(Path=OSPath.Basename) AS Drive,
           OSPath AS OSPath
      FROM glob(
        accessor=Accessor,
        globs="/uploads/*/*",
        root=pathspec(DelegatePath=ZipPath, DelegateAccessor="file"))
      GROUP BY Drive

  LET ScopeTemplate <= '''
  LET OVERLAY_ACCESSOR_DELEGATES <= dict(
       accessor="collector",
       paths={{ .Paths }})
  '''

  -- Overlay the files that were fetched with all accessors into the
  -- same directory.
  LET Overlays = SELECT * FROM foreach(row=["auto", "file", "ntfs"],
   query={
      SELECT
         dict(type="mount",
              scope=template(template=ScopeTemplate,
                             expansion=dict(Paths=serialize(item=Paths))),
              `from`=dict(accessor="overlay"),
              `on`=dict(accessor=_value,
                        prefix=Drive,
                        path_type="windows")) AS Clauses
      FROM AllDrives
    })

  -- Search for the hive with this glob and add the first match into
  -- the registry path specified.
  LET _FindHive(HiveGlob, RegPath) = SELECT
        dict(type="mount",
             description=format(format="Map %v to %v",
                          args=[OSPath.Path, RegPath]),
             `from`=dict(accessor="raw_reg",
                         path_type="registry",
                         prefix=serialize(format="json",
                            item=dict(DelegateAccessor=Accessor,
                                      DelegatePath=OSPath.PathSpec.String))),
             `on`=dict(accessor="registry",
                       path_type="registry",
                       prefix=RegPath)) AS Clauses
    FROM glob(globs=HiveGlob,
              accessor=Accessor,
              root=pathspec(Path="/uploads/",
                            DelegateAccessor="file",
                            DelegatePath=ZipPath))
      LIMIT 1

  -- Look for user hives and map them in HKEY_USERS
  LET _FindDirUserHives = SELECT
        dict(type="mount",
             description=format(format="Map %v to %v",
                          args=[OSPath.Path, RegPath]),
             `from`=dict(accessor="raw_reg",
                         path_type="registry",
                         prefix=serialize(format="json",
                            item=dict(DelegateAccessor=Accessor,
                                      DelegatePath=OSPath.PathSpec.String))),
             `on`=dict(accessor="registry",
                       path_type="registry",
                       prefix="HKEY_USERS/" + OSPath[4])) AS Clauses
    FROM glob(globs="*/*/Users/*/NTUser.dat",
              accessor=Accessor,
              root=pathspec(Path="/uploads/",
                            DelegateAccessor="file",
                            DelegatePath=ZipPath))

  LET RegistryMappings = SELECT * FROM chain(
    a={
      SELECT *
      FROM _FindHive(HiveGlob="*/*/Windows/System32/config/Software",
                     RegPath="HKEY_LOCAL_MACHINE/Software")
    }, b={
      SELECT *
      FROM _FindHive(HiveGlob="*/*/Windows/System32/config/Security",
                     RegPath="HKEY_LOCAL_MACHINE/Security")
    }, c={
      SELECT *
      FROM _FindHive(HiveGlob="*/*/Windows/System32/config/System",
                     RegPath="HKEY_LOCAL_MACHINE/System")
    }, d={
      SELECT *
      FROM _FindHive(HiveGlob="*/*/Windows/System32/config/SAM",
                     RegPath="SAM")
    }, e={
      SELECT *
      FROM _FindHive(HiveGlob="*/*/Windows/appcompat/Programs/Amcache.hve",
                     RegPath="Amcache")
    }, f={
      SELECT * FROM _FindDirUserHives
    })

sources:
- name: WriteRemapping
  query: |
    LET CalculateMappings <= Remappings.remappings +
       Overlays.Clauses +
       RegistryMappings.Clauses

    LET YamlText = serialize(format="yaml",
                              item=dict(remappings=CalculateMappings))

    SELECT CalculateMappings,
        Upload && upload(accessor="data", file=YamlText, name="remapping.yaml") AS Upload,
        WriteRemappingPath && copy(
              dest=WriteRemappingPath,
              accessor='data',
              filename=YamlText) AS RemappingFile
    FROM scope()


- name: CollectionHostInfo
  query: SELECT CollectionHostinfo FROM scope()

- name: TestRegistryAccess
  query: |
    LET _ <= remap(config=YamlText)
    SELECT OSPath
    FROM glob(globs="HKEY_LOCAL_MACHINE/Software/*", accessor='registry')

- name: TestFileAccess
  query: |
    SELECT OSPath
    FROM glob(globs="*/*")
