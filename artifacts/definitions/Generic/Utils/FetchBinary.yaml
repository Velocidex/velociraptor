name: Generic.Utils.FetchBinary
description: |
   A utility artifact which fetches a binary from a URL and caches it on disk.
   We verify the hash of the binary on disk and if it does not match we fetch it again
   from the source URL.

   This artifact is designed to be called from other artifacts. The
   binary path will be emitted in the FullPath column.

   As a result of launching an artifact with declared "required_tools"
   field, the server will populate the following environment
   variables.

   Tool_<ToolName>_HASH     - The hash of the binary
   Tool_<ToolName>_FILENAME - The filename to store it.
   Tool_<ToolName>_URL      - The URL.

parameters:
  - name: ToolName
    default: Autorun_amd64

  - name: SleepDuration
    default: "20"
    description: A time to sleep before fetching the binary.

  - name: ToolInfo
    type: hidden
    description: A dict containing the tool information.

sources:
  - query: |
      LET info_cache <= SELECT * FROM info()
      LET ToolInfo <= if(condition=ToolInfo, then=ToolInfo, else=scope())
      LET ToolHash <= get(field="Tool_" + ToolName + "_HASH", item=ToolInfo)
      LET ToolFilename <= get(field="Tool_" + ToolName + "_FILENAME", item=ToolInfo)
      LET ToolURL <= get(field="Tool_" + ToolName + "_URL", item=ToolInfo)

      // Figure out our binary cache path based on arch. Fallback to
      // the temp directory.
      LET binpath <= SELECT Path FROM switch(
          a={SELECT dirname(path=tempfile()) AS Path FROM scope() WHERE Path},
          b={SELECT dirname(path=expand(path=config.WritebackWindows)) AS Path
             FROM info_cache WHERE OS="windows" AND Path},
          c={SELECT dirname(path=expand(path=config.WritebackLinux)) AS Path
             FROM info_cache WHERE OS="linux" AND Path},
          d={SELECT dirname(path=expand(path=config.WritebackDarwin)) AS Path
             FROM info_cache WHERE OS="darwin" AND Path},
          e={SELECT "/tmp" AS Path FROM info_cache WHERE OS = "linux"}
        )

      // Where we should save the file.
      LET ToolPath <= path_join(components=[binpath[0].Path, ToolFilename])

      // Download the file from the binary URL and store in the local
      // binary cache.
      LET download = SELECT * FROM if(condition=log(message=ToolURL) AND binpath AND ToolHash AND ToolURL,
        then={
          SELECT hash(path=Content) as Hash,
              ToolFilename AS Name,
              "Downloaded" AS DownloadStatus,
              copy(filename=Content, dest=ToolPath) AS FullPath
          FROM http_client(url=ToolURL, tempfile_extension=".exe", remove_last=TRUE)
          WHERE log(message=format(format="hash of %v: %v, expected %v", args=[
                    Content, Hash.SHA256, ToolHash]))
                AND Hash.SHA256 = ToolHash
        }, else={
           SELECT * FROM scope()
           WHERE NOT log(message="No valid setup - is tool " + ToolName +
                        " configured in the server inventory?")
        })

      // Check if the existing file in the binary file cache matches
      // the hash.
      LET existing = SELECT FullPath, hash(path=FullPath) AS Hash, Name,
                    "Cached" AS DownloadStatus
        FROM stat(filename=ToolPath)
        WHERE Hash.SHA256 = ToolHash AND log(
            message=format(format="hash of %v: %v, expected %v", args=[
            FullPath, Hash.SHA256, ToolHash]))

      // Find the required_tool either in the local cache or
      // download it (and put it in the cache for next time). If we
      // have to download the file we sleep for a random time to
      // stagger server bandwidth load.
      SELECT * FROM switch(
        a=existing,
        b={
           SELECT rand(range=atoi(string=SleepDuration)) AS timeout
           FROM scope()
           WHERE log(message=format(format='Sleeping %v Seconds',
                 args=[timeout])) AND sleep(time=timeout) AND FALSE
        },
        c=download)
