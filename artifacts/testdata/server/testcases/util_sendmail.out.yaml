Query: LET _ <= import(artifact="Generic.Utils.SendEmail")
Output: []

# We expect a 1–70-character long string consisting of DIGIT / ALPHA / "'" /
# "(" / ")" / "+" / "_" / "," / "-" / "." / "/" / ":" / "=" / "?", not ending
# in space, as per RFC 1341 7.2.1:
Query: LET rfc_bcharsnospace <= "0-9A-Za-z'()+_,./:=?"
Output: []

Query: LET rfc_bchars <= rfc_bcharsnospace + " "
Output: []

Query: LET rfc_boundary <= "[" + rfc_bchars + "]{0,69}" + "[" + rfc_bcharsnospace + "]"
Output: []

# Generate a few random strings and ensure that they are all according to
# spec.:
Query: SELECT * FROM foreach(row={ SELECT * FROM range(end=10) }, query={
  SELECT RandomString =~ rfc_boundary AS OK
  FROM scope()
}) GROUP BY OK
Output: [
 {
  "OK": true
 }
]

Query: LET D(X) = split(string=X, sep="\r\n")
Output: []

Query: SELECT D(X=WrapText(Value='Foo bar baz', Type='plain')) AS Plain,
       D(X=WrapText(Value='HTML string', Type='html')) AS HTML FROM scope()

Output: [
 {
  "Plain": [
   "Content-Type: text/plain; charset=\"utf-8\"",
   "",
   "Foo bar baz",
   ""
  ],
  "HTML": [
   "Content-Type: text/html; charset=\"utf-8\"",
   "",
   "HTML string",
   ""
  ]
 }
]

Query: LET Plain <= WrapText(Value='This is the plain text', Type='plain')
Output: []

Query: LET HTML <= WrapText(Value='<!DOCTYPE html><html lang="en"><body><h1>Hello</h1></body></html>', Type='html')
Output: []

# In order to get consistent output for test results, mock the random barrier
# string:
Query: LET _ <= SELECT mock(function='rand', results=45) FROM scope()
Output: []

# Re-import to apply mock():
Query: LET _ <= import(artifact="Generic.Utils.SendEmail")
Output: []

# Sanity check – ensure output is not random:
Query: SELECT rand(range=100), RandomString FROM scope()
Output: [
 {
  "rand(range=100)": 45,
  "RandomString": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
 }
]

# Ensure that just plain text and just HTML results in their individual
# unaltered messages, while both results in a multipart/alternative message:
Query: SELECT D(X=WrapAlternative(Plain=Plain, HTML=null)) AS JustPlain FROM scope()
Output: [
 {
  "JustPlain": [
   "Content-Type: text/plain; charset=\"utf-8\"",
   "",
   "This is the plain text",
   ""
  ]
 }
]

Query: SELECT D(X=WrapAlternative(Plain=null, HTML=HTML)) AS JustHTML FROM scope()
Output: [
 {
  "JustHTML": [
   "Content-Type: text/html; charset=\"utf-8\"",
   "",
   "\u003c!DOCTYPE html\u003e\u003chtml lang=\"en\"\u003e\u003cbody\u003e\u003ch1\u003eHello\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e",
   ""
  ]
 }
]

Query: SELECT D(X=WrapAlternative(Plain=Plain, HTML=HTML)) AS Both FROM scope()
Output: [
 {
  "Both": [
   "Content-Type: multipart/alternative; boundary=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
   "",
   "--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
   "Content-Type: text/plain; charset=\"utf-8\"",
   "",
   "This is the plain text",
   "--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
   "Content-Type: text/html; charset=\"utf-8\"",
   "",
   "\u003c!DOCTYPE html\u003e\u003chtml lang=\"en\"\u003e\u003cbody\u003e\u003ch1\u003eHello\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e",
   "--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA--",
   ""
  ]
 }
]

# Create some files:
Query: LET tmp1 <= tempfile()
Output: []

Query: LET _ <= copy(accessor="data", filename="First attachment contents", dest=tmp1)
Output: []

Query: LET tmp2 <= tempfile()
Output: []

Query: LET _ <= copy(accessor="data", filename="Second attachment contents", dest=tmp2)
Output: []

# Create attachment:
Query: SELECT D(X=AttachFile(Path=tmp1, Filename='Attachment 1.txt')) AS file FROM scope()
Output: [
 {
  "file": [
   "Content-Type: application/octet-stream; name=\"Attachment 1\"",
   "Content-Disposition: attachment; filename=\"Attachment 1.txt\"",
   "Content-Transfer-Encoding: base64",
   "",
   "Rmlyc3QgYXR0YWNobWVudCBjb250ZW50cw==",
   "",
   ""
  ]
 }
]

# Create attachments:
Query: SELECT AttachFiles(Files=[
  dict(Path=tmp1, Filename='Attachment 1.txt'),
  dict(Path=tmp2, Filename='Attachment 2.txt')]) AS files FROM scope()

Output: [
 {
  "files": [
   {
    "Part": "Content-Type: application/octet-stream; name=\"Attachment 1\"\r\nContent-Disposition: attachment; filename=\"Attachment 1.txt\"\r\nContent-Transfer-Encoding: base64\r\n\r\nRmlyc3QgYXR0YWNobWVudCBjb250ZW50cw==\r\n\r\n"
   },
   {
    "Part": "Content-Type: application/octet-stream; name=\"Attachment 2\"\r\nContent-Disposition: attachment; filename=\"Attachment 2.txt\"\r\nContent-Transfer-Encoding: base64\r\n\r\nU2Vjb25kIGF0dGFjaG1lbnQgY29udGVudHM=\r\n\r\n"
   }
  ]
 }
]

# Create a boundary for the main multipart in order to distinguish from the
# multipart/alternative:
Query: LET Boundary <= 'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB'
Output: []

# Create multipart with just attachments:
Query: SELECT D(X=WrapInBoundary(Boundary=Boundary, Header="",
    Sections=AttachFiles(Files=[
       dict(Path=tmp1, Filename='Attachment 1.txt'),
       dict(Path=tmp2, Filename='Attachment 2.txt')]).Part)) AS attachments FROM scope()

Output: [
 {
  "attachments": [
   "--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",
   "Content-Type: application/octet-stream; name=\"Attachment 1\"",
   "Content-Disposition: attachment; filename=\"Attachment 1.txt\"",
   "Content-Transfer-Encoding: base64",
   "",
   "Rmlyc3QgYXR0YWNobWVudCBjb250ZW50cw==",
   "",
   "--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",
   "Content-Type: application/octet-stream; name=\"Attachment 2\"",
   "Content-Disposition: attachment; filename=\"Attachment 2.txt\"",
   "Content-Transfer-Encoding: base64",
   "",
   "U2Vjb25kIGF0dGFjaG1lbnQgY29udGVudHM=",
   "",
   "--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB--",
   ""
  ]
 }
]

# Create multipart with plain-text, HTML and attachments:
Query: SELECT D(X=WrapInBoundary(Boundary=Boundary, Header="",
    Sections=(WrapAlternative(Plain=Plain, HTML=HTML),) +
              AttachFiles(Files=[
                dict(Path=tmp1, Filename='Attachment 1.txt'),
                dict(Path=tmp2, Filename='Attachment 2.txt')]).Part)) AS attachments
FROM scope()

Output: [
 {
  "attachments": [
   "--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",
   "Content-Type: multipart/alternative; boundary=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
   "",
   "--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
   "Content-Type: text/plain; charset=\"utf-8\"",
   "",
   "This is the plain text",
   "--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
   "Content-Type: text/html; charset=\"utf-8\"",
   "",
   "\u003c!DOCTYPE html\u003e\u003chtml lang=\"en\"\u003e\u003cbody\u003e\u003ch1\u003eHello\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e",
   "--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA--",
   "--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",
   "Content-Type: application/octet-stream; name=\"Attachment 1\"",
   "Content-Disposition: attachment; filename=\"Attachment 1.txt\"",
   "Content-Transfer-Encoding: base64",
   "",
   "Rmlyc3QgYXR0YWNobWVudCBjb250ZW50cw==",
   "",
   "--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",
   "Content-Type: application/octet-stream; name=\"Attachment 2\"",
   "Content-Disposition: attachment; filename=\"Attachment 2.txt\"",
   "Content-Transfer-Encoding: base64",
   "",
   "U2Vjb25kIGF0dGFjaG1lbnQgY29udGVudHM=",
   "",
   "--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB--",
   ""
  ]
 }
]

# Create multipart with no attachments (empty):
Query: SELECT D(X=WrapInBoundary(Boundary=Boundary, Header="",
    Sections=(WrapAlternative(HTML=HTML),) + AttachFiles(Files=[]))) FROM scope()

Output: [
 {
  "D(X=WrapInBoundary(Boundary=Boundary, Header=\"\", Sections=(WrapAlternative(HTML=HTML), ) + AttachFiles(Files=[])))": [
   "--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",
   "Content-Type: multipart/alternative; boundary=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
   "",
   "--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
   "Content-Type: text/plain; charset=\"utf-8\"",
   "",
   "This is the plain text",
   "--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
   "Content-Type: text/html; charset=\"utf-8\"",
   "",
   "\u003c!DOCTYPE html\u003e\u003chtml lang=\"en\"\u003e\u003cbody\u003e\u003ch1\u003eHello\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e",
   "--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA--",
   "--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB--",
   ""
  ]
 }
]

