Query: LET _ <= import(artifact="Generic.Utils.SendEmail")
Output: []

# We expect a 1–70-character long string consisting of DIGIT / ALPHA / "'" /
# "(" / ")" / "+" / "_" / "," / "-" / "." / "/" / ":" / "=" / "?", not ending
# in space, as per RFC 1341 7.2.1:
Query: LET rfc_bcharsnospace <= "0-9A-Za-z'()+_,./:=?"
Output: []

Query: LET rfc_bchars <= rfc_bcharsnospace + " "
Output: []

Query: LET rfc_boundary <= "[" + rfc_bchars + "]{0,69}" + "[" + rfc_bcharsnospace + "]"
Output: []

# Generate a few random strings and ensure that they are all according to
# spec.:
Query: SELECT * FROM foreach(row={ SELECT * FROM range(end=10) }, query={
  SELECT RandomString =~ rfc_boundary FROM scope() })
Output: [
 {
  "RandomString =~ rfc_boundary": true
 },
 {
  "RandomString =~ rfc_boundary": true
 },
 {
  "RandomString =~ rfc_boundary": true
 },
 {
  "RandomString =~ rfc_boundary": true
 },
 {
  "RandomString =~ rfc_boundary": true
 },
 {
  "RandomString =~ rfc_boundary": true
 },
 {
  "RandomString =~ rfc_boundary": true
 },
 {
  "RandomString =~ rfc_boundary": true
 },
 {
  "RandomString =~ rfc_boundary": true
 },
 {
  "RandomString =~ rfc_boundary": true
 }
]

Query: SELECT WrapText(Value='Foo bar baz', Type='plain') AS Plain, WrapText(Value='HTML string', Type='html') AS HTML FROM scope()
Output: [
 {
  "Plain": "Content-Type: text/plain; charset=\"utf-8\"\r\n\r\nFoo bar baz\r\n",
  "HTML": "Content-Type: text/html; charset=\"utf-8\"\r\n\r\nHTML string\r\n"
 }
]

Query: LET Plain <= WrapText(Value='This is the plain text', Type='plain')
Output: []

Query: LET HTML <= WrapText(Value='<!DOCTYPE html><html lang="en"><body><h1>Hello</h1></body></html>', Type='html')
Output: []

# In order to get consistent output for test results, mock the random barrier
# string:
Query: LET _ <= SELECT mock(function='rand', results=45) FROM scope()
Output: []

# Re-import to apply mock():
Query: LET _ <= import(artifact="Generic.Utils.SendEmail")
Output: []

# Sanity check – ensure output is not random:
Query: SELECT rand(range=100), RandomString FROM scope()
Output: [
 {
  "rand(range=100)": 45,
  "RandomString": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
 }
]

# Ensure that just plain text and just HTML results in their individual
# unaltered messages, while both results in a multipart/alternative message:
Query: SELECT WrapAlternative(Plain=Plain, HTML=null) AS JustPlain FROM scope()
Output: [
 {
  "JustPlain": "Content-Type: text/plain; charset=\"utf-8\"\r\n\r\nThis is the plain text\r\n"
 }
]

Query: SELECT WrapAlternative(Plain=null, HTML=HTML) AS JustHTML FROM scope()
Output: [
 {
  "JustHTML": "Content-Type: text/html; charset=\"utf-8\"\r\n\r\n\u003c!DOCTYPE html\u003e\u003chtml lang=\"en\"\u003e\u003cbody\u003e\u003ch1\u003eHello\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\r\n"
 }
]

Query: SELECT WrapAlternative(Plain=Plain, HTML=HTML) AS Both FROM scope()
Output: [
 {
  "Both": "Content-Type: multipart/alternative; boundary=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\n\r\n--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nContent-Type: text/plain; charset=\"utf-8\"\r\n\r\nThis is the plain text\r\n--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nContent-Type: text/html; charset=\"utf-8\"\r\n\r\n\u003c!DOCTYPE html\u003e\u003chtml lang=\"en\"\u003e\u003cbody\u003e\u003ch1\u003eHello\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\r\n--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA--\r\n"
 }
]

# Create some files:
Query: LET tmp1 <= tempfile()
Output: []

Query: LET _ <= copy(accessor="data", filename="First attachment contents", dest=tmp1)
Output: []

Query: LET tmp2 <= tempfile()
Output: []

Query: LET _ <= copy(accessor="data", filename="Second attachment contents", dest=tmp2)
Output: []

# Create attachment:
Query: SELECT AttachFile(Path=tmp1, Filename='Attachment 1.txt') AS file FROM scope()
Output: [
 {
  "file": "Content-Type: application/octet-stream; name=\"Attachment 1\"\r\nContent-Disposition: attachment; filename=\"Attachment 1.txt\"\r\nContent-Transfer-Encoding: base64\r\n\r\nRmlyc3QgYXR0YWNobWVudCBjb250ZW50cw==\r\n\r\n"
 }
]

# Create attachments:
Query: SELECT AttachFiles(Files=[dict(Path=tmp1, Filename='Attachment 1.txt'), dict(Path=tmp2, Filename='Attachment 2.txt')]) AS files FROM scope()
Output: [
 {
  "files": [
   {
    "Part": "Content-Type: application/octet-stream; name=\"Attachment 1\"\r\nContent-Disposition: attachment; filename=\"Attachment 1.txt\"\r\nContent-Transfer-Encoding: base64\r\n\r\nRmlyc3QgYXR0YWNobWVudCBjb250ZW50cw==\r\n\r\n"
   },
   {
    "Part": "Content-Type: application/octet-stream; name=\"Attachment 2\"\r\nContent-Disposition: attachment; filename=\"Attachment 2.txt\"\r\nContent-Transfer-Encoding: base64\r\n\r\nU2Vjb25kIGF0dGFjaG1lbnQgY29udGVudHM=\r\n\r\n"
   }
  ]
 }
]

# Create a boundary for the main multipart in order to distinguish from the
# multipart/alternative:
Query: LET Boundary <= 'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB'
Output: []

# Create multipart with just attachments:
Query: SELECT WrapInBoundary(Boundary=Boundary, Sections=AttachFiles(Files=[dict(Path=tmp1, Filename='Attachment 1.txt'), dict(Path=tmp2, Filename='Attachment 2.txt')]).Part) AS attachments FROM scope()
Output: [
 {
  "attachments": "--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\r\nContent-Type: application/octet-stream; name=\"Attachment 1\"\r\nContent-Disposition: attachment; filename=\"Attachment 1.txt\"\r\nContent-Transfer-Encoding: base64\r\n\r\nRmlyc3QgYXR0YWNobWVudCBjb250ZW50cw==\r\n\r\n--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\r\nContent-Type: application/octet-stream; name=\"Attachment 2\"\r\nContent-Disposition: attachment; filename=\"Attachment 2.txt\"\r\nContent-Transfer-Encoding: base64\r\n\r\nU2Vjb25kIGF0dGFjaG1lbnQgY29udGVudHM=\r\n\r\n--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB--\r\n"
 }
]

# Create multipart with plain-text, HTML and attachments:
Query: SELECT WrapInBoundary(Boundary=Boundary, Sections=(WrapAlternative(Plain=Plain, HTML=HTML),) + AttachFiles(Files=[dict(Path=tmp1, Filename='Attachment 1.txt'), dict(Path=tmp2, Filename='Attachment 2.txt')]).Part) AS attachments FROM scope()
Output: [
 {
  "attachments": "--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\r\nContent-Type: multipart/alternative; boundary=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\n\r\n--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nContent-Type: text/plain; charset=\"utf-8\"\r\n\r\nThis is the plain text\r\n--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nContent-Type: text/html; charset=\"utf-8\"\r\n\r\n\u003c!DOCTYPE html\u003e\u003chtml lang=\"en\"\u003e\u003cbody\u003e\u003ch1\u003eHello\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\r\n--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA--\r\n--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\r\nContent-Type: application/octet-stream; name=\"Attachment 1\"\r\nContent-Disposition: attachment; filename=\"Attachment 1.txt\"\r\nContent-Transfer-Encoding: base64\r\n\r\nRmlyc3QgYXR0YWNobWVudCBjb250ZW50cw==\r\n\r\n--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\r\nContent-Type: application/octet-stream; name=\"Attachment 2\"\r\nContent-Disposition: attachment; filename=\"Attachment 2.txt\"\r\nContent-Transfer-Encoding: base64\r\n\r\nU2Vjb25kIGF0dGFjaG1lbnQgY29udGVudHM=\r\n\r\n--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB--\r\n"
 }
]

# Create multipart with no attachments (empty):
Query: SELECT WrapInBoundary(Boundary=Boundary, Sections=(WrapAlternative(HTML=HTML),) + AttachFiles(Files=[])) FROM scope()
Output: [
 {
  "WrapInBoundary(Boundary=Boundary, Sections=(WrapAlternative(HTML=HTML), ) + AttachFiles(Files=[]))": "--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\r\nContent-Type: multipart/alternative; boundary=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\n\r\n--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nContent-Type: text/plain; charset=\"utf-8\"\r\n\r\nThis is the plain text\r\n--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\r\nContent-Type: text/html; charset=\"utf-8\"\r\n\r\n\u003c!DOCTYPE html\u003e\u003chtml lang=\"en\"\u003e\u003cbody\u003e\u003ch1\u003eHello\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e\r\n--AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA--\r\n--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\r\n[]--BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB--\r\n"
 }
]

