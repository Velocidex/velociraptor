// These are the messages used in Velociraptor's encrypted
// communication protocol.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: jobs.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
	proto "www.velocidex.com/golang/velociraptor/actions/proto"
	_ "www.velocidex.com/golang/velociraptor/proto"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type FlowRequest_Compression int32

const (
	FlowRequest_NONE FlowRequest_Compression = 0
	FlowRequest_ZLIB FlowRequest_Compression = 1
)

// Enum value maps for FlowRequest_Compression.
var (
	FlowRequest_Compression_name = map[int32]string{
		0: "NONE",
		1: "ZLIB",
	}
	FlowRequest_Compression_value = map[string]int32{
		"NONE": 0,
		"ZLIB": 1,
	}
)

func (x FlowRequest_Compression) Enum() *FlowRequest_Compression {
	p := new(FlowRequest_Compression)
	*p = x
	return p
}

func (x FlowRequest_Compression) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FlowRequest_Compression) Descriptor() protoreflect.EnumDescriptor {
	return file_jobs_proto_enumTypes[0].Descriptor()
}

func (FlowRequest_Compression) Type() protoreflect.EnumType {
	return &file_jobs_proto_enumTypes[0]
}

func (x FlowRequest_Compression) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FlowRequest_Compression.Descriptor instead.
func (FlowRequest_Compression) EnumDescriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{0, 0}
}

// This is done because signing is done on a group of messages as
// they arrive over the POST transaction, but after decryption and
// unpacking, messages are processed individually and therefore need
// to retain their authenticated status.
type VeloMessage_AuthorizationState int32

const (
	VeloMessage_UNAUTHENTICATED VeloMessage_AuthorizationState = 0
	VeloMessage_AUTHENTICATED   VeloMessage_AuthorizationState = 1
)

// Enum value maps for VeloMessage_AuthorizationState.
var (
	VeloMessage_AuthorizationState_name = map[int32]string{
		0: "UNAUTHENTICATED",
		1: "AUTHENTICATED",
	}
	VeloMessage_AuthorizationState_value = map[string]int32{
		"UNAUTHENTICATED": 0,
		"AUTHENTICATED":   1,
	}
)

func (x VeloMessage_AuthorizationState) Enum() *VeloMessage_AuthorizationState {
	p := new(VeloMessage_AuthorizationState)
	*p = x
	return p
}

func (x VeloMessage_AuthorizationState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VeloMessage_AuthorizationState) Descriptor() protoreflect.EnumDescriptor {
	return file_jobs_proto_enumTypes[1].Descriptor()
}

func (VeloMessage_AuthorizationState) Type() protoreflect.EnumType {
	return &file_jobs_proto_enumTypes[1]
}

func (x VeloMessage_AuthorizationState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VeloMessage_AuthorizationState.Descriptor instead.
func (VeloMessage_AuthorizationState) EnumDescriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{1, 0}
}

// DEPRECATED: Status messages just carry the VeloStatus member.
type VeloMessage_Type int32

const (
	VeloMessage_MESSAGE VeloMessage_Type = 0 // The main kind of message.
	VeloMessage_STATUS  VeloMessage_Type = 1 //
)

// Enum value maps for VeloMessage_Type.
var (
	VeloMessage_Type_name = map[int32]string{
		0: "MESSAGE",
		1: "STATUS",
	}
	VeloMessage_Type_value = map[string]int32{
		"MESSAGE": 0,
		"STATUS":  1,
	}
)

func (x VeloMessage_Type) Enum() *VeloMessage_Type {
	p := new(VeloMessage_Type)
	*p = x
	return p
}

func (x VeloMessage_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VeloMessage_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_jobs_proto_enumTypes[2].Descriptor()
}

func (VeloMessage_Type) Type() protoreflect.EnumType {
	return &file_jobs_proto_enumTypes[2]
}

func (x VeloMessage_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VeloMessage_Type.Descriptor instead.
func (VeloMessage_Type) EnumDescriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{1, 1}
}

type Certificate_Type int32

const (
	Certificate_CSR Certificate_Type = 0
	Certificate_CRT Certificate_Type = 1
	Certificate_CA  Certificate_Type = 2
)

// Enum value maps for Certificate_Type.
var (
	Certificate_Type_name = map[int32]string{
		0: "CSR",
		1: "CRT",
		2: "CA",
	}
	Certificate_Type_value = map[string]int32{
		"CSR": 0,
		"CRT": 1,
		"CA":  2,
	}
)

func (x Certificate_Type) Enum() *Certificate_Type {
	p := new(Certificate_Type)
	*p = x
	return p
}

func (x Certificate_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Certificate_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_jobs_proto_enumTypes[3].Descriptor()
}

func (Certificate_Type) Type() protoreflect.EnumType {
	return &file_jobs_proto_enumTypes[3]
}

func (x Certificate_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Certificate_Type.Descriptor instead.
func (Certificate_Type) EnumDescriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{3, 0}
}

// Velociraptor only uses OK and GENERIC_ERROR right now.
type VeloStatus_ReturnedStatus int32

const (
	// Query completed successfully
	VeloStatus_OK VeloStatus_ReturnedStatus = 0
	// A progress report of the query but does not mean it is
	// completed.
	VeloStatus_PROGRESS      VeloStatus_ReturnedStatus = 4
	VeloStatus_GENERIC_ERROR VeloStatus_ReturnedStatus = 10
	VeloStatus_UNKNOWN_FLOW  VeloStatus_ReturnedStatus = 11
)

// Enum value maps for VeloStatus_ReturnedStatus.
var (
	VeloStatus_ReturnedStatus_name = map[int32]string{
		0:  "OK",
		4:  "PROGRESS",
		10: "GENERIC_ERROR",
		11: "UNKNOWN_FLOW",
	}
	VeloStatus_ReturnedStatus_value = map[string]int32{
		"OK":            0,
		"PROGRESS":      4,
		"GENERIC_ERROR": 10,
		"UNKNOWN_FLOW":  11,
	}
)

func (x VeloStatus_ReturnedStatus) Enum() *VeloStatus_ReturnedStatus {
	p := new(VeloStatus_ReturnedStatus)
	*p = x
	return p
}

func (x VeloStatus_ReturnedStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (VeloStatus_ReturnedStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_jobs_proto_enumTypes[4].Descriptor()
}

func (VeloStatus_ReturnedStatus) Type() protoreflect.EnumType {
	return &file_jobs_proto_enumTypes[4]
}

func (x VeloStatus_ReturnedStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use VeloStatus_ReturnedStatus.Descriptor instead.
func (VeloStatus_ReturnedStatus) EnumDescriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{7, 0}
}

// Currently Velociraptor always compresses all message lists.
type PackedMessageList_CompressionType int32

const (
	PackedMessageList_UNCOMPRESSED PackedMessageList_CompressionType = 0
	// Compressed using the zlib.compress() function.
	PackedMessageList_ZCOMPRESSION PackedMessageList_CompressionType = 1
)

// Enum value maps for PackedMessageList_CompressionType.
var (
	PackedMessageList_CompressionType_name = map[int32]string{
		0: "UNCOMPRESSED",
		1: "ZCOMPRESSION",
	}
	PackedMessageList_CompressionType_value = map[string]int32{
		"UNCOMPRESSED": 0,
		"ZCOMPRESSION": 1,
	}
)

func (x PackedMessageList_CompressionType) Enum() *PackedMessageList_CompressionType {
	p := new(PackedMessageList_CompressionType)
	*p = x
	return p
}

func (x PackedMessageList_CompressionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PackedMessageList_CompressionType) Descriptor() protoreflect.EnumDescriptor {
	return file_jobs_proto_enumTypes[5].Descriptor()
}

func (PackedMessageList_CompressionType) Type() protoreflect.EnumType {
	return &file_jobs_proto_enumTypes[5]
}

func (x PackedMessageList_CompressionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PackedMessageList_CompressionType.Descriptor instead.
func (PackedMessageList_CompressionType) EnumDescriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{9, 0}
}

type CipherProperties_HMACType int32

const (
	// DEPRECATED: Older clients use a HMAC only on the encrypted message.
	CipherProperties_SIMPLE_HMAC CipherProperties_HMACType = 0
	// Newer clients also include the encrypted cipher and API version in the
	// hmac.
	CipherProperties_FULL_HMAC CipherProperties_HMACType = 1
)

// Enum value maps for CipherProperties_HMACType.
var (
	CipherProperties_HMACType_name = map[int32]string{
		0: "SIMPLE_HMAC",
		1: "FULL_HMAC",
	}
	CipherProperties_HMACType_value = map[string]int32{
		"SIMPLE_HMAC": 0,
		"FULL_HMAC":   1,
	}
)

func (x CipherProperties_HMACType) Enum() *CipherProperties_HMACType {
	p := new(CipherProperties_HMACType)
	*p = x
	return p
}

func (x CipherProperties_HMACType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CipherProperties_HMACType) Descriptor() protoreflect.EnumDescriptor {
	return file_jobs_proto_enumTypes[6].Descriptor()
}

func (CipherProperties_HMACType) Type() protoreflect.EnumType {
	return &file_jobs_proto_enumTypes[6]
}

func (x CipherProperties_HMACType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CipherProperties_HMACType.Descriptor instead.
func (CipherProperties_HMACType) EnumDescriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{10, 0}
}

// This status code applies for the entire communication.
type ClientCommunication_Status int32

const (
	ClientCommunication_UNSET        ClientCommunication_Status = 0
	ClientCommunication_OK           ClientCommunication_Status = 200
	ClientCommunication_BAD_REQUEST  ClientCommunication_Status = 400
	ClientCommunication_CIPHER_ERROR ClientCommunication_Status = 406
)

// Enum value maps for ClientCommunication_Status.
var (
	ClientCommunication_Status_name = map[int32]string{
		0:   "UNSET",
		200: "OK",
		400: "BAD_REQUEST",
		406: "CIPHER_ERROR",
	}
	ClientCommunication_Status_value = map[string]int32{
		"UNSET":        0,
		"OK":           200,
		"BAD_REQUEST":  400,
		"CIPHER_ERROR": 406,
	}
)

func (x ClientCommunication_Status) Enum() *ClientCommunication_Status {
	p := new(ClientCommunication_Status)
	*p = x
	return p
}

func (x ClientCommunication_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClientCommunication_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_jobs_proto_enumTypes[7].Descriptor()
}

func (ClientCommunication_Status) Type() protoreflect.EnumType {
	return &file_jobs_proto_enumTypes[7]
}

func (x ClientCommunication_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ClientCommunication_Status.Descriptor instead.
func (ClientCommunication_Status) EnumDescriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{12, 0}
}

type ResumeTransactions_Compression int32

const (
	ResumeTransactions_NONE ResumeTransactions_Compression = 0
	ResumeTransactions_ZLIB ResumeTransactions_Compression = 1
)

// Enum value maps for ResumeTransactions_Compression.
var (
	ResumeTransactions_Compression_name = map[int32]string{
		0: "NONE",
		1: "ZLIB",
	}
	ResumeTransactions_Compression_value = map[string]int32{
		"NONE": 0,
		"ZLIB": 1,
	}
)

func (x ResumeTransactions_Compression) Enum() *ResumeTransactions_Compression {
	p := new(ResumeTransactions_Compression)
	*p = x
	return p
}

func (x ResumeTransactions_Compression) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ResumeTransactions_Compression) Descriptor() protoreflect.EnumDescriptor {
	return file_jobs_proto_enumTypes[8].Descriptor()
}

func (ResumeTransactions_Compression) Type() protoreflect.EnumType {
	return &file_jobs_proto_enumTypes[8]
}

func (x ResumeTransactions_Compression) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ResumeTransactions_Compression.Descriptor instead.
func (ResumeTransactions_Compression) EnumDescriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{15, 0}
}

// Represents a complete collection.
type FlowRequest struct {
	state            protoimpl.MessageState    `protogen:"open.v1"`
	VQLClientActions []*proto.VQLCollectorArgs `protobuf:"bytes,1,rep,name=VQLClientActions,proto3" json:"VQLClientActions,omitempty"`
	// The maximum time in milliseconds the client will batch log
	// messages before forwarding them to the server. If this is 0, no
	// updates will be sent until he very end of the query. You can
	// specify the default in
	// Frontend.resources.default_log_batch_time
	LogBatchTime uint64 `protobuf:"varint,2,opt,name=log_batch_time,json=logBatchTime,proto3" json:"log_batch_time,omitempty"`
	// The maximum time in milliseconds the client will wait before
	// sending progress updates on the running flows. This is useful
	// to monitor how the client is progress but if it done too often
	// increases load on the server. Default is 5000 (5sec) and you
	// can updatet the default in
	// Client.default_server_flow_stats_update
	FlowUpdateTime uint64 `protobuf:"varint,3,opt,name=flow_update_time,json=flowUpdateTime,proto3" json:"flow_update_time,omitempty"`
	// A limit on total number of rows returned from the
	// collection. Does not count log messages.
	MaxRows uint64 `protobuf:"varint,4,opt,name=max_rows,json=maxRows,proto3" json:"max_rows,omitempty"`
	// A limit on the total number of log messages allowed from the
	// flow - exceeding this will suppress further logging.
	MaxLogs uint64 `protobuf:"varint,7,opt,name=max_logs,json=maxLogs,proto3" json:"max_logs,omitempty"`
	// If the client exceeds this, the client will abort the
	// collection.
	MaxUploadBytes uint64 `protobuf:"varint,5,opt,name=max_upload_bytes,json=maxUploadBytes,proto3" json:"max_upload_bytes,omitempty"`
	// Execute this trace query while the main collection is running.
	Trace []*proto.VQLCollectorArgs `protobuf:"bytes,6,rep,name=trace,proto3" json:"trace,omitempty"`
	// If specified we use this regex to detect errors in log
	// messages. This regex will determine if the flow should be
	// flagged with an error depending on the log message.
	LogErrorRegex string                  `protobuf:"bytes,8,opt,name=log_error_regex,json=logErrorRegex,proto3" json:"log_error_regex,omitempty"`
	Compression   FlowRequest_Compression `protobuf:"varint,9,opt,name=compression,proto3,enum=proto.FlowRequest_Compression" json:"compression,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowRequest) Reset() {
	*x = FlowRequest{}
	mi := &file_jobs_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowRequest) ProtoMessage() {}

func (x *FlowRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowRequest.ProtoReflect.Descriptor instead.
func (*FlowRequest) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{0}
}

func (x *FlowRequest) GetVQLClientActions() []*proto.VQLCollectorArgs {
	if x != nil {
		return x.VQLClientActions
	}
	return nil
}

func (x *FlowRequest) GetLogBatchTime() uint64 {
	if x != nil {
		return x.LogBatchTime
	}
	return 0
}

func (x *FlowRequest) GetFlowUpdateTime() uint64 {
	if x != nil {
		return x.FlowUpdateTime
	}
	return 0
}

func (x *FlowRequest) GetMaxRows() uint64 {
	if x != nil {
		return x.MaxRows
	}
	return 0
}

func (x *FlowRequest) GetMaxLogs() uint64 {
	if x != nil {
		return x.MaxLogs
	}
	return 0
}

func (x *FlowRequest) GetMaxUploadBytes() uint64 {
	if x != nil {
		return x.MaxUploadBytes
	}
	return 0
}

func (x *FlowRequest) GetTrace() []*proto.VQLCollectorArgs {
	if x != nil {
		return x.Trace
	}
	return nil
}

func (x *FlowRequest) GetLogErrorRegex() string {
	if x != nil {
		return x.LogErrorRegex
	}
	return ""
}

func (x *FlowRequest) GetCompression() FlowRequest_Compression {
	if x != nil {
		return x.Compression
	}
	return FlowRequest_NONE
}

// This message is sent between the client and the server.
type VeloMessage struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	SessionId string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// An incrementing query id in this session.
	QueryId   uint64 `protobuf:"varint,37,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
	RequestId uint64 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// If this is set then the message is urgent - it will not be
	// queued needlessly.
	Urgent bool `protobuf:"varint,36,opt,name=urgent,proto3" json:"urgent,omitempty"`
	// DEPRECATED: not used any more.
	ResponseId uint64 `protobuf:"varint,3,opt,name=response_id,json=responseId,proto3" json:"response_id,omitempty"`
	// The source of this message. Note that clients may group together
	// many messages from the same source. The authenticity of the
	// source is cryptographically determined by the CipherMetadata but
	// the source is also copied down to each message by the server
	// after verification. This means that we ignore what the client
	// actually stores in this field and override it from the
	// CipherMetadata.Source field.
	Source string `protobuf:"bytes,6,opt,name=source,proto3" json:"source,omitempty"`
	// The Org this client belongs to - set by the frontend from
	// information gathered by the encryption envelope
	OrgId     string                         `protobuf:"bytes,40,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty"`
	AuthState VeloMessage_AuthorizationState `protobuf:"varint,7,opt,name=auth_state,json=authState,proto3,enum=proto.VeloMessage_AuthorizationState" json:"auth_state,omitempty"`
	// The id of this message in the scheduler. Based on the
	// timestamp. If this is 0 then the task is not scheduled.
	TaskId uint64 `protobuf:"varint,15,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// Generally only one of the following will be set.
	// Client to server:
	FlowStats         *FlowStats               `protobuf:"bytes,41,opt,name=flow_stats,json=flowStats,proto3" json:"flow_stats,omitempty"`
	Status            *VeloStatus              `protobuf:"bytes,25,opt,name=status,proto3" json:"status,omitempty"`
	ForemanCheckin    *proto.ForemanCheckin    `protobuf:"bytes,27,opt,name=ForemanCheckin,proto3" json:"ForemanCheckin,omitempty"` // Upon initial connection.
	FileBuffer        *proto.FileBuffer        `protobuf:"bytes,28,opt,name=FileBuffer,proto3" json:"FileBuffer,omitempty"`         // For uploads.
	UploadTransaction *proto.UploadTransaction `protobuf:"bytes,44,opt,name=UploadTransaction,proto3" json:"UploadTransaction,omitempty"`
	CSR               *Certificate             `protobuf:"bytes,29,opt,name=CSR,proto3" json:"CSR,omitempty"` // For enrollment.
	VQLResponse       *proto.VQLResponse       `protobuf:"bytes,33,opt,name=VQLResponse,proto3" json:"VQLResponse,omitempty"`
	LogMessage        *LogMessage              `protobuf:"bytes,34,opt,name=LogMessage,proto3" json:"LogMessage,omitempty"`
	Ping              *Cancel                  `protobuf:"bytes,39,opt,name=Ping,proto3" json:"Ping,omitempty"`
	// Server to client:
	UpdateEventTable *proto.VQLEventTable `protobuf:"bytes,31,opt,name=UpdateEventTable,proto3" json:"UpdateEventTable,omitempty"`
	// DEPRECATED but used to talk with older clients. New clients will
	// ignore this message and read the FlowRequest message instead.
	VQLClientAction *proto.VQLCollectorArgs `protobuf:"bytes,30,opt,name=VQLClientAction,proto3" json:"VQLClientAction,omitempty"`
	// Requests a flow to be collected - contains all the queries that
	// make up the collection.
	FlowRequest *FlowRequest `protobuf:"bytes,42,opt,name=FlowRequest,proto3" json:"FlowRequest,omitempty"`
	// Instructs the client to resume transactions
	ResumeTransactions *ResumeTransactions `protobuf:"bytes,45,opt,name=ResumeTransactions,proto3" json:"ResumeTransactions,omitempty"`
	// Check up on in progress flows. Causes the client to return a set
	// of FlowStats for inflight flows.
	FlowStatsRequest *FlowStatsRequest     `protobuf:"bytes,43,opt,name=flow_stats_request,json=flowStatsRequest,proto3" json:"flow_stats_request,omitempty"`
	Cancel           *Cancel               `protobuf:"bytes,32,opt,name=Cancel,proto3" json:"Cancel,omitempty"`
	UpdateForeman    *proto.ForemanCheckin `protobuf:"bytes,35,opt,name=UpdateForeman,proto3" json:"UpdateForeman,omitempty"`
	// Immediately kill the client and reset all buffers.
	KillKillKill *Cancel `protobuf:"bytes,38,opt,name=KillKillKill,proto3" json:"KillKillKill,omitempty"`
	// DEPRECATED: The following fields were used as part of the old
	// VeloMessage communication protocol. These fields were replaced
	// by the messages above.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// DEPRECATED: This field contains an encoded rdfvalue. The type of
	// this value is in args_rdf_name.
	Args []byte `protobuf:"bytes,5,opt,name=args,proto3" json:"args,omitempty"`
	// DEPRECATED:
	// The rdfvalue class of the args.
	ArgsRdfName string `protobuf:"bytes,14,opt,name=args_rdf_name,json=argsRdfName,proto3" json:"args_rdf_name,omitempty"`
	// DEPRECATED:
	// The final response to a request carries this type which indicates it is a
	// status message.
	Type          VeloMessage_Type `protobuf:"varint,8,opt,name=type,proto3,enum=proto.VeloMessage_Type" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VeloMessage) Reset() {
	*x = VeloMessage{}
	mi := &file_jobs_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VeloMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VeloMessage) ProtoMessage() {}

func (x *VeloMessage) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VeloMessage.ProtoReflect.Descriptor instead.
func (*VeloMessage) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{1}
}

func (x *VeloMessage) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *VeloMessage) GetQueryId() uint64 {
	if x != nil {
		return x.QueryId
	}
	return 0
}

func (x *VeloMessage) GetRequestId() uint64 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *VeloMessage) GetUrgent() bool {
	if x != nil {
		return x.Urgent
	}
	return false
}

func (x *VeloMessage) GetResponseId() uint64 {
	if x != nil {
		return x.ResponseId
	}
	return 0
}

func (x *VeloMessage) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *VeloMessage) GetOrgId() string {
	if x != nil {
		return x.OrgId
	}
	return ""
}

func (x *VeloMessage) GetAuthState() VeloMessage_AuthorizationState {
	if x != nil {
		return x.AuthState
	}
	return VeloMessage_UNAUTHENTICATED
}

func (x *VeloMessage) GetTaskId() uint64 {
	if x != nil {
		return x.TaskId
	}
	return 0
}

func (x *VeloMessage) GetFlowStats() *FlowStats {
	if x != nil {
		return x.FlowStats
	}
	return nil
}

func (x *VeloMessage) GetStatus() *VeloStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *VeloMessage) GetForemanCheckin() *proto.ForemanCheckin {
	if x != nil {
		return x.ForemanCheckin
	}
	return nil
}

func (x *VeloMessage) GetFileBuffer() *proto.FileBuffer {
	if x != nil {
		return x.FileBuffer
	}
	return nil
}

func (x *VeloMessage) GetUploadTransaction() *proto.UploadTransaction {
	if x != nil {
		return x.UploadTransaction
	}
	return nil
}

func (x *VeloMessage) GetCSR() *Certificate {
	if x != nil {
		return x.CSR
	}
	return nil
}

func (x *VeloMessage) GetVQLResponse() *proto.VQLResponse {
	if x != nil {
		return x.VQLResponse
	}
	return nil
}

func (x *VeloMessage) GetLogMessage() *LogMessage {
	if x != nil {
		return x.LogMessage
	}
	return nil
}

func (x *VeloMessage) GetPing() *Cancel {
	if x != nil {
		return x.Ping
	}
	return nil
}

func (x *VeloMessage) GetUpdateEventTable() *proto.VQLEventTable {
	if x != nil {
		return x.UpdateEventTable
	}
	return nil
}

func (x *VeloMessage) GetVQLClientAction() *proto.VQLCollectorArgs {
	if x != nil {
		return x.VQLClientAction
	}
	return nil
}

func (x *VeloMessage) GetFlowRequest() *FlowRequest {
	if x != nil {
		return x.FlowRequest
	}
	return nil
}

func (x *VeloMessage) GetResumeTransactions() *ResumeTransactions {
	if x != nil {
		return x.ResumeTransactions
	}
	return nil
}

func (x *VeloMessage) GetFlowStatsRequest() *FlowStatsRequest {
	if x != nil {
		return x.FlowStatsRequest
	}
	return nil
}

func (x *VeloMessage) GetCancel() *Cancel {
	if x != nil {
		return x.Cancel
	}
	return nil
}

func (x *VeloMessage) GetUpdateForeman() *proto.ForemanCheckin {
	if x != nil {
		return x.UpdateForeman
	}
	return nil
}

func (x *VeloMessage) GetKillKillKill() *Cancel {
	if x != nil {
		return x.KillKillKill
	}
	return nil
}

func (x *VeloMessage) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VeloMessage) GetArgs() []byte {
	if x != nil {
		return x.Args
	}
	return nil
}

func (x *VeloMessage) GetArgsRdfName() string {
	if x != nil {
		return x.ArgsRdfName
	}
	return ""
}

func (x *VeloMessage) GetType() VeloMessage_Type {
	if x != nil {
		return x.Type
	}
	return VeloMessage_MESSAGE
}

type Cancel struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Principal     string                 `protobuf:"bytes,1,opt,name=principal,proto3" json:"principal,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cancel) Reset() {
	*x = Cancel{}
	mi := &file_jobs_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cancel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cancel) ProtoMessage() {}

func (x *Cancel) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cancel.ProtoReflect.Descriptor instead.
func (*Cancel) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{2}
}

func (x *Cancel) GetPrincipal() string {
	if x != nil {
		return x.Principal
	}
	return ""
}

// Certificates are exchanged with this.
type Certificate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          Certificate_Type       `protobuf:"varint,1,opt,name=type,proto3,enum=proto.Certificate_Type" json:"type,omitempty"`
	Pem           []byte                 `protobuf:"bytes,2,opt,name=pem,proto3" json:"pem,omitempty"`
	Cn            string                 `protobuf:"bytes,3,opt,name=cn,proto3" json:"cn,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Certificate) Reset() {
	*x = Certificate{}
	mi := &file_jobs_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Certificate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Certificate) ProtoMessage() {}

func (x *Certificate) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Certificate.ProtoReflect.Descriptor instead.
func (*Certificate) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{3}
}

func (x *Certificate) GetType() Certificate_Type {
	if x != nil {
		return x.Type
	}
	return Certificate_CSR
}

func (x *Certificate) GetPem() []byte {
	if x != nil {
		return x.Pem
	}
	return nil
}

func (x *Certificate) GetCn() string {
	if x != nil {
		return x.Cn
	}
	return ""
}

// A periodic message sent from the client to the server to update the
// server about the flow progress.
type FlowStats struct {
	state                      protoimpl.MessageState `protogen:"open.v1"`
	TotalUploadedFiles         uint64                 `protobuf:"varint,1,opt,name=total_uploaded_files,json=totalUploadedFiles,proto3" json:"total_uploaded_files,omitempty"`
	TotalExpectedUploadedBytes uint64                 `protobuf:"varint,2,opt,name=total_expected_uploaded_bytes,json=totalExpectedUploadedBytes,proto3" json:"total_expected_uploaded_bytes,omitempty"`
	TotalUploadedBytes         uint64                 `protobuf:"varint,3,opt,name=total_uploaded_bytes,json=totalUploadedBytes,proto3" json:"total_uploaded_bytes,omitempty"`
	TotalCollectedRows         uint64                 `protobuf:"varint,4,opt,name=total_collected_rows,json=totalCollectedRows,proto3" json:"total_collected_rows,omitempty"`
	TotalLogs                  uint64                 `protobuf:"varint,5,opt,name=total_logs,json=totalLogs,proto3" json:"total_logs,omitempty"`
	TransactionsOutstanding    uint64                 `protobuf:"varint,10,opt,name=transactions_outstanding,json=transactionsOutstanding,proto3" json:"transactions_outstanding,omitempty"`
	Timestamp                  uint64                 `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	NamesWithResponse          []string               `protobuf:"bytes,9,rep,name=names_with_response,json=namesWithResponse,proto3" json:"names_with_response,omitempty"`
	QueryStatus                []*VeloStatus          `protobuf:"bytes,7,rep,name=query_status,json=queryStatus,proto3" json:"query_status,omitempty"`
	// When this is true, the flow is considered complete. It is
	// guaranteed to only fire once.
	FlowComplete  bool `protobuf:"varint,8,opt,name=flow_complete,json=flowComplete,proto3" json:"flow_complete,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowStats) Reset() {
	*x = FlowStats{}
	mi := &file_jobs_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowStats) ProtoMessage() {}

func (x *FlowStats) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowStats.ProtoReflect.Descriptor instead.
func (*FlowStats) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{4}
}

func (x *FlowStats) GetTotalUploadedFiles() uint64 {
	if x != nil {
		return x.TotalUploadedFiles
	}
	return 0
}

func (x *FlowStats) GetTotalExpectedUploadedBytes() uint64 {
	if x != nil {
		return x.TotalExpectedUploadedBytes
	}
	return 0
}

func (x *FlowStats) GetTotalUploadedBytes() uint64 {
	if x != nil {
		return x.TotalUploadedBytes
	}
	return 0
}

func (x *FlowStats) GetTotalCollectedRows() uint64 {
	if x != nil {
		return x.TotalCollectedRows
	}
	return 0
}

func (x *FlowStats) GetTotalLogs() uint64 {
	if x != nil {
		return x.TotalLogs
	}
	return 0
}

func (x *FlowStats) GetTransactionsOutstanding() uint64 {
	if x != nil {
		return x.TransactionsOutstanding
	}
	return 0
}

func (x *FlowStats) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *FlowStats) GetNamesWithResponse() []string {
	if x != nil {
		return x.NamesWithResponse
	}
	return nil
}

func (x *FlowStats) GetQueryStatus() []*VeloStatus {
	if x != nil {
		return x.QueryStatus
	}
	return nil
}

func (x *FlowStats) GetFlowComplete() bool {
	if x != nil {
		return x.FlowComplete
	}
	return false
}

// Sent from the server to the client to check up on in flight flows.
type FlowStatsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FlowId        []string               `protobuf:"bytes,1,rep,name=flow_id,json=flowId,proto3" json:"flow_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowStatsRequest) Reset() {
	*x = FlowStatsRequest{}
	mi := &file_jobs_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowStatsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowStatsRequest) ProtoMessage() {}

func (x *FlowStatsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowStatsRequest.ProtoReflect.Descriptor instead.
func (*FlowStatsRequest) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{5}
}

func (x *FlowStatsRequest) GetFlowId() []string {
	if x != nil {
		return x.FlowId
	}
	return nil
}

type FlowStatsSummaryItem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FlowId        string                 `protobuf:"bytes,1,opt,name=flow_id,json=flowId,proto3" json:"flow_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowStatsSummaryItem) Reset() {
	*x = FlowStatsSummaryItem{}
	mi := &file_jobs_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowStatsSummaryItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowStatsSummaryItem) ProtoMessage() {}

func (x *FlowStatsSummaryItem) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowStatsSummaryItem.ProtoReflect.Descriptor instead.
func (*FlowStatsSummaryItem) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{6}
}

func (x *FlowStatsSummaryItem) GetFlowId() string {
	if x != nil {
		return x.FlowId
	}
	return ""
}

// This is a status response that is sent for each complete
// query. Velociraptor collections consist of multiple queries (for
// example collecting multiple artifacts or artifacts with multiple
// sources). Each query request ellicits a status message when
// finished to indicate the query's success status and send stats
// about it.
type VeloStatus struct {
	state        protoimpl.MessageState    `protogen:"open.v1"`
	Status       VeloStatus_ReturnedStatus `protobuf:"varint,1,opt,name=status,proto3,enum=proto.VeloStatus_ReturnedStatus" json:"status,omitempty"`
	ErrorMessage string                    `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	Backtrace    string                    `protobuf:"bytes,3,opt,name=backtrace,proto3" json:"backtrace,omitempty"`
	// Total duration the query took to run on the client.
	Duration    int64  `protobuf:"varint,4,opt,name=duration,proto3" json:"duration,omitempty"`
	LastActive  uint64 `protobuf:"varint,14,opt,name=last_active,json=lastActive,proto3" json:"last_active,omitempty"`
	FirstActive uint64 `protobuf:"varint,15,opt,name=first_active,json=firstActive,proto3" json:"first_active,omitempty"`
	// A List of artifacts that had some results.
	NamesWithResponse []string `protobuf:"bytes,5,rep,name=names_with_response,json=namesWithResponse,proto3" json:"names_with_response,omitempty"`
	// The artifact that this status refers to
	Artifact string `protobuf:"bytes,10,opt,name=Artifact,proto3" json:"Artifact,omitempty"`
	// How many log rows we generated
	LogRows int64 `protobuf:"varint,6,opt,name=log_rows,json=logRows,proto3" json:"log_rows,omitempty"`
	// How many files were uploaded in this query.
	UploadedFiles         int64 `protobuf:"varint,11,opt,name=uploaded_files,json=uploadedFiles,proto3" json:"uploaded_files,omitempty"`
	UploadedBytes         int64 `protobuf:"varint,12,opt,name=uploaded_bytes,json=uploadedBytes,proto3" json:"uploaded_bytes,omitempty"`
	ExpectedUploadedBytes int64 `protobuf:"varint,13,opt,name=expected_uploaded_bytes,json=expectedUploadedBytes,proto3" json:"expected_uploaded_bytes,omitempty"`
	ResultRows            int64 `protobuf:"varint,7,opt,name=result_rows,json=resultRows,proto3" json:"result_rows,omitempty"`
	// This status corresponds to this query number out of the total
	// in this collection.
	QueryId                 int64  `protobuf:"varint,8,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
	TotalQueries            int64  `protobuf:"varint,9,opt,name=total_queries,json=totalQueries,proto3" json:"total_queries,omitempty"`
	TransactionsOutstanding uint64 `protobuf:"varint,16,opt,name=transactions_outstanding,json=transactionsOutstanding,proto3" json:"transactions_outstanding,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *VeloStatus) Reset() {
	*x = VeloStatus{}
	mi := &file_jobs_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VeloStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VeloStatus) ProtoMessage() {}

func (x *VeloStatus) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VeloStatus.ProtoReflect.Descriptor instead.
func (*VeloStatus) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{7}
}

func (x *VeloStatus) GetStatus() VeloStatus_ReturnedStatus {
	if x != nil {
		return x.Status
	}
	return VeloStatus_OK
}

func (x *VeloStatus) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *VeloStatus) GetBacktrace() string {
	if x != nil {
		return x.Backtrace
	}
	return ""
}

func (x *VeloStatus) GetDuration() int64 {
	if x != nil {
		return x.Duration
	}
	return 0
}

func (x *VeloStatus) GetLastActive() uint64 {
	if x != nil {
		return x.LastActive
	}
	return 0
}

func (x *VeloStatus) GetFirstActive() uint64 {
	if x != nil {
		return x.FirstActive
	}
	return 0
}

func (x *VeloStatus) GetNamesWithResponse() []string {
	if x != nil {
		return x.NamesWithResponse
	}
	return nil
}

func (x *VeloStatus) GetArtifact() string {
	if x != nil {
		return x.Artifact
	}
	return ""
}

func (x *VeloStatus) GetLogRows() int64 {
	if x != nil {
		return x.LogRows
	}
	return 0
}

func (x *VeloStatus) GetUploadedFiles() int64 {
	if x != nil {
		return x.UploadedFiles
	}
	return 0
}

func (x *VeloStatus) GetUploadedBytes() int64 {
	if x != nil {
		return x.UploadedBytes
	}
	return 0
}

func (x *VeloStatus) GetExpectedUploadedBytes() int64 {
	if x != nil {
		return x.ExpectedUploadedBytes
	}
	return 0
}

func (x *VeloStatus) GetResultRows() int64 {
	if x != nil {
		return x.ResultRows
	}
	return 0
}

func (x *VeloStatus) GetQueryId() int64 {
	if x != nil {
		return x.QueryId
	}
	return 0
}

func (x *VeloStatus) GetTotalQueries() int64 {
	if x != nil {
		return x.TotalQueries
	}
	return 0
}

func (x *VeloStatus) GetTransactionsOutstanding() uint64 {
	if x != nil {
		return x.TransactionsOutstanding
	}
	return 0
}

// This is a list of job messages.
type MessageList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Job           []*VeloMessage         `protobuf:"bytes,1,rep,name=job,proto3" json:"job,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MessageList) Reset() {
	*x = MessageList{}
	mi := &file_jobs_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MessageList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MessageList) ProtoMessage() {}

func (x *MessageList) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MessageList.ProtoReflect.Descriptor instead.
func (*MessageList) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{8}
}

func (x *MessageList) GetJob() []*VeloMessage {
	if x != nil {
		return x.Job
	}
	return nil
}

// This is the protobuf which is transmitted on the wire
type PackedMessageList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// How the message_list element is compressed.
	Compression PackedMessageList_CompressionType `protobuf:"varint,4,opt,name=compression,proto3,enum=proto.PackedMessageList_CompressionType" json:"compression,omitempty"`
	// A serialized and compressed MessageList for signing
	MessageList   [][]byte `protobuf:"bytes,1,rep,name=message_list,json=messageList,proto3" json:"message_list,omitempty"`
	Timestamp     uint64   `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Nonce         string   `protobuf:"bytes,7,opt,name=nonce,proto3" json:"nonce,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PackedMessageList) Reset() {
	*x = PackedMessageList{}
	mi := &file_jobs_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PackedMessageList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PackedMessageList) ProtoMessage() {}

func (x *PackedMessageList) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PackedMessageList.ProtoReflect.Descriptor instead.
func (*PackedMessageList) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{9}
}

func (x *PackedMessageList) GetCompression() PackedMessageList_CompressionType {
	if x != nil {
		return x.Compression
	}
	return PackedMessageList_UNCOMPRESSED
}

func (x *PackedMessageList) GetMessageList() [][]byte {
	if x != nil {
		return x.MessageList
	}
	return nil
}

func (x *PackedMessageList) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *PackedMessageList) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

// A cacheable object carrying key material that is reused between
// packets. Can be re-verified on demand but it is retransmitted on
// each packet and cached on each end.
type CipherProperties struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Name  string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Key   []byte                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// This IV is used to encrypt the cipher metadata block. Note: Both the
	// CipherProperties() and the CipherMetadata() protobufs do not change for all
	// messages in this session.
	MetadataIv []byte `protobuf:"bytes,3,opt,name=metadata_iv,json=metadataIv,proto3" json:"metadata_iv,omitempty"`
	// The key used for the hmac.
	HmacKey []byte `protobuf:"bytes,5,opt,name=hmac_key,json=hmacKey,proto3" json:"hmac_key,omitempty"`
	// The API version of the cipher.
	HmacType      CipherProperties_HMACType `protobuf:"varint,6,opt,name=hmac_type,json=hmacType,proto3,enum=proto.CipherProperties_HMACType" json:"hmac_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CipherProperties) Reset() {
	*x = CipherProperties{}
	mi := &file_jobs_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CipherProperties) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CipherProperties) ProtoMessage() {}

func (x *CipherProperties) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CipherProperties.ProtoReflect.Descriptor instead.
func (*CipherProperties) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{10}
}

func (x *CipherProperties) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CipherProperties) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *CipherProperties) GetMetadataIv() []byte {
	if x != nil {
		return x.MetadataIv
	}
	return nil
}

func (x *CipherProperties) GetHmacKey() []byte {
	if x != nil {
		return x.HmacKey
	}
	return nil
}

func (x *CipherProperties) GetHmacType() CipherProperties_HMACType {
	if x != nil {
		return x.HmacType
	}
	return CipherProperties_SIMPLE_HMAC
}

type CipherMetadata struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Source string                 `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// The signature of the encrypted cipher block.
	Signature     []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CipherMetadata) Reset() {
	*x = CipherMetadata{}
	mi := &file_jobs_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CipherMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CipherMetadata) ProtoMessage() {}

func (x *CipherMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CipherMetadata.ProtoReflect.Descriptor instead.
func (*CipherMetadata) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{11}
}

func (x *CipherMetadata) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *CipherMetadata) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

// The protobuf actually sent in the POST request (or received in the GET).
// Next field: 11
type ClientCommunication struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This message is a serialized PackedMessageList() protobuf, encrypted using
	// the session key (Encrypted inside field 2) and the per-packet IV (field 8).
	Encrypted []byte `protobuf:"bytes,1,opt,name=encrypted,proto3" json:"encrypted,omitempty"`
	// This is a CipherProperties() protobuf encrypted with the public key of the
	// receiver. Contains the session key and iv, as well as hmac key. This IV
	// does not change for the duration of the session. It is used to decrypt the
	// CipherMetadata() (field 9).
	EncryptedCipher []byte `protobuf:"bytes,2,opt,name=encrypted_cipher,json=encryptedCipher,proto3" json:"encrypted_cipher,omitempty"`
	// A serialized CipherMetadata() protobuf, encrypted with the session
	// key. Contains the RSA signature of the digest of the serialized
	// CipherProperties() above, signed with the sender's private key.
	EncryptedCipherMetadata []byte `protobuf:"bytes,9,opt,name=encrypted_cipher_metadata,json=encryptedCipherMetadata,proto3" json:"encrypted_cipher_metadata,omitempty"`
	// This iv is used to encrypt the encrypted field (No. 1). This IV changes for
	// each packet.
	PacketIv []byte                     `protobuf:"bytes,8,opt,name=packet_iv,json=packetIv,proto3" json:"packet_iv,omitempty"`
	Status   ClientCommunication_Status `protobuf:"varint,5,opt,name=status,proto3,enum=proto.ClientCommunication_Status" json:"status,omitempty"`
	// Communication version:
	// 3 - All versions before release 0.6.8
	// 4 - Release 0.6.8
	ApiVersion uint32 `protobuf:"varint,6,opt,name=api_version,json=apiVersion,proto3" json:"api_version,omitempty"`
	// This is the FULL_HMAC. It covers:
	// 1) the "encrypted" field,
	// 2) The "encrypted_cipher" field.
	// 3) The encrypted_cipher_metadata field
	// 4) The packet iv
	// 5) the api_version.
	FullHmac []byte `protobuf:"bytes,10,opt,name=full_hmac,json=fullHmac,proto3" json:"full_hmac,omitempty"`
	// While the message is being processed, we send padding
	// periodically to the client to kep the client connection up and
	// keep the client waiting for the message to be processed. This
	// padding can be ignored.
	Padding       []uint64 `protobuf:"varint,11,rep,packed,name=padding,proto3" json:"padding,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClientCommunication) Reset() {
	*x = ClientCommunication{}
	mi := &file_jobs_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientCommunication) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientCommunication) ProtoMessage() {}

func (x *ClientCommunication) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientCommunication.ProtoReflect.Descriptor instead.
func (*ClientCommunication) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{12}
}

func (x *ClientCommunication) GetEncrypted() []byte {
	if x != nil {
		return x.Encrypted
	}
	return nil
}

func (x *ClientCommunication) GetEncryptedCipher() []byte {
	if x != nil {
		return x.EncryptedCipher
	}
	return nil
}

func (x *ClientCommunication) GetEncryptedCipherMetadata() []byte {
	if x != nil {
		return x.EncryptedCipherMetadata
	}
	return nil
}

func (x *ClientCommunication) GetPacketIv() []byte {
	if x != nil {
		return x.PacketIv
	}
	return nil
}

func (x *ClientCommunication) GetStatus() ClientCommunication_Status {
	if x != nil {
		return x.Status
	}
	return ClientCommunication_UNSET
}

func (x *ClientCommunication) GetApiVersion() uint32 {
	if x != nil {
		return x.ApiVersion
	}
	return 0
}

func (x *ClientCommunication) GetFullHmac() []byte {
	if x != nil {
		return x.FullHmac
	}
	return nil
}

func (x *ClientCommunication) GetPadding() []uint64 {
	if x != nil {
		return x.Padding
	}
	return nil
}

type LogMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// An incremental ID of the first log message
	Id int64 `protobuf:"varint,5,opt,name=id,proto3" json:"id,omitempty"`
	// Total number of rows encoded in the jsonl field.
	NumberOfRows uint64 `protobuf:"varint,6,opt,name=number_of_rows,json=numberOfRows,proto3" json:"number_of_rows,omitempty"`
	// A JSONL encoded list of log messages
	Jsonl string `protobuf:"bytes,7,opt,name=jsonl,proto3" json:"jsonl,omitempty"`
	// If any of the messages in jsonl are at error level the first is
	// captured in this string.
	ErrorMessage string `protobuf:"bytes,8,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Deprecated: The fields below are used by older clients and can
	// still be processed by the server but newer clients batch log
	// messages in the jsonl field above.
	Message   string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	Timestamp uint64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// The artifact name that we were running at the time.
	Artifact string `protobuf:"bytes,3,opt,name=artifact,proto3" json:"artifact,omitempty"`
	// DEFAULT, ERROR, DEBUG
	Level         string `protobuf:"bytes,4,opt,name=level,proto3" json:"level,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogMessage) Reset() {
	*x = LogMessage{}
	mi := &file_jobs_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogMessage) ProtoMessage() {}

func (x *LogMessage) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogMessage.ProtoReflect.Descriptor instead.
func (*LogMessage) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{13}
}

func (x *LogMessage) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *LogMessage) GetNumberOfRows() uint64 {
	if x != nil {
		return x.NumberOfRows
	}
	return 0
}

func (x *LogMessage) GetJsonl() string {
	if x != nil {
		return x.Jsonl
	}
	return ""
}

func (x *LogMessage) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *LogMessage) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *LogMessage) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *LogMessage) GetArtifact() string {
	if x != nil {
		return x.Artifact
	}
	return ""
}

func (x *LogMessage) GetLevel() string {
	if x != nil {
		return x.Level
	}
	return ""
}

// Message written to the data store with the PEM of the client's
// public key.
type PublicKey struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Pem   []byte                 `protobuf:"bytes,1,opt,name=pem,proto3" json:"pem,omitempty"`
	// The timestamp when the key was saved (the client
	// enrolled). This is used to deduce the first_seen_time.
	EnrollTime    uint64 `protobuf:"varint,2,opt,name=enroll_time,json=enrollTime,proto3" json:"enroll_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublicKey) Reset() {
	*x = PublicKey{}
	mi := &file_jobs_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublicKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicKey) ProtoMessage() {}

func (x *PublicKey) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicKey.ProtoReflect.Descriptor instead.
func (*PublicKey) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{14}
}

func (x *PublicKey) GetPem() []byte {
	if x != nil {
		return x.Pem
	}
	return nil
}

func (x *PublicKey) GetEnrollTime() uint64 {
	if x != nil {
		return x.EnrollTime
	}
	return 0
}

type ResumeTransactions struct {
	state          protoimpl.MessageState         `protogen:"open.v1"`
	FlowId         string                         `protobuf:"bytes,1,opt,name=flow_id,json=flowId,proto3" json:"flow_id,omitempty"`
	ClientId       string                         `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	Timeout        uint64                         `protobuf:"varint,7,opt,name=timeout,proto3" json:"timeout,omitempty"`
	MaxUploadBytes uint64                         `protobuf:"varint,3,opt,name=max_upload_bytes,json=maxUploadBytes,proto3" json:"max_upload_bytes,omitempty"`
	Compression    ResumeTransactions_Compression `protobuf:"varint,4,opt,name=compression,proto3,enum=proto.ResumeTransactions_Compression" json:"compression,omitempty"`
	Transactions   []*proto.UploadTransaction     `protobuf:"bytes,5,rep,name=transactions,proto3" json:"transactions,omitempty"`
	QueryStats     []*VeloStatus                  `protobuf:"bytes,6,rep,name=query_stats,json=queryStats,proto3" json:"query_stats,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ResumeTransactions) Reset() {
	*x = ResumeTransactions{}
	mi := &file_jobs_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResumeTransactions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResumeTransactions) ProtoMessage() {}

func (x *ResumeTransactions) ProtoReflect() protoreflect.Message {
	mi := &file_jobs_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResumeTransactions.ProtoReflect.Descriptor instead.
func (*ResumeTransactions) Descriptor() ([]byte, []int) {
	return file_jobs_proto_rawDescGZIP(), []int{15}
}

func (x *ResumeTransactions) GetFlowId() string {
	if x != nil {
		return x.FlowId
	}
	return ""
}

func (x *ResumeTransactions) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *ResumeTransactions) GetTimeout() uint64 {
	if x != nil {
		return x.Timeout
	}
	return 0
}

func (x *ResumeTransactions) GetMaxUploadBytes() uint64 {
	if x != nil {
		return x.MaxUploadBytes
	}
	return 0
}

func (x *ResumeTransactions) GetCompression() ResumeTransactions_Compression {
	if x != nil {
		return x.Compression
	}
	return ResumeTransactions_NONE
}

func (x *ResumeTransactions) GetTransactions() []*proto.UploadTransaction {
	if x != nil {
		return x.Transactions
	}
	return nil
}

func (x *ResumeTransactions) GetQueryStats() []*VeloStatus {
	if x != nil {
		return x.QueryStats
	}
	return nil
}

var File_jobs_proto protoreflect.FileDescriptor

const file_jobs_proto_rawDesc = "" +
	"\n" +
	"\n" +
	"jobs.proto\x12\x05proto\x1a\x14proto/semantic.proto\x1a\x1dactions/proto/transport.proto\x1a\x17actions/proto/vql.proto\"\xbe\x03\n" +
	"\vFlowRequest\x12C\n" +
	"\x10VQLClientActions\x18\x01 \x03(\v2\x17.proto.VQLCollectorArgsR\x10VQLClientActions\x12$\n" +
	"\x0elog_batch_time\x18\x02 \x01(\x04R\flogBatchTime\x12(\n" +
	"\x10flow_update_time\x18\x03 \x01(\x04R\x0eflowUpdateTime\x12\x19\n" +
	"\bmax_rows\x18\x04 \x01(\x04R\amaxRows\x12\x19\n" +
	"\bmax_logs\x18\a \x01(\x04R\amaxLogs\x12(\n" +
	"\x10max_upload_bytes\x18\x05 \x01(\x04R\x0emaxUploadBytes\x12-\n" +
	"\x05trace\x18\x06 \x03(\v2\x17.proto.VQLCollectorArgsR\x05trace\x12&\n" +
	"\x0flog_error_regex\x18\b \x01(\tR\rlogErrorRegex\x12@\n" +
	"\vcompression\x18\t \x01(\x0e2\x1e.proto.FlowRequest.CompressionR\vcompression\"!\n" +
	"\vCompression\x12\b\n" +
	"\x04NONE\x10\x00\x12\b\n" +
	"\x04ZLIB\x10\x01\"\x85\x0e\n" +
	"\vVeloMessage\x12_\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tB@\xe2\xfc\xe3\xc4\x01:\x128The session id of the flow that this message belongs to.R\tsessionId\x12\x19\n" +
	"\bquery_id\x18% \x01(\x04R\aqueryId\x12u\n" +
	"\n" +
	"request_id\x18\x02 \x01(\x04BV\xe2\xfc\xe3\xc4\x01P\x12NThe message is in response to this request number (requests increment from 1).R\trequestId\x12\x16\n" +
	"\x06urgent\x18$ \x01(\bR\x06urgent\x12]\n" +
	"\vresponse_id\x18\x03 \x01(\x04B<\xe2\xfc\xe3\xc4\x016\x124Responses for each request are also numbered from 1.R\n" +
	"responseId\x12\x16\n" +
	"\x06source\x18\x06 \x01(\tR\x06source\x12\x15\n" +
	"\x06org_id\x18( \x01(\tR\x05orgId\x12D\n" +
	"\n" +
	"auth_state\x18\a \x01(\x0e2%.proto.VeloMessage.AuthorizationStateR\tauthState\x12\x17\n" +
	"\atask_id\x18\x0f \x01(\x04R\x06taskId\x12/\n" +
	"\n" +
	"flow_stats\x18) \x01(\v2\x10.proto.FlowStatsR\tflowStats\x12)\n" +
	"\x06status\x18\x19 \x01(\v2\x11.proto.VeloStatusR\x06status\x12=\n" +
	"\x0eForemanCheckin\x18\x1b \x01(\v2\x15.proto.ForemanCheckinR\x0eForemanCheckin\x121\n" +
	"\n" +
	"FileBuffer\x18\x1c \x01(\v2\x11.proto.FileBufferR\n" +
	"FileBuffer\x12F\n" +
	"\x11UploadTransaction\x18, \x01(\v2\x18.proto.UploadTransactionR\x11UploadTransaction\x12$\n" +
	"\x03CSR\x18\x1d \x01(\v2\x12.proto.CertificateR\x03CSR\x124\n" +
	"\vVQLResponse\x18! \x01(\v2\x12.proto.VQLResponseR\vVQLResponse\x121\n" +
	"\n" +
	"LogMessage\x18\" \x01(\v2\x11.proto.LogMessageR\n" +
	"LogMessage\x12!\n" +
	"\x04Ping\x18' \x01(\v2\r.proto.CancelR\x04Ping\x12@\n" +
	"\x10UpdateEventTable\x18\x1f \x01(\v2\x14.proto.VQLEventTableR\x10UpdateEventTable\x12A\n" +
	"\x0fVQLClientAction\x18\x1e \x01(\v2\x17.proto.VQLCollectorArgsR\x0fVQLClientAction\x124\n" +
	"\vFlowRequest\x18* \x01(\v2\x12.proto.FlowRequestR\vFlowRequest\x12I\n" +
	"\x12ResumeTransactions\x18- \x01(\v2\x19.proto.ResumeTransactionsR\x12ResumeTransactions\x12E\n" +
	"\x12flow_stats_request\x18+ \x01(\v2\x17.proto.FlowStatsRequestR\x10flowStatsRequest\x12%\n" +
	"\x06Cancel\x18  \x01(\v2\r.proto.CancelR\x06Cancel\x12;\n" +
	"\rUpdateForeman\x18# \x01(\v2\x15.proto.ForemanCheckinR\rUpdateForeman\x121\n" +
	"\fKillKillKill\x18& \x01(\v2\r.proto.CancelR\fKillKillKill\x12\x8d\x01\n" +
	"\x04name\x18\x04 \x01(\tBy\xe2\xfc\xe3\xc4\x01s\x12qThis is the name of the client action that will be executed. It is set by the flow and is executed by the client.R\x04name\x12\x12\n" +
	"\x04args\x18\x05 \x01(\fR\x04args\x12\"\n" +
	"\rargs_rdf_name\x18\x0e \x01(\tR\vargsRdfName\x12+\n" +
	"\x04type\x18\b \x01(\x0e2\x17.proto.VeloMessage.TypeR\x04type\"<\n" +
	"\x12AuthorizationState\x12\x13\n" +
	"\x0fUNAUTHENTICATED\x10\x00\x12\x11\n" +
	"\rAUTHENTICATED\x10\x01\"\x1f\n" +
	"\x04Type\x12\v\n" +
	"\aMESSAGE\x10\x00\x12\n" +
	"\n" +
	"\x06STATUS\x10\x01\"&\n" +
	"\x06Cancel\x12\x1c\n" +
	"\tprincipal\x18\x01 \x01(\tR\tprincipal\"~\n" +
	"\vCertificate\x12+\n" +
	"\x04type\x18\x01 \x01(\x0e2\x17.proto.Certificate.TypeR\x04type\x12\x10\n" +
	"\x03pem\x18\x02 \x01(\fR\x03pem\x12\x0e\n" +
	"\x02cn\x18\x03 \x01(\tR\x02cn\" \n" +
	"\x04Type\x12\a\n" +
	"\x03CSR\x10\x00\x12\a\n" +
	"\x03CRT\x10\x01\x12\x06\n" +
	"\x02CA\x10\x02\"\xe7\x03\n" +
	"\tFlowStats\x120\n" +
	"\x14total_uploaded_files\x18\x01 \x01(\x04R\x12totalUploadedFiles\x12A\n" +
	"\x1dtotal_expected_uploaded_bytes\x18\x02 \x01(\x04R\x1atotalExpectedUploadedBytes\x120\n" +
	"\x14total_uploaded_bytes\x18\x03 \x01(\x04R\x12totalUploadedBytes\x120\n" +
	"\x14total_collected_rows\x18\x04 \x01(\x04R\x12totalCollectedRows\x12\x1d\n" +
	"\n" +
	"total_logs\x18\x05 \x01(\x04R\ttotalLogs\x129\n" +
	"\x18transactions_outstanding\x18\n" +
	" \x01(\x04R\x17transactionsOutstanding\x12\x1c\n" +
	"\ttimestamp\x18\x06 \x01(\x04R\ttimestamp\x12.\n" +
	"\x13names_with_response\x18\t \x03(\tR\x11namesWithResponse\x124\n" +
	"\fquery_status\x18\a \x03(\v2\x11.proto.VeloStatusR\vqueryStatus\x12#\n" +
	"\rflow_complete\x18\b \x01(\bR\fflowComplete\"+\n" +
	"\x10FlowStatsRequest\x12\x17\n" +
	"\aflow_id\x18\x01 \x03(\tR\x06flowId\"/\n" +
	"\x14FlowStatsSummaryItem\x12\x17\n" +
	"\aflow_id\x18\x01 \x01(\tR\x06flowId\"\xbf\x05\n" +
	"\n" +
	"VeloStatus\x128\n" +
	"\x06status\x18\x01 \x01(\x0e2 .proto.VeloStatus.ReturnedStatusR\x06status\x12#\n" +
	"\rerror_message\x18\x02 \x01(\tR\ferrorMessage\x12\x1c\n" +
	"\tbacktrace\x18\x03 \x01(\tR\tbacktrace\x12\x1a\n" +
	"\bduration\x18\x04 \x01(\x03R\bduration\x12\x1f\n" +
	"\vlast_active\x18\x0e \x01(\x04R\n" +
	"lastActive\x12!\n" +
	"\ffirst_active\x18\x0f \x01(\x04R\vfirstActive\x12.\n" +
	"\x13names_with_response\x18\x05 \x03(\tR\x11namesWithResponse\x12\x1a\n" +
	"\bArtifact\x18\n" +
	" \x01(\tR\bArtifact\x12\x19\n" +
	"\blog_rows\x18\x06 \x01(\x03R\alogRows\x12%\n" +
	"\x0euploaded_files\x18\v \x01(\x03R\ruploadedFiles\x12%\n" +
	"\x0euploaded_bytes\x18\f \x01(\x03R\ruploadedBytes\x126\n" +
	"\x17expected_uploaded_bytes\x18\r \x01(\x03R\x15expectedUploadedBytes\x12\x1f\n" +
	"\vresult_rows\x18\a \x01(\x03R\n" +
	"resultRows\x12\x19\n" +
	"\bquery_id\x18\b \x01(\x03R\aqueryId\x12#\n" +
	"\rtotal_queries\x18\t \x01(\x03R\ftotalQueries\x129\n" +
	"\x18transactions_outstanding\x18\x10 \x01(\x04R\x17transactionsOutstanding\"K\n" +
	"\x0eReturnedStatus\x12\x06\n" +
	"\x02OK\x10\x00\x12\f\n" +
	"\bPROGRESS\x10\x04\x12\x11\n" +
	"\rGENERIC_ERROR\x10\n" +
	"\x12\x10\n" +
	"\fUNKNOWN_FLOW\x10\v\"3\n" +
	"\vMessageList\x12$\n" +
	"\x03job\x18\x01 \x03(\v2\x12.proto.VeloMessageR\x03job\"\xf0\x05\n" +
	"\x11PackedMessageList\x12J\n" +
	"\vcompression\x18\x04 \x01(\x0e2(.proto.PackedMessageList.CompressionTypeR\vcompression\x12!\n" +
	"\fmessage_list\x18\x01 \x03(\fR\vmessageList\x12l\n" +
	"\ttimestamp\x18\x06 \x01(\x04BN\xe2\xfc\xe3\xc4\x01H\n" +
	"\vRDFDatetime\x129The client sends its timestamp to prevent replay attacks.R\ttimestamp\x12\xc6\x03\n" +
	"\x05nonce\x18\a \x01(\tB\xaf\x03\xe2\xfc\xe3\xc4\x01\xa8\x03\x12\xa5\x03A shared nonce between the server and client which must be given by the client. The server uses this to ensure the client belongs to the same deployment as the server. Without this check any client may connect to any server. NOTE this is a weak check - anyone who compromises a client in this deployment may extract this nonce and connect to that server, but it makes it a little harder to join a Velociraptor deployment.R\x05nonce\"5\n" +
	"\x0fCompressionType\x12\x10\n" +
	"\fUNCOMPRESSED\x10\x00\x12\x10\n" +
	"\fZCOMPRESSION\x10\x01\"\xa4\x02\n" +
	"\x10CipherProperties\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12'\n" +
	"\x03key\x18\x02 \x01(\fB\x15\xe2\xfc\xe3\xc4\x01\x0f\n" +
	"\rEncryptionKeyR\x03key\x126\n" +
	"\vmetadata_iv\x18\x03 \x01(\fB\x15\xe2\xfc\xe3\xc4\x01\x0f\n" +
	"\rEncryptionKeyR\n" +
	"metadataIv\x120\n" +
	"\bhmac_key\x18\x05 \x01(\fB\x15\xe2\xfc\xe3\xc4\x01\x0f\n" +
	"\rEncryptionKeyR\ahmacKey\x12=\n" +
	"\thmac_type\x18\x06 \x01(\x0e2 .proto.CipherProperties.HMACTypeR\bhmacType\"*\n" +
	"\bHMACType\x12\x0f\n" +
	"\vSIMPLE_HMAC\x10\x00\x12\r\n" +
	"\tFULL_HMAC\x10\x01\"\x97\x01\n" +
	"\x0eCipherMetadata\x12g\n" +
	"\x06source\x18\x01 \x01(\tBO\xe2\xfc\xe3\xc4\x01I\n" +
	"\x06RDFURN\x12?The common name this cipher should be used to communicate with.R\x06source\x12\x1c\n" +
	"\tsignature\x18\x02 \x01(\fR\tsignature\"\xa4\x03\n" +
	"\x13ClientCommunication\x12\x1c\n" +
	"\tencrypted\x18\x01 \x01(\fR\tencrypted\x12)\n" +
	"\x10encrypted_cipher\x18\x02 \x01(\fR\x0fencryptedCipher\x12:\n" +
	"\x19encrypted_cipher_metadata\x18\t \x01(\fR\x17encryptedCipherMetadata\x122\n" +
	"\tpacket_iv\x18\b \x01(\fB\x15\xe2\xfc\xe3\xc4\x01\x0f\n" +
	"\rEncryptionKeyR\bpacketIv\x129\n" +
	"\x06status\x18\x05 \x01(\x0e2!.proto.ClientCommunication.StatusR\x06status\x12\x1f\n" +
	"\vapi_version\x18\x06 \x01(\rR\n" +
	"apiVersion\x12\x1b\n" +
	"\tfull_hmac\x18\n" +
	" \x01(\fR\bfullHmac\x12\x18\n" +
	"\apadding\x18\v \x03(\x04R\apadding\"A\n" +
	"\x06Status\x12\t\n" +
	"\x05UNSET\x10\x00\x12\a\n" +
	"\x02OK\x10\xc8\x01\x12\x10\n" +
	"\vBAD_REQUEST\x10\x90\x03\x12\x11\n" +
	"\fCIPHER_ERROR\x10\x96\x03\"\xd2\x02\n" +
	"\n" +
	"LogMessage\x12\x0e\n" +
	"\x02id\x18\x05 \x01(\x03R\x02id\x12$\n" +
	"\x0enumber_of_rows\x18\x06 \x01(\x04R\fnumberOfRows\x12\x14\n" +
	"\x05jsonl\x18\a \x01(\tR\x05jsonl\x12#\n" +
	"\rerror_message\x18\b \x01(\tR\ferrorMessage\x12D\n" +
	"\amessage\x18\x01 \x01(\tB*\xe2\xfc\xe3\xc4\x01$\x12\"The message to send to the server.R\amessage\x12[\n" +
	"\ttimestamp\x18\x02 \x01(\x04B=\xe2\xfc\xe3\xc4\x017\n" +
	"\vRDFDatetime\x12(The time when the message was generated.R\ttimestamp\x12\x1a\n" +
	"\bartifact\x18\x03 \x01(\tR\bartifact\x12\x14\n" +
	"\x05level\x18\x04 \x01(\tR\x05level\">\n" +
	"\tPublicKey\x12\x10\n" +
	"\x03pem\x18\x01 \x01(\fR\x03pem\x12\x1f\n" +
	"\venroll_time\x18\x02 \x01(\x04R\n" +
	"enrollTime\"\xec\x02\n" +
	"\x12ResumeTransactions\x12\x17\n" +
	"\aflow_id\x18\x01 \x01(\tR\x06flowId\x12\x1b\n" +
	"\tclient_id\x18\x02 \x01(\tR\bclientId\x12\x18\n" +
	"\atimeout\x18\a \x01(\x04R\atimeout\x12(\n" +
	"\x10max_upload_bytes\x18\x03 \x01(\x04R\x0emaxUploadBytes\x12G\n" +
	"\vcompression\x18\x04 \x01(\x0e2%.proto.ResumeTransactions.CompressionR\vcompression\x12<\n" +
	"\ftransactions\x18\x05 \x03(\v2\x18.proto.UploadTransactionR\ftransactions\x122\n" +
	"\vquery_stats\x18\x06 \x03(\v2\x11.proto.VeloStatusR\n" +
	"queryStats\"!\n" +
	"\vCompression\x12\b\n" +
	"\x04NONE\x10\x00\x12\b\n" +
	"\x04ZLIB\x10\x01B4Z2www.velocidex.com/golang/velociraptor/crypto/protob\x06proto3"

var (
	file_jobs_proto_rawDescOnce sync.Once
	file_jobs_proto_rawDescData []byte
)

func file_jobs_proto_rawDescGZIP() []byte {
	file_jobs_proto_rawDescOnce.Do(func() {
		file_jobs_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_jobs_proto_rawDesc), len(file_jobs_proto_rawDesc)))
	})
	return file_jobs_proto_rawDescData
}

var file_jobs_proto_enumTypes = make([]protoimpl.EnumInfo, 9)
var file_jobs_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_jobs_proto_goTypes = []any{
	(FlowRequest_Compression)(0),           // 0: proto.FlowRequest.Compression
	(VeloMessage_AuthorizationState)(0),    // 1: proto.VeloMessage.AuthorizationState
	(VeloMessage_Type)(0),                  // 2: proto.VeloMessage.Type
	(Certificate_Type)(0),                  // 3: proto.Certificate.Type
	(VeloStatus_ReturnedStatus)(0),         // 4: proto.VeloStatus.ReturnedStatus
	(PackedMessageList_CompressionType)(0), // 5: proto.PackedMessageList.CompressionType
	(CipherProperties_HMACType)(0),         // 6: proto.CipherProperties.HMACType
	(ClientCommunication_Status)(0),        // 7: proto.ClientCommunication.Status
	(ResumeTransactions_Compression)(0),    // 8: proto.ResumeTransactions.Compression
	(*FlowRequest)(nil),                    // 9: proto.FlowRequest
	(*VeloMessage)(nil),                    // 10: proto.VeloMessage
	(*Cancel)(nil),                         // 11: proto.Cancel
	(*Certificate)(nil),                    // 12: proto.Certificate
	(*FlowStats)(nil),                      // 13: proto.FlowStats
	(*FlowStatsRequest)(nil),               // 14: proto.FlowStatsRequest
	(*FlowStatsSummaryItem)(nil),           // 15: proto.FlowStatsSummaryItem
	(*VeloStatus)(nil),                     // 16: proto.VeloStatus
	(*MessageList)(nil),                    // 17: proto.MessageList
	(*PackedMessageList)(nil),              // 18: proto.PackedMessageList
	(*CipherProperties)(nil),               // 19: proto.CipherProperties
	(*CipherMetadata)(nil),                 // 20: proto.CipherMetadata
	(*ClientCommunication)(nil),            // 21: proto.ClientCommunication
	(*LogMessage)(nil),                     // 22: proto.LogMessage
	(*PublicKey)(nil),                      // 23: proto.PublicKey
	(*ResumeTransactions)(nil),             // 24: proto.ResumeTransactions
	(*proto.VQLCollectorArgs)(nil),         // 25: proto.VQLCollectorArgs
	(*proto.ForemanCheckin)(nil),           // 26: proto.ForemanCheckin
	(*proto.FileBuffer)(nil),               // 27: proto.FileBuffer
	(*proto.UploadTransaction)(nil),        // 28: proto.UploadTransaction
	(*proto.VQLResponse)(nil),              // 29: proto.VQLResponse
	(*proto.VQLEventTable)(nil),            // 30: proto.VQLEventTable
}
var file_jobs_proto_depIdxs = []int32{
	25, // 0: proto.FlowRequest.VQLClientActions:type_name -> proto.VQLCollectorArgs
	25, // 1: proto.FlowRequest.trace:type_name -> proto.VQLCollectorArgs
	0,  // 2: proto.FlowRequest.compression:type_name -> proto.FlowRequest.Compression
	1,  // 3: proto.VeloMessage.auth_state:type_name -> proto.VeloMessage.AuthorizationState
	13, // 4: proto.VeloMessage.flow_stats:type_name -> proto.FlowStats
	16, // 5: proto.VeloMessage.status:type_name -> proto.VeloStatus
	26, // 6: proto.VeloMessage.ForemanCheckin:type_name -> proto.ForemanCheckin
	27, // 7: proto.VeloMessage.FileBuffer:type_name -> proto.FileBuffer
	28, // 8: proto.VeloMessage.UploadTransaction:type_name -> proto.UploadTransaction
	12, // 9: proto.VeloMessage.CSR:type_name -> proto.Certificate
	29, // 10: proto.VeloMessage.VQLResponse:type_name -> proto.VQLResponse
	22, // 11: proto.VeloMessage.LogMessage:type_name -> proto.LogMessage
	11, // 12: proto.VeloMessage.Ping:type_name -> proto.Cancel
	30, // 13: proto.VeloMessage.UpdateEventTable:type_name -> proto.VQLEventTable
	25, // 14: proto.VeloMessage.VQLClientAction:type_name -> proto.VQLCollectorArgs
	9,  // 15: proto.VeloMessage.FlowRequest:type_name -> proto.FlowRequest
	24, // 16: proto.VeloMessage.ResumeTransactions:type_name -> proto.ResumeTransactions
	14, // 17: proto.VeloMessage.flow_stats_request:type_name -> proto.FlowStatsRequest
	11, // 18: proto.VeloMessage.Cancel:type_name -> proto.Cancel
	26, // 19: proto.VeloMessage.UpdateForeman:type_name -> proto.ForemanCheckin
	11, // 20: proto.VeloMessage.KillKillKill:type_name -> proto.Cancel
	2,  // 21: proto.VeloMessage.type:type_name -> proto.VeloMessage.Type
	3,  // 22: proto.Certificate.type:type_name -> proto.Certificate.Type
	16, // 23: proto.FlowStats.query_status:type_name -> proto.VeloStatus
	4,  // 24: proto.VeloStatus.status:type_name -> proto.VeloStatus.ReturnedStatus
	10, // 25: proto.MessageList.job:type_name -> proto.VeloMessage
	5,  // 26: proto.PackedMessageList.compression:type_name -> proto.PackedMessageList.CompressionType
	6,  // 27: proto.CipherProperties.hmac_type:type_name -> proto.CipherProperties.HMACType
	7,  // 28: proto.ClientCommunication.status:type_name -> proto.ClientCommunication.Status
	8,  // 29: proto.ResumeTransactions.compression:type_name -> proto.ResumeTransactions.Compression
	28, // 30: proto.ResumeTransactions.transactions:type_name -> proto.UploadTransaction
	16, // 31: proto.ResumeTransactions.query_stats:type_name -> proto.VeloStatus
	32, // [32:32] is the sub-list for method output_type
	32, // [32:32] is the sub-list for method input_type
	32, // [32:32] is the sub-list for extension type_name
	32, // [32:32] is the sub-list for extension extendee
	0,  // [0:32] is the sub-list for field type_name
}

func init() { file_jobs_proto_init() }
func file_jobs_proto_init() {
	if File_jobs_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_jobs_proto_rawDesc), len(file_jobs_proto_rawDesc)),
			NumEnums:      9,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_jobs_proto_goTypes,
		DependencyIndexes: file_jobs_proto_depIdxs,
		EnumInfos:         file_jobs_proto_enumTypes,
		MessageInfos:      file_jobs_proto_msgTypes,
	}.Build()
	File_jobs_proto = out.File
	file_jobs_proto_goTypes = nil
	file_jobs_proto_depIdxs = nil
}
