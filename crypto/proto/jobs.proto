// Copyright 2011 Google Inc. All Rights Reserved

// These are the messages used in GRR encrypted communication protocol.
syntax = "proto3";

import "google/protobuf/any.proto";
import "www.velocidex.com/golang/velociraptor/proto/semantic.proto";

package proto;

// This message is sent between the client and the server.
// Next field: 24
message GrrMessage {
   string session_id = 1 [(sem_type) = {
      type: "FlowSessionID",
      description: "The session id of the flow that this message belongs to."
    }];

   uint64 request_id = 2 [(sem_type) = {
      description: "The message is in response to this request number "
      "(requests increment from 1)."
    }];

   uint64 response_id = 3 [(sem_type) = {
      description: "Responses for each request are also numbered from 1."
    }];

   string name = 4 [(sem_type) = {
      description: "This is the name of the client action that will be "
      "executed. It is set by the flow and is executed by the client."
    }];

  // This field contains an encoded rdfvalue.
   bytes args = 5;

   string source = 6  [(sem_type) = {
      type: "RDFURN",
      description: "Client name where the message came from "
      "(Filled in by the frontend)."
    }];

  // A Flag to indicate if the message is authenticated. Note that the client
  // does not get to decide this - the_server will verify the message and tag it
  // as such. The message is then passed down the chain of components carrying
  // this tag.

  // This is done because signing is done on a group of messages as they arrive
  // over the POST, but after decryption and unpacking, messages are queued
  // individually and therefore need to retain their authenticated status.
  enum AuthorizationState {
    UNAUTHENTICATED = 0;
    AUTHENTICATED = 1;

    // This indicates that clocks are out of sync and this message may be a
    // replay.
    DESYNCHRONIZED = 2;
  };

   AuthorizationState auth_state = 7;

  enum Type {
      MESSAGE = 0; // The main kind of message.
      STATUS = 1; //
  };

  // The final response to a request carries this type which indicates it is a
  // status message.
   Type type = 8;

  // The rdfvalue class of the args.
   string args_rdf_name = 14;

  // The id of this message in the scheduler.
   uint64 task_id = 15;

    // Supercedes the args parameter.
    google.protobuf.Any payload = 23 [(sem_type) = {
            description: "The payload of this message",
        }];
};

// Certificates are exchanged with this.
message Certificate {
  enum Type {
    CSR = 0;
    CRT = 1;
    CA  = 2;
  };

   Type type = 1;
   bytes pem = 2;
   string cn = 3;
};

// This is a status response that is sent for each complete
// transaction. It is always the last message in the transaction.
message GrrStatus {
  enum ReturnedStatus {
    OK = 0;
    IOERROR = 1;
    RETRANSMISSION_DETECTED = 2;
    CLIENT_KILLED = 3;
    NETWORK_LIMIT_EXCEEDED = 4;

    WORKER_STUCK = 9;
    GENERIC_ERROR = 10;
  };

   ReturnedStatus status = 1;

   string error_message = 2;

   string backtrace = 3;

   string child_session_id = 5 [(sem_type) = {
      type: "SessionID",
      description: "The URN of a subflow.",
    }];

   uint64 network_bytes_sent = 6;

   string nanny_status = 7;
};

// This is a list of messages
message MessageList {
  repeated GrrMessage job = 1;
};

// This is the protobuf which is transmitted on the wire
message PackedMessageList {
  enum CompressionType {
    UNCOMPRESSED = 0;
    // Compressed using the zlib.compress() function.
    ZCOMPRESSION = 1;
  };

  // This is a serialized MessageList for signing
   repeated bytes message_list = 1;

   string source = 3 [(sem_type) = {
      type: "RDFURN",
      description: "The source where this message came from."
    }];

  // How the message_list element is compressed
   CompressionType compression = 4;
   uint64 timestamp = 6 [(sem_type) = {
      type: "RDFDatetime",
      description: "The client sends its timestamp to prevent replay attacks."
    }];

    string nonce = 7 [(sem_type) = {
            description: "A shared nonce between the server and client which must be given by the client. The server uses this to ensure the client belongs to the same deployment as the server. Without this check any client may connect to any server. NOTE this is a weak check - anyone who compromises a client in this deployment may extract this nonce and connect to that server, but it makes it a little harder to join a Velociraptor deployment."
        }];
};

message CipherProperties {
   string name = 1;

   bytes key = 2 [(sem_type) = {
      type: "EncryptionKey",
    }];

  // This IV is used to encrypt the cipher metadata block. Note: Both the
  // CipherProperties() and the CipherMetadata() protobufs do not change for all
  // messages in this session.
   bytes metadata_iv = 3 [(sem_type) = {
      type: "EncryptionKey",
    }];

  // The key used for the hmac.
   bytes hmac_key = 5 [(sem_type) = {
      type: "EncryptionKey",
    }];

  enum HMACType {
    // Older clients use a HMAC only on the encrypted message.
    SIMPLE_HMAC = 0;

    // Newer clients also include the encrypted cipher and API version in the
    // hmac.
    FULL_HMAC = 1;
  };

  // The API version of the cipher.
   HMACType hmac_type = 6;

};

message CipherMetadata {
   string source = 1 [(sem_type) = {
      type: "RDFURN",
      description: "The common name this cipher should be used to communicate with."
    }];

  // The signature of the encrypted cipher block.
   bytes signature = 2;
};

// Next field: 11
message ClientCommunication {
  // This message is a serialized SignedMessageList() protobuf, encrypted using
  // the session key (Encrypted inside field 2) and the per-packet IV (field 8).
   bytes encrypted = 1;

  // This is a CipherProperties() protobuf encrypted with the public key of the
  // receiver. Contains the session key and iv, as well as hmac key. This IV
  // does not change for the duration of the session. It is used to decrypt the
  // CipherMetadata() (field 9).
   bytes encrypted_cipher = 2;

  // A serialized CipherMetadata() protobuf, encrypted with the session
  // key. Contains the RSA signature of the digest of the serialized
  // CipherProperties() above, signed with the sender's private key.
   bytes encrypted_cipher_metadata = 9;

  // This iv is used to encrypt the encrypted field (No. 1). This IV changes for
  // each packet.
   bytes packet_iv = 8 [(sem_type) = {
      type: "EncryptionKey",
    }];;

  //  Not supported by velociraptor.
  //   HttpRequest orig_request = 3;

  // The number of messages waiting on the input queue. The client
  // fills this in so the server can limit the number of messages
  // issued to the client as a means of throttling it.
   uint32 queue_size = 4;

  // This status code applies for the entire communication.
  enum Status {
      UNSET = 0;
    OK = 200;
    BAD_REQUEST = 400;
    CIPHER_ERROR = 406;
  };
   Status status = 5;

   uint32 api_version = 6;

  // The choice of which hmac is used is set in the CipherProperties() protocol
  // buffer. A full hmac is more secure and is the new default, but we can still
  // support the old hmac for backwards compatibility.

  // This is the SIMPLE_HMAC. It covers the "encrypted" field only.
   bytes hmac = 7;

  // This is the FULL_HMAC. It covers:
  // 1) the "encrypted" field,
  // 2) The "encrypted_cipher" field.
  // 3) The encrypted_cipher_metadata field
  // 4) The packet iv
  // 5) the api_version.
   bytes full_hmac = 10;

    // While the message is being processed, we send padding
    // periodically to the client to kep the client connection up and
    // keep the client waiting for the message to be processed. This
    // padding can be ignored.
    repeated uint64 padding = 11;
};


message LogMessage {
    string message = 1 [(sem_type) = {
            description: "The message to send to the server.",
        }];

    uint64 timestamp = 2 [(sem_type) = {
            description: "The time when the message was generated.",
            type: "RDFDatetime",
        }];
}

// Message written to the data store with the PEM of the client's
// public key.
message PublicKey {
    bytes pem = 1;
}