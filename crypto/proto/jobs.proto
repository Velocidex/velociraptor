// Copyright 2011 Google Inc. All Rights Reserved

// These are the messages used in GRR encrypted communication protocol.
syntax = "proto3";

import "google/protobuf/any.proto";
import "www.velocidex.com/golang/velociraptor/proto/semantic.proto";

package proto;

// This message is sent between the client and the server.
// Next field: 24
message GrrMessage {
   string session_id = 1 [(sem_type) = {
      type: "FlowSessionID",
      description: "The session id of the flow that this message belongs to."
    }];

   uint64 request_id = 2 [(sem_type) = {
      description: "The message is in response to this request number "
      "(requests increment from 1)."
    }];

   uint64 response_id = 3 [(sem_type) = {
      description: "Responses for each request are also numbered from 1."
    }];

   string name = 4 [(sem_type) = {
      description: "This is the name of the client action that will be "
      "executed. It is set by the flow and is executed by the client."
    }];

  // This field contains an encoded rdfvalue.
   bytes args = 5;

  // Due to superceed the args field (not yet implemented). Contains the
  // argument to the client action, or the response from the client action.
  //  Not supported by velociraptor.
  //   EmbeddedRDFValue arg = 20;

   string source = 6  [(sem_type) = {
      type: "RDFURN",
      description: "Client name where the message came from "
      "(Filled in by the frontend)."
    }];

  // A Flag to indicate if the message is authenticated. Note that the client
  // does not get to decide this - the_server will verify the message and tag it
  // as such. The message is then passed down the chain of components carrying
  // this tag.

  // This is done because signing is done on a group of messages as they arrive
  // over the POST, but after decryption and unpacking, messages are queued
  // individually and therefore need to retain their authenticated status.
  enum AuthorizationState {
    UNAUTHENTICATED = 0;
    AUTHENTICATED = 1;

    // This indicates that clocks are out of sync and this message may be a
    // replay.
    DESYNCHRONIZED = 2;
  };

   AuthorizationState auth_state = 7;

  enum Type {
    MESSAGE = 0;
    STATUS = 1;
    ITERATOR = 2;
  };

  // The final response to a request carries this type which indicates it is a
  // status message.
   Type type = 8;

  enum Priority {
    LOW_PRIORITY = 0;
    MEDIUM_PRIORITY = 1;
    HIGH_PRIORITY = 2;
  };

   Priority priority = 9 [(sem_type) = {
      description: "The priority of this message - allows higher priority "
      "messages to leap to the front of queues."
    }];

   uint32 ttl = 10 [(sem_type) = {
      description: "Time to live - each time a request is retransmitted this "
      "decrement until it expires."
    }];

   bool require_fastpoll = 11 [(sem_type) = {
      description: "If this is true, the client will enter fast poll mode "
      "after processing."
    }];

   float cpu_limit = 12 [(sem_type) = {
      description: "Maximum number of CPU seconds to be used by this action."
    }];

   uint64 args_age = 13 [(sem_type) = {
      type: "RDFDatetime",
      description: "The age of the args rdfvalue.",
    }];

  // The rdfvalue class of the args.
   string args_rdf_name = 14;

  // The id of this message in the scheduler.
   uint64 task_id = 15;

  // The ttl used in the task scheduler.
   int32 task_ttl = 16;
   string queue = 17  [(sem_type) = {
      type: "RDFURN",
      description: "The scheduler queue this message is in."
    }];

   uint64 eta = 18 [(sem_type) = {
      type: "RDFDatetime",
      description: "The time when this message will become available "
      "for leasing.",
    }];

  // Human readable info about the last process leasing this message.
   string last_lease = 19;

   uint64 network_bytes_limit = 21 [
      (sem_type) = {
      description: "Maximum number of network bytes to be sent, 10G default. "
                   "All bytes charged against the flow session ID count "
                   "towards the limit but only during TransferBuffer is the "
                   "limit enforced. This means we can blockfile transfers but "
                   "still communicate after the limit is reached.",
      default: "10737418240",
    }];
   uint64 timestamp = 22 [(sem_type) = {
      type: "RDFDatetime",
      description: "An  timestamp when this message was stored.",
    }];

    // Velociraptor specific messages.
    enum ClientType {
        GRR = 0;
        VELOCIRAPTOR = 1;
    };

    // This is only set by the Velociraptor client to indicate special
    // processing by the Velociraptor server.
     ClientType client_type = 6600 [ (sem_type) = {
            description: "The type of client that generated this message."
        }];

    // Supercedes the args parameter.
    google.protobuf.Any payload = 23 [(sem_type) = {
            description: "The payload of this message",
        }];
};

// Certificates are exchanged with this.
message Certificate {
  enum Type {
    CSR = 0;
    CRT = 1;
    CA  = 2;
  };

   Type type = 1;
   bytes pem = 2;
   string cn = 3;
};

message CpuSeconds {
   float user_cpu_time = 1 [(sem_type) = {
      friendly_name: "User cpu seconds used",
    }];
   float system_cpu_time = 2 [(sem_type) = {
      friendly_name: "System cpu seconds used",
    }];
}

// This is a status response that is sent for each complete
// transaction. It is always the last message in the transaction.
message GrrStatus {
  enum ReturnedStatus {
    OK = 0;
    IOERROR = 1;
    RETRANSMISSION_DETECTED = 2;
    CLIENT_KILLED = 3;
    NETWORK_LIMIT_EXCEEDED = 4;

    WORKER_STUCK = 9;
    GENERIC_ERROR = 10;
  };

   ReturnedStatus status = 1;

   string error_message = 2;

   string backtrace = 3;

   CpuSeconds cpu_time_used = 4;

   string child_session_id = 5 [(sem_type) = {
      type: "SessionID",
      description: "The URN of a subflow.",
    }];

   uint64 network_bytes_sent = 6;

   string nanny_status = 7;
};

// This is a list of messages
message MessageList {
  repeated GrrMessage job = 1;
};

// This is the protobuf which is transmitted on the wire
message PackedMessageList {
  enum CompressionType {
    UNCOMPRESSED = 0;
    // Compressed using the zlib.compress() function.
    ZCOMPRESSION = 1;
  };

  // This is a serialized MessageList for signing
   bytes message_list = 1;

   string source = 3 [(sem_type) = {
      type: "RDFURN",
      description: "The source where this message came from."
    }];

  // How the message_list element is compressed
   CompressionType compression = 4;
   uint64 timestamp = 6 [(sem_type) = {
      type: "RDFDatetime",
      description: "The client sends its timestamp to prevent replay attacks."
    }];
};

message CipherProperties {
   string name = 1;

   bytes key = 2 [(sem_type) = {
      type: "EncryptionKey",
    }];

  // This IV is used to encrypt the cipher metadata block. Note: Both the
  // CipherProperties() and the CipherMetadata() protobufs do not change for all
  // messages in this session.
   bytes metadata_iv = 3 [(sem_type) = {
      type: "EncryptionKey",
    }];

  // The key used for the hmac.
   bytes hmac_key = 5 [(sem_type) = {
      type: "EncryptionKey",
    }];

  enum HMACType {
    // Older clients use a HMAC only on the encrypted message.
    SIMPLE_HMAC = 0;

    // Newer clients also include the encrypted cipher and API version in the
    // hmac.
    FULL_HMAC = 1;
  };

  // The API version of the cipher.
   HMACType hmac_type = 6;

};

message CipherMetadata {
   string source = 1 [(sem_type) = {
      type: "RDFURN",
      description: "The common name this cipher should be used to communicate with."
    }];

  // The signature of the encrypted cipher block.
   bytes signature = 2;
};

// Next field: 11
message ClientCommunication {
  // This message is a serialized SignedMessageList() protobuf, encrypted using
  // the session key (Encrypted inside field 2) and the per-packet IV (field 8).
   bytes encrypted = 1;

  // This is a CipherProperties() protobuf encrypted with the public key of the
  // receiver. Contains the session key and iv, as well as hmac key. This IV
  // does not change for the duration of the session. It is used to decrypt the
  // CipherMetadata() (field 9).
   bytes encrypted_cipher = 2;

  // A serialized CipherMetadata() protobuf, encrypted with the session
  // key. Contains the RSA signature of the digest of the serialized
  // CipherProperties() above, signed with the sender's private key.
   bytes encrypted_cipher_metadata = 9;

  // This iv is used to encrypt the encrypted field (No. 1). This IV changes for
  // each packet.
   bytes packet_iv = 8 [(sem_type) = {
      type: "EncryptionKey",
    }];;

  //  Not supported by velociraptor.
  //   HttpRequest orig_request = 3;

  // The number of messages waiting on the input queue. The client
  // fills this in so the server can limit the number of messages
  // issued to the client as a means of throttling it.
   uint32 queue_size = 4;

  // This status code applies for the entire communication.
  enum Status {
      UNSET = 0;
    OK = 200;
    BAD_REQUEST = 400;
    CIPHER_ERROR = 406;
  };
   Status status = 5;

   uint32 api_version = 6;

  // The choice of which hmac is used is set in the CipherProperties() protocol
  // buffer. A full hmac is more secure and is the new default, but we can still
  // support the old hmac for backwards compatibility.

  // This is the SIMPLE_HMAC. It covers the "encrypted" field only.
   bytes hmac = 7;

  // This is the FULL_HMAC. It covers:
  // 1) the "encrypted" field,
  // 2) The "encrypted_cipher" field.
  // 3) The encrypted_cipher_metadata field
  // 4) The packet iv
  // 5) the api_version.
   bytes full_hmac = 10;

    // While the message is being processed, we send padding
    // periodically to the client to kep the client connection up and
    // keep the client waiting for the message to be processed. This
    // padding can be ignored.
    repeated uint64 padding = 11;
};


message ClientResources {
   string client_id = 1 [(sem_type) = {
      type: "ClientURN"
    }];
   string session_id = 2 [(sem_type) = {
      type: "SessionID"
    }];
   CpuSeconds cpu_usage = 3;
   uint64 network_bytes_sent = 4;
}


message LogMessage {
    string message = 1 [(sem_type) = {
            description: "The message to send to the server.",
        }];

    uint64 timestamp = 2 [(sem_type) = {
            description: "The time when the message was generated.",
            type: "RDFDatetime",
        }];
}
