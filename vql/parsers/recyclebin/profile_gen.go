package recyclebin

// Autogenerated code from vtype_profile.json. Do not edit.

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"unicode/utf16"
	"unicode/utf8"
)

var (
	// Depending on autogenerated code we may use this. Add a reference
	// to shut the compiler up.
	_ = bytes.MinRead
	_ = fmt.Sprintf
	_ = utf16.Decode
	_ = binary.LittleEndian
	_ = utf8.RuneError
)

type RecycleBinIndex struct {
	Off_Metadata_DeletedTime    int64
	Off_Metadata_FileNameLength int64
	Off_Metadata_FilePath       int64
	Off_Metadata_FileSize       int64
	Off_Metadata_Header         int64
}

func NewRecycleBinIndex() *RecycleBinIndex {
	// Specific offsets can be tweaked to cater for slight version mismatches.
	self := &RecycleBinIndex{16, 24, 28, 8, 0}
	return self
}

func (self *RecycleBinIndex) Metadata(reader io.ReaderAt, offset int64) *Metadata {
	return &Metadata{Reader: reader, Offset: offset, Profile: self}
}

type Metadata struct {
	Reader  io.ReaderAt
	Offset  int64
	Profile *RecycleBinIndex
}

func NewMetadata(reader io.ReaderAt) *Metadata {
	self := &Metadata{Reader: reader}
	return self
}

func (self *Metadata) Size() int {
	return 0
}

func (self *Metadata) DeletedTime() uint64 {
	return ParseUint64(self.Reader, self.Profile.Off_Metadata_DeletedTime+self.Offset)
}

func (self *Metadata) FileNameLength() uint32 {
	return ParseUint32(self.Reader, self.Profile.Off_Metadata_FileNameLength+self.Offset)
}

func (self *Metadata) FilePath() string {
	return ParseTerminatedUTF16String(self.Reader, self.Profile.Off_Metadata_FilePath+self.Offset)
}

func (self *Metadata) FileSize() uint64 {
	return ParseUint64(self.Reader, self.Profile.Off_Metadata_FileSize+self.Offset)
}

func (self *Metadata) Header() uint64 {
	return ParseUint64(self.Reader, self.Profile.Off_Metadata_Header+self.Offset)
}

func ParseUint32(reader io.ReaderAt, offset int64) uint32 {
	data := make([]byte, 4)
	_, err := reader.ReadAt(data, offset)
	if err != nil {
		return 0
	}
	return binary.LittleEndian.Uint32(data)
}

func ParseUint64(reader io.ReaderAt, offset int64) uint64 {
	data := make([]byte, 8)
	_, err := reader.ReadAt(data, offset)
	if err != nil {
		return 0
	}
	return binary.LittleEndian.Uint64(data)
}

func ParseTerminatedUTF16String(reader io.ReaderAt, offset int64) string {
	data := make([]byte, 1024)
	n, err := reader.ReadAt(data, offset)
	if err != nil && err != io.EOF {
		return ""
	}

	idx := bytes.Index(data[:n], []byte{0, 0})
	if idx < 0 {
		idx = n - 1
	}
	return UTF16BytesToUTF8(data[0:idx+1], binary.LittleEndian)
}

func ParseUTF16String(reader io.ReaderAt, offset int64, length int64) string {
	data := make([]byte, length)
	n, err := reader.ReadAt(data, offset)
	if err != nil && err != io.EOF {
		return ""
	}
	return UTF16BytesToUTF8(data[:n], binary.LittleEndian)
}

func UTF16BytesToUTF8(b []byte, o binary.ByteOrder) string {
	if len(b) < 2 {
		return ""
	}

	if b[0] == 0xff && b[1] == 0xfe {
		o = binary.BigEndian
		b = b[2:]
	} else if b[0] == 0xfe && b[1] == 0xff {
		o = binary.LittleEndian
		b = b[2:]
	}

	utf := make([]uint16, (len(b)+(2-1))/2)

	for i := 0; i+(2-1) < len(b); i += 2 {
		utf[i/2] = o.Uint16(b[i:])
	}
	if len(b)/2 < len(utf) {
		utf[len(utf)-1] = utf8.RuneError
	}

	return string(utf16.Decode(utf))
}
