
package ese

// Autogenerated code from vtype_profile.json. Do not edit.

import (
    "encoding/binary"
    "fmt"
    "bytes"
    "io"
    "sort"
    "strings"
    "unicode/utf16"
    "unicode/utf8"
)

var (
   // Depending on autogenerated code we may use this. Add a reference
   // to shut the compiler up.
   _ = bytes.MinRead
   _ = fmt.Sprintf
   _ = utf16.Decode
   _ = binary.LittleEndian
   _ = utf8.RuneError
   _ = sort.Strings
   _ = strings.Join
   _ = io.Copy
)

func indent(text string) string {
    result := []string{}
    lines := strings.Split(text,"\n")
    for _, line := range lines {
         result = append(result, "  " + line)
    }
    return strings.Join(result, "\n")
}


type MiscProfile struct {
    Off_Misc_Misc int64
    Off_SID_Revision int64
    Off_SID_SubAuthCount int64
    Off_SID_Authority int64
    Off_SID_Authority2 int64
    Off_SID_Subauthority int64
}

func NewMiscProfile() *MiscProfile {
    // Specific offsets can be tweaked to cater for slight version mismatches.
    self := &MiscProfile{0,0,1,2,4,8}
    return self
}

func (self *MiscProfile) Misc(reader io.ReaderAt, offset int64) *Misc {
    return &Misc{Reader: reader, Offset: offset, Profile: self}
}

func (self *MiscProfile) SID(reader io.ReaderAt, offset int64) *SID {
    return &SID{Reader: reader, Offset: offset, Profile: self}
}


type Misc struct {
    Reader io.ReaderAt
    Offset int64
    Profile *MiscProfile
}

func (self *Misc) Size() int {
    return 0
}


func (self *Misc) Misc() string {
  return ParseTerminatedUTF16String(self.Reader, self.Profile.Off_Misc_Misc + self.Offset)
}

type SID struct {
    Reader io.ReaderAt
    Offset int64
    Profile *MiscProfile
}

func (self *SID) Size() int {
    return 16
}

func (self *SID) Revision() byte {
   return ParseUint8(self.Reader, self.Profile.Off_SID_Revision + self.Offset)
}

func (self *SID) SubAuthCount() byte {
   return ParseUint8(self.Reader, self.Profile.Off_SID_SubAuthCount + self.Offset)
}

func (self *SID) Authority() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_SID_Authority + self.Offset)
}

func (self *SID) Authority2() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_SID_Authority2 + self.Offset)
}

func (self *SID) Subauthority() []uint32 {
   return ParseArray_uint32(self.Profile, self.Reader, self.Profile.Off_SID_Subauthority + self.Offset, 100)
}

func ParseArray_uint32(profile *MiscProfile, reader io.ReaderAt, offset int64, count int) []uint32 {
    result := make([]uint32, 0, count)
    for i:=0; i<count; i++ {
      value := ParseUint32(reader, offset)
      result = append(result, value)
      offset += int64(4)
    }
    return result
}

func ParseUint16(reader io.ReaderAt, offset int64) uint16 {
    data := make([]byte, 2)
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return binary.LittleEndian.Uint16(data)
}

func ParseUint32(reader io.ReaderAt, offset int64) uint32 {
    data := make([]byte, 4)
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return binary.LittleEndian.Uint32(data)
}

func ParseUint8(reader io.ReaderAt, offset int64) byte {
    result := make([]byte, 1)
    _, err := reader.ReadAt(result, offset)
    if err != nil {
       return 0
    }
    return result[0]
}

func ParseTerminatedUTF16String(reader io.ReaderAt, offset int64) string {
   data := make([]byte, 1024)
   n, err := reader.ReadAt(data, offset)
   if err != nil && err != io.EOF {
     return ""
   }

   idx := bytes.Index(data[:n], []byte{0, 0})
   if idx < 0 {
      idx = n-1
   }
   return UTF16BytesToUTF8(data[0:idx+1], binary.LittleEndian)
}

func ParseUTF16String(reader io.ReaderAt, offset int64, length int64) string {
   data := make([]byte, length)
   n, err := reader.ReadAt(data, offset)
   if err != nil && err != io.EOF {
     return ""
   }
   return UTF16BytesToUTF8(data[:n], binary.LittleEndian)
}

func UTF16BytesToUTF8(b []byte, o binary.ByteOrder) string {
	if len(b) < 2 {
		return ""
	}

	if b[0] == 0xff && b[1] == 0xfe {
		o = binary.BigEndian
		b = b[2:]
	} else if b[0] == 0xfe && b[1] == 0xff {
		o = binary.LittleEndian
		b = b[2:]
	}

	utf := make([]uint16, (len(b)+(2-1))/2)

	for i := 0; i+(2-1) < len(b); i += 2 {
		utf[i/2] = o.Uint16(b[i:])
	}
	if len(b)/2 < len(utf) {
		utf[len(utf)-1] = utf8.RuneError
	}

	return string(utf16.Decode(utf))
}


