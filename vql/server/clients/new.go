package clients

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"time"

	"github.com/Velocidex/ordereddict"
	"www.velocidex.com/golang/velociraptor/acls"
	actions_proto "www.velocidex.com/golang/velociraptor/actions/proto"
	"www.velocidex.com/golang/velociraptor/json"
	"www.velocidex.com/golang/velociraptor/logging"
	"www.velocidex.com/golang/velociraptor/services"
	"www.velocidex.com/golang/velociraptor/vql"
	vql_subsystem "www.velocidex.com/golang/velociraptor/vql"
	"www.velocidex.com/golang/vfilter"
	"www.velocidex.com/golang/vfilter/arg_parser"
)

type NewClientArgs struct {
	FirstSeenAt  time.Time `vfilter:"optional,field=first_seen_at"`
	LastSeenAt   time.Time `vfilter:"optional,field=last_seen_at"`
	Labels       []string  `vfilter:"optional,field=labels"`
	OS           string    `vfilter:"optional,field=os,doc=What type of OS this is (default offline)"`
	Hostname     string    `vfilter:"optional,field=hostname,doc=The hostname of the system"`
	ClientId     string    `vfilter:"optional,field=client_id,doc=if set we use this client id otherwise we make a new one"`
	MacAddresses []string  `vfilter:"optional,field=mac_addresses"`
}

type NewClientFunction struct{}

func (self NewClientFunction) Call(ctx context.Context,
	scope vfilter.Scope,
	args *ordereddict.Dict) vfilter.Any {

	arg := &NewClientArgs{}

	err := vql_subsystem.CheckAccess(scope, acls.SERVER_ADMIN)
	if err != nil {
		scope.Log("client_create: %s", err)
		return &vfilter.Null{}
	}

	err = arg_parser.ExtractArgsWithContext(ctx, scope, args, arg)
	if err != nil {
		scope.Log("client_create: %s", err)
		return &vfilter.Null{}
	}

	err = services.RequireFrontend()
	if err != nil {
		scope.Log("client_create: %v", err)
		return vfilter.Null{}
	}

	config_obj, ok := vql_subsystem.GetServerConfig(scope)
	if !ok {
		scope.Log("client_create: Command can only run on the server")
		return &vfilter.Null{}
	}

	client_info_manager, err := services.GetClientInfoManager(config_obj)
	if err != nil {
		scope.Log("client_create: %s", err)
		return &vfilter.Null{}
	}

	// Normally the client id is generated by the client itself (as a
	// hash of its public key) but for offline clients the client id
	// is pretty random.
	if arg.ClientId == "" {
		arg.ClientId = NewClientId()
	}

	// Create a client record and index with elastic.
	record := &actions_proto.ClientInfo{
		Hostname:     arg.Hostname,
		Fqdn:         arg.Hostname,
		System:       arg.OS,
		Labels:       arg.Labels,
		ClientId:     arg.ClientId,
		MacAddresses: arg.MacAddresses,
	}

	if !arg.FirstSeenAt.IsZero() {
		record.FirstSeenAt = uint64(arg.FirstSeenAt.Unix())
	}

	if !arg.LastSeenAt.IsZero() {
		record.Ping = uint64(arg.LastSeenAt.UnixNano() / 1000)
	}

	err = client_info_manager.Set(ctx, &services.ClientInfo{ClientInfo: record})
	if err != nil {
		scope.Log("client_create: %s", err)
		return &vfilter.Null{}
	}

	indexer, err := services.GetIndexer(config_obj)
	if err != nil {
		scope.Log("client_create: %s", err)
		return &vfilter.Null{}
	}

	// Add the new client to the index.
	for _, term := range []string{
		"all", // This is used for "." search
		record.ClientId,
		"host:" + record.Fqdn,
		"host:" + record.Hostname,
	} {
		err = indexer.SetIndex(arg.ClientId, term)
		if err != nil {
			scope.Log("client_create: %s", err)
			return &vfilter.Null{}
		}
	}

	labeler := services.GetLabeler(config_obj)
	for _, label := range arg.Labels {
		err := labeler.SetClientLabel(ctx, config_obj, arg.ClientId, label)
		if err != nil {
			scope.Log("client_create: %s", err)
			break
		}
	}

	principal := vql_subsystem.GetPrincipal(scope)
	err = services.LogAudit(ctx,
		config_obj, principal, "client_create",
		ordereddict.NewDict().
			Set("client_id", record.ClientId).
			Set("details", record))
	if err != nil {
		logger := logging.GetLogger(config_obj, &logging.FrontendComponent)
		logger.Error("NewClientFunction: client_create %v $%v",
			principal, record)
	}

	return json.ConvertProtoToOrderedDict(record)
}

func (self NewClientFunction) Info(
	scope vfilter.Scope, type_map *vfilter.TypeMap) *vfilter.FunctionInfo {
	return &vfilter.FunctionInfo{
		Name:     "client_create",
		Doc:      "Create a new client in the data store.",
		ArgType:  type_map.AddType(scope, &NewClientArgs{}),
		Metadata: vql.VQLMetadata().Permissions(acls.SERVER_ADMIN).Build(),
	}
}

func init() {
	vql_subsystem.RegisterFunction(&NewClientFunction{})
}

// Generate a new client id
func NewClientId() string {
	buf := make([]byte, 8)
	_, _ = rand.Read(buf)
	dst := make([]byte, hex.EncodedLen(8))
	hex.Encode(dst, buf)
	return "C." + string(dst)
}
