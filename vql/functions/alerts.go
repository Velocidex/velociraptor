package functions

import (
	"context"

	"github.com/Velocidex/ordereddict"
	"www.velocidex.com/golang/velociraptor/json"
	"www.velocidex.com/golang/velociraptor/logging"
	"www.velocidex.com/golang/velociraptor/services"
	"www.velocidex.com/golang/velociraptor/utils"
	vql_subsystem "www.velocidex.com/golang/velociraptor/vql"
	"www.velocidex.com/golang/vfilter"
	"www.velocidex.com/golang/vfilter/types"
)

/*
An alert is a structured log message which is generated by VQL
specifically to be routed into the high priority alert queue on the
server. Alerts are time deduplicated for a long time as they are
meant to just direct attention to some actiivty instead of a running
log of what actually happened.
*/
type AlertFunctionArgs struct {
	AlertName string    `vfilter:"required,field=name,doc=Name of the alert."`
	DedupTime int64     `vfilter:"optional,field=dedup,doc=Suppress same message in this many seconds (default 7200 sec or 2 hours)."`
	Condition types.Any `vfilter:"options,field=condition,doc=If specified we ignore the alert unless the condition is true"`
}

type AlertFunction struct{}

func (self *AlertFunction) Call(ctx context.Context,
	scope vfilter.Scope,
	args *ordereddict.Dict) vfilter.Any {

	defer vql_subsystem.RegisterMonitor(ctx, "alert", args)()

	// If a condition is specified we ignore the alert unless the
	// condition is true
	condition, pres := args.Get("condition")
	if pres && !scope.Bool(condition) {
		return &vfilter.Null{}
	}

	// Make sure all the args are materialized.
	args = vfilter.RowToDict(ctx, scope, args)

	alert_name, pres := args.GetString("name")
	if !pres {
		scope.Log("alert: Alert name must be specified!")
		return &vfilter.Null{}
	}

	dedup_time, _ := args.GetInt64("dedup")
	if dedup_time == 0 {
		dedup_time = 7200
	}

	// Build an EventData
	event_data := ordereddict.NewDict()
	for _, i := range args.Items() {
		switch i.Key {
		case "name", "dedup":
			// skip these fields
		default:
			event_data.Set(i.Key, i.Value)
		}
	}

	// Build a structured alert message
	alert := services.AlertMessage{
		Timestamp: utils.GetTime().Now(),
		AlertName: alert_name,
		EventData: event_data,
	}

	serialized, err := json.Marshal(alert)
	if err != nil {
		scope.Log("alert: %v", err)
		return &vfilter.Null{}
	}

	// Deduplicate alerts based on the alert name. If the alert is to
	// be duduplicated, we send a log at the logging.INFO level in
	// order to preserve the information.

	// The intention here is that the deduplicated ALERT level message
	// be captured by the system and direct attention of the user to a
	// client and time range of interest, where the full details of
	// the alert be further examined.
	log_fuction := &LogFunction{}
	if log_fuction.ShouldMessageBeSuppressed(
		ctx, scope, alert_name, dedup_time) {
		return (&LogFunction{}).Call(ctx, scope, ordereddict.NewDict().
			Set("message", string(serialized)).
			Set("dedup", dedup_time).
			Set("level", logging.INFO))
	}

	return (&LogFunction{}).Call(ctx, scope, ordereddict.NewDict().
		Set("message", string(serialized)).
		Set("dedup", dedup_time).
		Set("level", logging.ALERT))
}

func (self AlertFunction) Info(scope vfilter.Scope, type_map *vfilter.TypeMap) *vfilter.FunctionInfo {
	return &vfilter.FunctionInfo{
		Name:         "alert",
		Doc:          "Generate an alert message.",
		ArgType:      type_map.AddType(scope, &AlertFunctionArgs{}),
		FreeFormArgs: true,
		Version:      2,
	}
}

func init() {
	vql_subsystem.RegisterFunction(&AlertFunction{})
}
