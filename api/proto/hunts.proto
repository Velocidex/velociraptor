syntax = "proto3";

import "www.velocidex.com/golang/velociraptor/proto/semantic.proto";
import "www.velocidex.com/golang/velociraptor/flows/proto/flows.proto";
import "www.velocidex.com/golang/velociraptor/crypto/proto/jobs.proto";
import "www.velocidex.com/golang/velociraptor/actions/proto/vql.proto";
import "www.velocidex.com/golang/velociraptor/flows/proto/artifacts.proto";

package proto;


message HuntConditionGeneric {
    VQLCollectorArgs flow_condition_query = 4 [(sem_type) = {
            description: "A VQL query to run in order to collect information for determining if the hunt applies to this client.",
            friendly_name: "Client Side Condition",
        }];
    VQLCollectorArgs server_side_condition_query = 5 [(sem_type) = {
            description: "A VQL query which runs server side on the results of the flow_condition_query. If any rows are returned then the condition is deemed fulfilled and the hunt will be scheduled."
            friendly_name: "Server Side Condition",
        }];
}

message HuntLabelCondition {
    repeated string label = 1;
}

message HuntOsCondition {
    enum OS {
        ALL = 0;
        WINDOWS = 1;
        LINUX = 2;
        OSX = 3;
    }

    OS os = 1;
}

message HuntCondition {
    option (semantic) = {
        description: "The condition to match hosts for this hunt.",
    };

    oneof union_field {
        HuntConditionGeneric generic_condition = 1 [(sem_type) = {
                friendly_name: "Generic Condition",
                default: '{"flow_condition_query": {"Query": [{"Name": "Collect default client info", "VQL": "SELECT OS, Architecture, Fqdn, Platform, config.Client_labels from info()"}]}, "server_side_condition_query": {"Query": [{"Name": "Select client by info", "VQL": "SELECT * from rows where Fqdn =~ \'.\'"}]}}',
            }];

        HuntLabelCondition labels = 2 [(sem_type) = {
                friendly_name: "Match by label",
            }];

        HuntOsCondition os = 3 [(sem_type) = {
                friendly_name: "Operating System",
            }];
    }
}


message HuntStats {
    uint64 total_clients_scheduled = 9 [(sem_type) = {
            description: "The total number of clients currently scheduled for this hunt.",
            friendly_name: "Total Scheduled",
        }];

    uint64 total_clients_with_results = 14 [(sem_type) = {
            description: "Total number of clients with results.",
            friendly_name: "Total Clients with Results",
        }];

    uint64 total_clients_without_results = 16 [(sem_type) = {
            description: "Total number of clients with out results.",
            friendly_name: "Total Clients without Results",
        }];

    uint64 total_clients_with_errors = 15 [(sem_type) = {
            description: "Total number of clients with errors.",
            friendly_name: "Total Clients with Errors",
        }];

    bool stopped = 1 [(sem_type) = {
            description: "If this is set then the hunt is stopped. This field "
            "is manipulated by the hunt manager."
        }];
}


message Hunt {
    string hunt_id = 1 [(sem_type) = {
            friendly_name: "Hunt ID",
        }];

    uint64 create_time = 2 [(sem_type) = {
            description: "When this hunt was created.",
            friendly_name: "Creation Time",
            type: "RDFDatetime",
        }];

    string creator = 12 [(sem_type) = {
            description: "Who created the hunt?",
        }];

    uint64 start_time = 21 [(sem_type) = {
            description: "When this hunt was actually started.",
            friendly_name: "Start Time",
            type: "RDFDatetime",
        }];

    uint64 expires = 10 [(sem_type) = {
            description: "When does this hunt expire?",
            friendly_name: "Expiry Time",
            type: "RDFDatetime",
        }];

    string hunt_description = 11 [(sem_type) = {
            description: "Hunt's description",
        }];

    ArtifactCollectorArgs start_request = 16 [(sem_type) = {
            description: "Launch this collection on the client if the condition is true",
        }];

    HuntCondition condition = 4 [(sem_type) = {
            description: "The condition that must be satisfied for the hunt to be scheduled.",
            friendly_name: "Hunt Condition",
        }];

    uint64 client_limit = 6 [(sem_type) = {
            description: "Total number of clients this hunt will run on."
        }];

    HuntStats stats = 18;

    repeated string artifacts = 17 [(sem_type) = {
            description: "A list of artifacts this hunt produces.",
        }];

    repeated string artifact_sources = 19 [(sem_type) = {
            description: "A list of artifact sources this hunt produces.",
        }];

    enum State {
        UNSET = 0;
        PAUSED = 1 [(description) = "Hunt will not schedule new clients but can be started."];
        RUNNING = 2 [(description) = "Hunt is running and ready."];
        STOPPED = 3 [(description) = "Hunt has stopped."];
        ARCHIVED = 4 [(description) = "Hunt has been archived."];
    };

    State state = 8 [(sem_type) = {
            description: "This is state of the hunt. This field is manupulated by the GUI."
        }];
}

message ListHuntsRequest {
    uint64 offset = 1;
    uint64 count = 2;
    bool include_archived = 3;
}

message ListHuntsResponse {
    repeated Hunt items = 1;
}

message GetHuntRequest {
    string hunt_id = 1;
}

message GetHuntResultsRequest {
    uint64 offset = 1;
    uint64 count = 2;
    string hunt_id = 3;
    string artifact = 4;
}
